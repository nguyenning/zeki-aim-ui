"use strict";var Wt=Object.defineProperty,Bt=Object.defineProperties,Ht=Object.getOwnPropertyDescriptors,Je=Object.getOwnPropertySymbols,Gt=Object.prototype.hasOwnProperty,Kt=Object.prototype.propertyIsEnumerable,Ze=(he,Q,g)=>Q in he?Wt(he,Q,{enumerable:!0,configurable:!0,writable:!0,value:g}):he[Q]=g,Re=(he,Q)=>{for(var g in Q||(Q={}))Gt.call(Q,g)&&Ze(he,g,Q[g]);if(Je)for(var g of Je(Q))Kt.call(Q,g)&&Ze(he,g,Q[g]);return he},De=(he,Q)=>Bt(he,Ht(Q));(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[9651],{13160:(he,Q,g)=>{var X,k,b;g.d(Q,{E9:()=>M,I6:()=>J,Vl:()=>X,bN:()=>H}),(b=X||(X={}))[b.Unknown=0]="Unknown",b[b.Point=1]="Point",b[b.LineString=2]="LineString",b[b.Polygon=3]="Polygon";class M{constructor(r,a){this.x=r,this.y=a}clone(){return new M(this.x,this.y)}equals(r,a){return r===this.x&&a===this.y}isEqual(r){return r.x===this.x&&r.y===this.y}setCoords(r,a){this.x=r,this.y=a}normalize(){const r=this.x,a=this.y,_=Math.sqrt(r*r+a*a);this.x/=_,this.y/=_}rightPerpendicular(){const r=this.x;this.x=this.y,this.y=-r}move(r,a){this.x+=r,this.y+=a}assign(r){this.x=r.x,this.y=r.y}assignAdd(r,a){this.x=r.x+a.x,this.y=r.y+a.y}assignSub(r,a){this.x=r.x-a.x,this.y=r.y-a.y}rotate(r,a){const _=this.x,y=this.y;this.x=_*r-y*a,this.y=_*a+y*r}scale(r){this.x*=r,this.y*=r}length(){const r=this.x,a=this.y;return Math.sqrt(r*r+a*a)}static distance(r,a){const _=a.x-r.x,y=a.y-r.y;return Math.sqrt(_*_+y*y)}static add(r,a){return new M(r.x+a.x,r.y+a.y)}static sub(r,a){return new M(r.x-a.x,r.y-a.y)}}class se{constructor(r,a,_){this.ratio=r,this.x=a,this.y=_}}class H{constructor(r,a,_,y=8,u=8){this._lines=[],this._starts=[],this.validateTessellation=!0,this._pixelRatio=y,this._pixelMargin=u,this._tileSize=512*y,this._dz=r,this._yPos=a,this._xPos=_}setPixelMargin(r){r!==this._pixelMargin&&(this._pixelMargin=r,this.setExtent(this._extent))}setExtent(r){this._extent=r,this._finalRatio=this._tileSize/r*(1<<this._dz);let a=this._pixelRatio*this._pixelMargin;a/=this._finalRatio;const _=r>>this._dz;a>_&&(a=_),this._margin=a,this._xmin=_*this._xPos-a,this._ymin=_*this._yPos-a,this._xmax=this._xmin+_+2*a,this._ymax=this._ymin+_+2*a}reset(r){this._type=r,this._lines=[],this._starts=[],this._line=null,this._start=0}moveTo(r,a){this._pushLine(),this._prevIsIn=this._isIn(r,a),this._moveTo(r,a,this._prevIsIn),this._prevPt=new M(r,a),this._firstPt=new M(r,a),this._dist=0}lineTo(r,a){const _=this._isIn(r,a),y=new M(r,a),u=M.distance(this._prevPt,y);let v,w,m,f,ne,re,$,q;if(_)this._prevIsIn?this._lineTo(r,a,!0):(v=this._prevPt,w=y,m=this._intersect(w,v),this._start=this._dist+u*(1-this._r),this._lineTo(m.x,m.y,!0),this._lineTo(w.x,w.y,!0));else if(this._prevIsIn)w=this._prevPt,v=y,m=this._intersect(w,v),this._lineTo(m.x,m.y,!0),this._lineTo(v.x,v.y,!1);else{const I=this._prevPt,F=y;if(I.x<=this._xmin&&F.x<=this._xmin||I.x>=this._xmax&&F.x>=this._xmax||I.y<=this._ymin&&F.y<=this._ymin||I.y>=this._ymax&&F.y>=this._ymax)this._lineTo(F.x,F.y,!1);else{const G=[];if((I.x<this._xmin&&F.x>this._xmin||I.x>this._xmin&&F.x<this._xmin)&&(f=(this._xmin-I.x)/(F.x-I.x),q=I.y+f*(F.y-I.y),q<=this._ymin?re=!1:q>=this._ymax?re=!0:G.push(new se(f,this._xmin,q))),(I.x<this._xmax&&F.x>this._xmax||I.x>this._xmax&&F.x<this._xmax)&&(f=(this._xmax-I.x)/(F.x-I.x),q=I.y+f*(F.y-I.y),q<=this._ymin?re=!1:q>=this._ymax?re=!0:G.push(new se(f,this._xmax,q))),(I.y<this._ymin&&F.y>this._ymin||I.y>this._ymin&&F.y<this._ymin)&&(f=(this._ymin-I.y)/(F.y-I.y),$=I.x+f*(F.x-I.x),$<=this._xmin?ne=!1:$>=this._xmax?ne=!0:G.push(new se(f,$,this._ymin))),(I.y<this._ymax&&F.y>this._ymax||I.y>this._ymax&&F.y<this._ymax)&&(f=(this._ymax-I.y)/(F.y-I.y),$=I.x+f*(F.x-I.x),$<=this._xmin?ne=!1:$>=this._xmax?ne=!0:G.push(new se(f,$,this._ymax))),0===G.length)this._lineTo(ne?this._xmax:this._xmin,re?this._ymax:this._ymin,!0);else if(G.length>1&&G[0].ratio>G[1].ratio)this._start=this._dist+u*G[1].ratio,this._lineTo(G[1].x,G[1].y,!0),this._lineTo(G[0].x,G[0].y,!0);else{this._start=this._dist+u*G[0].ratio;for(let te=0;te<G.length;te++)this._lineTo(G[te].x,G[te].y,!0)}this._lineTo(F.x,F.y,!1)}}this._dist+=u,this._prevIsIn=_,this._prevPt=y}close(){if(this._line.length>2){const r=this._firstPt,a=this._prevPt;r.x===a.x&&r.y===a.y||this.lineTo(r.x,r.y);const _=this._line;let y=_.length;for(;y>=4&&(_[0].x===_[1].x&&_[0].x===_[y-2].x||_[0].y===_[1].y&&_[0].y===_[y-2].y);)_.pop(),_[0].x=_[y-2].x,_[0].y=_[y-2].y,--y}}result(r=!0){return this._pushLine(),0===this._lines.length?null:(this._type===X.Polygon&&r&&ie.simplify(this._tileSize,this._margin*this._finalRatio,this._lines),this._lines)}resultWithStarts(){if(this._type!==X.LineString)throw new Error("Only valid for lines");this._pushLine();const r=this._lines,a=r.length;if(0===a)return null;const _=[];for(let y=0;y<a;y++)_.push({line:r[y],start:this._starts[y]||0});return _}_isIn(r,a){return r>=this._xmin&&r<=this._xmax&&a>=this._ymin&&a<=this._ymax}_intersect(r,a){let _,y,u;if(a.x>=this._xmin&&a.x<=this._xmax)y=a.y<=this._ymin?this._ymin:this._ymax,u=(y-r.y)/(a.y-r.y),_=r.x+u*(a.x-r.x);else if(a.y>=this._ymin&&a.y<=this._ymax)_=a.x<=this._xmin?this._xmin:this._xmax,u=(_-r.x)/(a.x-r.x),y=r.y+u*(a.y-r.y);else{y=a.y<=this._ymin?this._ymin:this._ymax,_=a.x<=this._xmin?this._xmin:this._xmax;const v=(_-r.x)/(a.x-r.x),w=(y-r.y)/(a.y-r.y);v<w?(u=v,y=r.y+v*(a.y-r.y)):(u=w,_=r.x+w*(a.x-r.x))}return this._r=u,new M(_,y)}_pushLine(){this._line&&(this._type===X.Point?this._line.length>0&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===X.LineString?this._line.length>1&&(this._lines.push(this._line),this._starts.push(this._start)):this._type===X.Polygon&&this._line.length>3&&(this._lines.push(this._line),this._starts.push(this._start))),this._line=[],this._start=0}_moveTo(r,a,_){this._type!==X.Polygon?_&&(r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.push(new M(r,a))):(_||(r<this._xmin&&(r=this._xmin),r>this._xmax&&(r=this._xmax),a<this._ymin&&(a=this._ymin),a>this._ymax&&(a=this._ymax)),r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.push(new M(r,a)),this._isH=!1,this._isV=!1)}_lineTo(r,a,_){let y,u;if(this._type!==X.Polygon)if(_){if(r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line.length>0&&(y=this._line[this._line.length-1],y.equals(r,a)))return;this._line.push(new M(r,a))}else this._line&&this._line.length>0&&this._pushLine();else if(_||(r<this._xmin&&(r=this._xmin),r>this._xmax&&(r=this._xmax),a<this._ymin&&(a=this._ymin),a>this._ymax&&(a=this._ymax)),r=Math.round((r-(this._xmin+this._margin))*this._finalRatio),a=Math.round((a-(this._ymin+this._margin))*this._finalRatio),this._line&&this._line.length>0){y=this._line[this._line.length-1];const v=y.x===r,w=y.y===a;if(v&&w)return;this._isH&&v||this._isV&&w?(y.x=r,y.y=a,u=this._line[this._line.length-2],u.x===r&&u.y===a?(this._line.pop(),this._line.length<=1?(this._isH=!1,this._isV=!1):(u=this._line[this._line.length-2],this._isH=u.x===r,this._isV=u.y===a)):(this._isH=u.x===r,this._isV=u.y===a)):(this._line.push(new M(r,a)),this._isH=v,this._isV=w)}else this._line.push(new M(r,a))}}class J{setExtent(r){this._ratio=4096===r?1:4096/r}get validateTessellation(){return this._ratio<1}reset(r){this._lines=[],this._line=null}moveTo(r,a){this._line&&this._lines.push(this._line),this._line=[];const _=this._ratio;this._line.push(new M(r*_,a*_))}lineTo(r,a){const _=this._ratio;this._line.push(new M(r*_,a*_))}close(){const r=this._line;r&&!r[0].isEqual(r[r.length-1])&&r.push(r[0])}result(){return this._line&&this._lines.push(this._line),0===this._lines.length?null:this._lines}}!function(b){b[b.sideLeft=0]="sideLeft",b[b.sideRight=1]="sideRight",b[b.sideTop=2]="sideTop",b[b.sideBottom=3]="sideBottom"}(k||(k={}));class ie{static simplify(r,a,_){if(!_)return;const y=-a,u=r+a,v=-a,w=r+a,m=[],f=[],ne=_.length;for(let $=0;$<ne;++$){const q=_[$];if(!q||q.length<2)continue;let I,F=q[0];const G=q.length;for(let te=1;te<G;++te)I=q[te],F.x===I.x&&(F.x<=y&&(F.y>I.y?(m.push($),m.push(te),m.push(k.sideLeft),m.push(-1)):(f.push($),f.push(te),f.push(k.sideLeft),f.push(-1))),F.x>=u&&(F.y<I.y?(m.push($),m.push(te),m.push(k.sideRight),m.push(-1)):(f.push($),f.push(te),f.push(k.sideRight),f.push(-1)))),F.y===I.y&&(F.y<=v&&(F.x<I.x?(m.push($),m.push(te),m.push(k.sideTop),m.push(-1)):(f.push($),f.push(te),f.push(k.sideTop),f.push(-1))),F.y>=w&&(F.x>I.x?(m.push($),m.push(te),m.push(k.sideBottom),m.push(-1)):(f.push($),f.push(te),f.push(k.sideBottom),f.push(-1)))),F=I}if(0===m.length||0===f.length)return;ie.fillParent(_,f,m),ie.fillParent(_,m,f);const re=[];ie.calcDeltas(re,f,m),ie.calcDeltas(re,m,f),ie.addDeltas(re,_)}static fillParent(r,a,_){const y=_.length,u=a.length;for(let v=0;v<u;v+=4){const w=a[v],m=a[v+1],f=a[v+2],ne=r[w][m-1],re=r[w][m];let $=8092,q=-1;for(let I=0;I<y;I+=4){if(_[I+2]!==f)continue;const F=_[I],G=_[I+1],te=r[F][G-1],pe=r[F][G];switch(f){case k.sideLeft:case k.sideRight:if(ee(ne.y,te.y,pe.y)&&ee(re.y,te.y,pe.y)){const _e=Math.abs(pe.y-te.y);_e<$&&($=_e,q=I)}break;case k.sideTop:case k.sideBottom:if(ee(ne.x,te.x,pe.x)&&ee(re.x,te.x,pe.x)){const _e=Math.abs(pe.x-te.x);_e<$&&($=_e,q=I)}}}a[v+3]=q}}static calcDeltas(r,a,_){const y=a.length;for(let u=0;u<y;u+=4){const w=ie.calcDelta(u,a,_,[]);r.push(a[u]),r.push(a[u+1]),r.push(a[u+2]),r.push(w)}}static calcDelta(r,a,_,y){const u=a[r+3];if(-1===u)return 0;const v=y.length;return v>1&&y[v-2]===u?0:(y.push(u),ie.calcDelta(u,_,a,y)+1)}static addDeltas(r,a){const _=r.length;let y=0;for(let u=0;u<_;u+=4){const v=r[u+3];v>y&&(y=v)}for(let u=0;u<_;u+=4){const v=a[r[u]],w=r[u+1],m=y-r[u+3];switch(r[u+2]){case k.sideLeft:v[w-1].x-=m,v[w].x-=m,1===w&&(v[v.length-1].x-=m),w===v.length-1&&(v[0].x-=m);break;case k.sideRight:v[w-1].x+=m,v[w].x+=m,1===w&&(v[v.length-1].x+=m),w===v.length-1&&(v[0].x+=m);break;case k.sideTop:v[w-1].y-=m,v[w].y-=m,1===w&&(v[v.length-1].y-=m),w===v.length-1&&(v[0].y-=m);break;case k.sideBottom:v[w-1].y+=m,v[w].y+=m,1===w&&(v[v.length-1].y+=m),w===v.length-1&&(v[0].y+=m)}}}}const ee=(b,r,a)=>b>=r&&b<=a||b>=a&&b<=r},26996:(he,Q,g)=>{g.d(Q,{Y:()=>M,m:()=>se});var j=g(36161),X=g(21286);function M(H,J,ie){const ee=(0,X.fp)(Math.ceil(ie)),b=(H=>"vertical"===H||"horizontal"===H||"cross"===H||"esriSFSCross"===H||"esriSFSVertical"===H||"esriSFSHorizontal"===H)(J)?8*ee:16*ee,r=2*ee;H.width=b,H.height=b;const a=H.getContext("2d");a.strokeStyle="#FFFFFF",a.lineWidth=ee,a.beginPath(),"vertical"!==J&&"cross"!==J&&"esriSFSCross"!==J&&"esriSFSVertical"!==J||(a.moveTo(b/2,-r),a.lineTo(b/2,b+r)),"horizontal"!==J&&"cross"!==J&&"esriSFSCross"!==J&&"esriSFSHorizontal"!==J||(a.moveTo(-r,b/2),a.lineTo(b+r,b/2)),"forward-diagonal"!==J&&"diagonal-cross"!==J&&"esriSFSDiagonalCross"!==J&&"esriSFSForwardDiagonal"!==J||(a.moveTo(-r,-r),a.lineTo(b+r,b+r),a.moveTo(b-r,-r),a.lineTo(b+r,r),a.moveTo(-r,b-r),a.lineTo(r,b+r)),"backward-diagonal"!==J&&"diagonal-cross"!==J&&"esriSFSBackwardDiagonal"!==J&&"esriSFSDiagonalCross"!==J||(a.moveTo(b+r,-r),a.lineTo(-r,b+r),a.moveTo(r,-r),a.lineTo(-r,r),a.moveTo(b+r,b-r),a.lineTo(b-r,b+r)),a.stroke();const _=a.getImageData(0,0,H.width,H.height),y=new Uint8Array(_.data);let u;for(let v=0;v<y.length;v+=4)u=y[v+3]/255,y[v]=y[v]*u,y[v+1]=y[v+1]*u,y[v+2]=y[v+2]*u;return[y,H.width,H.height]}function se(H,J){const ie="Butt"===J,ee="Square"===J,b=!ie&&!ee;H.length%2==1&&(H=[...H,...H]);const r=15.5;let _=0;for(const q of H)_+=q;const y=Math.round(_*r),u=new Float32Array(31*y),v=7.75;let w=0,m=0,f=.5,ne=!0;for(const q of H){for(w=m,m+=q*r;f<=m;){let I=.5;for(;I<31;){const F=(I-.5)*y+f-.5,G=b?(I-r)*(I-r):Math.abs(I-r);u[F]=ne?ie?Math.max(Math.max(w+v-f,G),Math.max(f-m+v,G)):G:b?Math.min((f-w)*(f-w)+G,(f-m)*(f-m)+G):ee?Math.min(Math.max(f-w,G),Math.max(m-f,G)):Math.min(Math.max(f-w+v,G),Math.max(m+v-f,G)),I++}f++}ne=!ne}const re=u.length,$=new Uint8Array(4*re);for(let q=0;q<re;++q){const I=(b?Math.sqrt(u[q]):u[q])/r;(0,j.I)(I,$,4*q)}return[$,y,31]}},86575:(he,Q,g)=>{g.d(Q,{B1:()=>j,DQ:()=>ie,DT:()=>H,JJ:()=>X,Or:()=>ee,_U:()=>k,k3:()=>r,sX:()=>_});const j=Number.POSITIVE_INFINITY,X=Math.PI,k=2*X,M=128/X,H=X/180,J=1/Math.LN2;function ie(u,v){return(u%=v)>=0?u:u+v}function ee(u){return ie(u*M,256)}function r(u){return Math.log(u)*J}function _(u,v,w){return u*(1-w)+v*w}},84439:(he,Q,g)=>{g.d(Q,{Z:()=>j});class j{constructor(k=0,M=0,se=0,H=0){this.x=k,this.y=M,this.width=se,this.height=H}get isEmpty(){return this.width<=0||this.height<=0}union(k){this.x=Math.min(this.x,k.x),this.y=Math.min(this.y,k.y),this.width=Math.max(this.width,k.width),this.height=Math.max(this.height,k.height)}}},5254:(he,Q,g)=>{g.d(Q,{Au:()=>a,Jz:()=>u,UJ:()=>y});const j=new Float32Array(1);function a(m){return[255&m,(65280&m)>>>8,(16711680&m)>>>16,(4278190080&m)>>>24]}function y(m,f){return 65535&m|f<<16}function u(m,f,ne,re){return 255&m|(255&f)<<8|(255&ne)<<16|re<<24}new Uint32Array(j.buffer)},19702:(he,Q,g)=>{g.d(Q,{A:()=>r});var j=g(15861),X=g(17626),k=g(54024),M=g(10699),se=g(32917),H=g(77712),ee=(g(90912),g(85931),g(76898)),b=g(36947);const r=a=>{let _=class extends a{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(y){super.postscript(y),(0,b.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}_validateHeightModelInfo(){var y=this;return(0,j.Z)(function*(){const u=new AbortController,v=u.signal;y.handles.add((0,k.kB)(()=>u.abort())),yield(0,se.N1)(()=>{var m;return null==(m=y.view.defaultsFromMap)?void 0:m.heightModelInfoReady},v),(0,M.k_)(v);const w=(0,b.Wt)(y.layer,y.view.heightModelInfo,y.supportsHeightUnitConversion);if(w)throw w})()}canResume(){const y=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!y||!y.minScale||!y.maxScale||y.minScale>=y.maxScale)}getSuspendInfo(){const y=super.getSuspendInfo(),u=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return u&&u.minScale&&u.maxScale&&u.minScale<u.maxScale&&(y.outsideScaleRange=!0),y}};return(0,X._)([(0,H.Cb)()],_.prototype,"view",void 0),(0,X._)([(0,H.Cb)()],_.prototype,"slicePlaneEnabled",void 0),_=(0,X._)([(0,ee.j)("esri.views.3d.layers.LayerView3D")],_),_}},63038:(he,Q,g)=>{g.r(Q),g.d(Q,{default:()=>Vt});var j=g(15861),X=g(17626),k=g(26584),M=g(62208),se=g(10699),H=g(32917),J=g(77712),b=(g(90912),g(85931),g(76898));class r{constructor(e,i){this._lockedSchemaPixelSize=e,this._isGCS=i}getLevelRowColumn(e){return this._isGCS?[e[0],e[1]>>1,e[2]>>1]:256===this._lockedSchemaPixelSize&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this._isGCS?e:256===this._lockedSchemaPixelSize?e>0?e-1:0:e}getShift(e,i){let t=0,n=0;return(256===this._lockedSchemaPixelSize||this._isGCS)&&(e[2]%2&&(t=i),e[1]%2&&(n=i)),[t,n]}getScale(e){if(this._isGCS){if(512===this._lockedSchemaPixelSize)return 4}else if(256===this._lockedSchemaPixelSize&&0===e)return 1;return 2}}var a=g(1036),_=g(49966),y=g(65401),u=g(21726),v=g(59289),w=g(84439);class m{constructor(e,i){this._width=0,this._height=0,this._free=[],this._width=e,this._height=i,this._free.push(new w.Z(0,0,e,i))}get width(){return this._width}get height(){return this._height}allocate(e,i){if(e>this._width||i>this._height)return new w.Z;let t=null,n=-1;for(let s=0;s<this._free.length;++s){const o=this._free[s];e<=o.width&&i<=o.height&&(null===t||o.y<=t.y&&o.x<=t.x)&&(t=o,n=s)}return null===t?new w.Z:(this._free.splice(n,1),t.width<t.height?(t.width>e&&this._free.push(new w.Z(t.x+e,t.y,t.width-e,i)),t.height>i&&this._free.push(new w.Z(t.x,t.y+i,t.width,t.height-i))):(t.width>e&&this._free.push(new w.Z(t.x+e,t.y,t.width-e,t.height)),t.height>i&&this._free.push(new w.Z(t.x,t.y+i,e,t.height-i))),new w.Z(t.x,t.y,e,i))}release(e){for(let i=0;i<this._free.length;++i){const t=this._free[i];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(i,1),this.release(e)}this._free.push(e)}}var f=g(67969),ne=g(55086);class re{constructor(e,i,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=i,this._glyphSource=t,this._binPack=new m(e-4,i-4),this._glyphData.push(new Uint8Array(e*i)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,i){const t=[],n=this._glyphSource,s=new Set;for(const h of i){const c=Math.floor(.00390625*h);s.add(c)}const l=[];return s.forEach(h=>{if(h<=256){const c=e+h;if(this._rangePromises.has(c))l.push(this._rangePromises.get(c));else{const x=n.getRange(e,h).then(()=>{this._rangePromises.delete(c)},()=>{this._rangePromises.delete(c)});this._rangePromises.set(c,x),l.push(x)}}}),Promise.all(l).then(()=>{let h=this._glyphIndex[e];h||(h={},this._glyphIndex[e]=h);for(const c of i){const x=h[c];if(x){t[c]={sdf:!0,rect:x.rect,metrics:x.metrics,page:x.page,code:c};continue}const P=n.getGlyph(e,c);if(!P||!P.metrics)continue;const S=P.metrics;let d;if(0===S.width)d=new w.Z(0,0,0,0);else{const R=S.width+6,E=S.height+6;let T=R%4?4-R%4:4,D=E%4?4-E%4:4;1===T&&(T=5),1===D&&(D=5),d=this._binPack.allocate(R+T,E+D),d.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new m(this.width-4,this.height-4),d=this._binPack.allocate(R+T,E+D));const W=this._glyphData[this._currentPage],N=P.bitmap;let U,O;if(N)for(let z=0;z<E;z++){U=R*z,O=this.width*(d.y+z+1)+d.x;for(let L=0;L<R;L++)W[O+L+1]=N[U+L]}}h[c]={rect:d,metrics:S,tileIDs:null,page:this._currentPage},t[c]={sdf:!0,rect:d,metrics:S,page:this._currentPage,code:c},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const i in this._glyphIndex){const t=this._glyphIndex[i];if(!t)continue;let n;for(const s in t)if(n=t[s],n.tileIDs.delete(e),0===n.tileIDs.size){const o=this._glyphData[n.page],l=n.rect;let h,c;for(let x=0;x<l.height;x++)for(h=this.width*(l.y+x)+l.x,c=0;c<l.width;c++)o[h+c]=0;delete t[s],this._dirties[n.page]=!0}}}bind(e,i,t,n=0){this._textures[t]||(this._textures[t]=new ne.x(e,{pixelFormat:f.VI.ALPHA,dataType:f.Br.UNSIGNED_BYTE,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const s=this._textures[t];s.setSamplingMode(i),this._dirties[t]&&s.setData(this._glyphData[t]),e.bindTexture(s,n),this._dirties[t]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var $=g(84792),q=g(24192);class I{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const i=e.getMessage();for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage();let n,s,o,l,h,c,x;for(;t.next();)switch(t.tag()){case 1:n=t.getUInt32();break;case 2:s=t.getBytes();break;case 3:o=t.getUInt32();break;case 4:l=t.getUInt32();break;case 5:h=t.getSInt32();break;case 6:c=t.getSInt32();break;case 7:x=t.getUInt32();break;default:t.skip()}t.release(),n&&(this._metrics[n]={width:o,height:l,left:h,top:c,advance:x},this._bitmaps[n]=s);break}default:i.skip()}i.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class F{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,i){this._ranges[e]=i}}class G{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,i){const t=this._getFontStack(e);if(t.getRange(i))return Promise.resolve();const n=256*i,s=n+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+s);return(0,$.default)(o,{responseType:"array-buffer"}).then(l=>{t.addRange(i,new I(new q.Z(new Uint8Array(l.data),new DataView(l.data))))}).catch(()=>{t.addRange(i,new I)})}return t.addRange(i,new I),Promise.resolve()}getGlyph(e,i){const t=this._getFontStack(e);if(!t)return;const n=Math.floor(i/256);if(n>256)return;const s=t.getRange(n);return s?{metrics:s.getMetrics(i),bitmap:s.getBitmap(i)}:void 0}_getFontStack(e){let i=this._glyphInfo[e];return i||(i=this._glyphInfo[e]=new F),i}}var te=g(26996);class _e{constructor(e,i,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||i<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=i,t>0&&(this._maxItemSize=t),this._binPack=new m(e-4,i-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new m(this._pageWidth-4,this._pageHeight-4);const i=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),n=new Uint32Array(i*t);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,i=!1){let t,n,s=this._mosaicRects[e];if(s)return s;if(!this._sprites||"loaded"!==this._sprites.loadStatus||(e&&e.startsWith("dasharray-")?([t,n]=this._rasterizeDash(e),i=!0):t=this._sprites.getSpriteInfo(e),!t||!t.width||!t.height||t.width<0||t.height<0))return null;const o=t.width,l=t.height,[h,c,x]=this._allocateImage(o,l);return h.width<=0?null:(this._copy(h,t,c,x,i,n),s={rect:h,width:o,height:l,sdf:t.sdf,simplePattern:!1,pixelRatio:t.pixelRatio,page:c},this._mosaicRects[e]=s,s)}getSpriteItems(e){const i={};for(const t of e)i[t.name]=this.getSpriteItem(t.name,t.repeat);return i}getMosaicItemPosition(e,i){const t=this.getSpriteItem(e,i),n=t&&t.rect;return n?(n.width=t.width,n.height=t.height,{tl:[n.x+2,n.y+2],br:[n.x+2+t.width,n.y+2+t.height],page:t.page}):null}bind(e,i,t=0,n=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;this._textures[t]||(this._textures[t]=new ne.x(e,{pixelFormat:f.VI.RGBA,dataType:f.Br.UNSIGNED_BYTE,wrapMode:f.e8.CLAMP_TO_EDGE,width:this._size[t][0],height:this._size[t][1]},new Uint8Array(this._mosaicsData[t].buffer)));const s=this._textures[t];s.setSamplingMode(i),this._dirties[t]&&s.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(s,n),this._dirties[t]=!1}static _copyBits(e,i,t,n,s,o,l,h,c,x,P){let S=n*i+t,d=h*o+l;if(P){d-=o;for(let C=-1;C<=x;C++,S=((C+x)%x+n)*i+t,d+=o)for(let R=-1;R<=c;R++)s[d+R]=e[S+(R+c)%c]}else for(let C=0;C<x;C++){for(let R=0;R<c;R++)s[d+R]=e[S+R];S+=i,d+=o}}_copy(e,i,t,n,s,o){if(!this._sprites||"loaded"!==this._sprites.loadStatus||t>=this._mosaicsData.length)return;const l=new Uint32Array(o?o.buffer:this._sprites.image.buffer),h=this._mosaicsData[t];h&&l||console.error("Source or target images are uninitialized!"),_e._copyBits(l,o?i.width:this._sprites.width,i.x,i.y,h,n[0],e.x+2,e.y+2,i.width,i.height,s),this._dirties[t]=!0}_allocateImage(e,i){e+=2,i+=2;const t=Math.max(e,i);if(this._maxItemSize&&this._maxItemSize<t){const l=new w.Z(0,0,e,i);return this._mosaicsData.push(new Uint32Array(e*i)),this._dirties.push(!0),this._size.push([e,i]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[e,i]]}let n=e%4?4-e%4:4,s=i%4?4-i%4:4;1===n&&(n=5),1===s&&(s=5);const o=this._binPack.allocate(e+n,i+s);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new m(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,i)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const n=t[1].split(",").map(Number),s=e.slice(e.lastIndexOf("-")+1),[o,l,h]=(0,te.m)(n,s);return[{x:0,y:0,width:l,height:h,sdf:!0,pixelRatio:1},new Uint8Array(o.buffer)]}}var xe=g(58098),Ye=g(54540),$e=g(51200),Ie=g(47132),Se=g(76763),K=g(1268);function qe(p,e,i,t,n,s){const{iconRotationAlignment:o,textRotationAlignment:l,iconTranslate:h,iconTranslateAnchor:c,textTranslate:x,textTranslateAnchor:P}=t;let S=0;for(const d of p.colliders){const[C,R]=0===d.partIndex?h:x,E=0===d.partIndex?c:P,T=d.minLod<=s&&s<=d.maxLod;S+=T?0:1,d.enabled=T,d.xScreen=d.xTile*n[0]+d.yTile*n[3]+n[6],d.yScreen=d.xTile*n[1]+d.yTile*n[4]+n[7],E===K.fD.MAP?(d.xScreen+=i*C-e*R,d.yScreen+=e*C+i*R):(d.xScreen+=C,d.yScreen+=R),K.aF.VIEWPORT===(0===d.partIndex?o:l)?(d.dxScreen=d.dxPixels,d.dyScreen=d.dyPixels):(d.dxScreen=i*(d.dxPixels+d.width/2)-e*(d.dyPixels+d.height/2)-d.width/2,d.dyScreen=e*(d.dxPixels+d.width/2)+i*(d.dyPixels+d.height/2)-d.height/2)}p.colliders.length>0&&S===p.colliders.length&&(p.unique.show=!1)}class Qe{constructor(e,i,t,n,s,o){this._symbols=e,this._styleRepository=n,this._zoom=s,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new Se.HX(i,t,Ie.PF),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const l of e)for(const h of l.symbols)this._allNeededMatrices.has(h.tile)||this._allNeededMatrices.set(h.tile,(0,_.a)(h.tile.transforms.tileUnitsToPixels))}work(e){const i=this._gridIndex;function t(s){const o=s.xScreen+s.dxScreen,l=s.yScreen+s.dyScreen,h=o+s.width,c=l+s.height,[x,P,S,d]=i.getCellSpan(o,l,h,c);for(let C=P;C<=d;C++)for(let R=x;R<=S;R++){const E=i.cells[C][R];for(const T of E){const D=T.xScreen+T.dxScreen,W=T.yScreen+T.dyScreen,N=D+T.width,U=W+T.height;if(!(h<D||o>N||c<W||l>U))return!0}}return!1}const n=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],o=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-n>e)return!1;const l=s.symbols[this._currentSymbolCursor];if(!l.unique.show)continue;qe(l,this._si,this._co,o,this._allNeededMatrices.get(l.tile),this._zoom);const h=l.unique;if(!h.show)continue;const{iconAllowOverlap:c,iconIgnorePlacement:x,textAllowOverlap:P,textIgnorePlacement:S}=o;for(const d of l.colliders){if(!d.enabled)continue;const C=h.parts[d.partIndex];!C.show||!(d.partIndex?P:c)&&t(d)&&(d.hard?h.show=!1:C.show=!1)}if(h.show)for(const d of l.colliders){if(!d.enabled||(d.partIndex?S:x)||!h.parts[d.partIndex].show)continue;const C=d.xScreen+d.dxScreen,R=d.yScreen+d.dyScreen,E=C+d.width,T=R+d.height,[D,W,N,U]=this._gridIndex.getCellSpan(C,R,E,T);for(let O=W;O<=U;O++)for(let z=D;z<=N;z++)this._gridIndex.cells[O][z].push(d)}}}return!0}_getProperties(e){const i=this._styleProps.get(e);if(i)return i;const t=this._zoom,n=this._styleRepository.getStyleLayerByUID(e),s=n.getLayoutValue("symbol-placement",t)!==K.R.POINT;let o=n.getLayoutValue("icon-rotation-alignment",t);o===K.aF.AUTO&&(o=s?K.aF.MAP:K.aF.VIEWPORT);let l=n.getLayoutValue("text-rotation-alignment",t);l===K.aF.AUTO&&(l=s?K.aF.MAP:K.aF.VIEWPORT);const h=n.getPaintValue("icon-translate",t),c=n.getPaintValue("icon-translate-anchor",t),x=n.getPaintValue("text-translate",t),P=n.getPaintValue("text-translate-anchor",t),S={iconAllowOverlap:n.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:n.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:n.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:n.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:o,textRotationAlignment:l,iconTranslateAnchor:c,iconTranslate:h,textTranslateAnchor:P,textTranslate:x};return this._styleProps.set(e,S),S}}function et(p,e){if(p.priority-e.priority)return p.priority-e.priority;const i=p.tile.key,t=e.tile.key;return i.world-t.world?i.world-t.world:i.level-t.level?i.level-t.level:i.row-t.row?i.row-t.row:i.col-t.col?i.col-t.col:p.xTile-e.xTile?p.xTile-e.xTile:p.yTile-e.yTile}class tt{get running(){return this._running}constructor(e,i,t,n,s,o){this._visibleTiles=e,this._symbolRepository=i,this._createCollisionJob=t,this._assignTileSymbolsOpacity=n,this._symbolLayerSorter=s,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(e,i){this._screenWidth===e&&this._screenHeight===i||this.restart(),this._screenWidth=e,this._screenHeight=i}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const i=performance.now();if(!this._selectionJob.work(e)||(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const i=performance.now();if(!this._collisionJob.work(e)||(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const i=performance.now();if(!this._opacityJob.work(e)||(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols;for(let h=0;h<e.length;h++){const c=e[h];for(let x=0;x<c.uniqueSymbols.length;x++){const P=c.uniqueSymbols[x];for(const S of P.tileSymbols)S.selectedForRendering=!1}}const i=[];let t=0,n=0;const s=this._isLayerVisible,l=this._symbolLayerSorter;return{work:function o(h){let c;const x=performance.now();for(;n<e.length;n++,t=0){const P=e[n],S=P.styleLayerUID;if(!s(S)){i[n]||(i[n]={styleLayerUID:S,symbols:[]});continue}i[n]=i[n]||{styleLayerUID:S,symbols:[]};const d=i[n];for(;t<P.uniqueSymbols.length;t++){if(c=P.uniqueSymbols[t],t%100==99&&performance.now()-x>h)return!1;let C=null,R=!1,E=!1;for(const T of c.tileSymbols)if(!E||!R){const D=T.tile;(!C||D.isCoverage||D.neededForCoverage&&!R)&&(C=T,(D.neededForCoverage||D.isCoverage)&&(E=!0),D.isCoverage&&(R=!0))}if(C.selectedForRendering=!0,E){d.symbols.push(C),c.show=!0;for(const T of c.parts)T.show=!0}else c.show=!1}}for(const P of i)P.symbols.sort(et);return!0},get sortedSymbols(){return i.sort(l)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,i=this._visibleTiles;let t=0;function n(s,o){const l=s.symbols;for(const[h,c]of l)it(c,o);e(s,o);for(const h of s.childrenTiles)n(h,o)}return{work(s){const o=performance.now();for(;t<i.length;t++){if(performance.now()-o>s)return!1;const l=i[t];(0,M.pC)(l.parentTile)||n(l,performance.now())}return!0}}}}function it(p,e){for(const i of p){const t=i.unique;for(const n of t.parts)n.startOpacity+=(e-n.startTime)/Ie.nN*(n.targetOpacity>.5?1:-1),n.startOpacity=Math.min(Math.max(n.startOpacity,0),1),n.startTime=e,n.targetOpacity=t.show&&n.show?1:0}}class ot{constructor(e,i,t){this.tileCoordRange=e,this._visibleTiles=i,this._createUnique=t,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return(0,M.Wi)(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,i){this._uniqueSymbolLayerArray=null;let t=this._tiles.get(e.id);t||(t={symbols:new Map},this._tiles.set(e.id,t));const n=new Map;if(i)for(const l of i)t.symbols.has(l)&&(n.set(l,t.symbols.get(l)),t.symbols.delete(l));else for(const[l,h]of e.layerData)t.symbols.has(l)&&(n.set(l,t.symbols.get(l)),t.symbols.delete(l));this._removeSymbols(n);const s=e.symbols,o=new Map;for(const[l,h]of s){let c=h.length;if(c>=32){let x=this.tileCoordRange;do{x/=2,c/=4}while(c>8&&x>64);const P=new Se.HX(this.tileCoordRange,this.tileCoordRange,x);o.set(l,{flat:h,index:P}),t.symbols.set(l,{flat:h,index:P});for(const S of h)P.getCell(S.xTile,S.yTile).push(S)}else o.set(l,{flat:h}),t.symbols.set(l,{flat:h})}this._addSymbols(e.key,s)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[i,t]of this._tiles){const n=new Map;for(const s of e)t.symbols.has(s)&&(n.set(s,t.symbols.get(s)),t.symbols.delete(s));this._removeSymbols(n),0===t.symbols.size&&this._tiles.delete(i)}}removeTile(e){this._uniqueSymbolLayerArray=null;const i=this._tiles.get(e.id);if(!i)return;const t=new Map;for(const[n,s]of e.symbols)i.symbols.has(n)&&(t.set(n,i.symbols.get(n)),i.symbols.delete(n));this._removeSymbols(t),0===i.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[i,{flat:t}]of e)for(const n of t){const s=n.unique,o=s.tileSymbols,l=o.length-1;for(let h=0;h<l;h++)if(o[h]===n){o[h]=o[l];break}if(o.length=l,0===l){const h=this._uniqueSymbolsReferences.get(i);h.delete(s),0===h.size&&this._uniqueSymbolsReferences.delete(i)}n.unique=null}}_addSymbols(e,i){if(0===i.size)return;const t=this._visibleTiles;for(const n of t)n.parentTile||n.key.world!==e.world||n.key.level===e.level&&!n.key.equals(e)||this._matchSymbols(n,e,i);for(const[n,s]of i)for(const o of s)if((0,M.Wi)(o.unique)){const l=this._createUnique();o.unique=l,l.tileSymbols.push(o);let h=this._uniqueSymbolsReferences.get(n);h||(h=new Set,this._uniqueSymbolsReferences.set(n,h)),h.add(l)}}_matchSymbols(e,i,t){if(e.key.level>i.level){const s=e.key.level-i.level;if(e.key.row>>s!==i.row||e.key.col>>s!==i.col)return}if(i.level>e.key.level){const s=i.level-e.key.level;if(i.row>>s!==e.key.row||i.col>>s!==e.key.col)return}if(i.equals(e.key)){for(const s of e.childrenTiles)this._matchSymbols(s,i,t);return}const n=new Map;for(const[s,o]of t){const l=[];for(const P of o){const S=(0,Se.co)(this.tileCoordRange,P.xTile,i.level,i.col,e.key.level,e.key.col),d=(0,Se.co)(this.tileCoordRange,P.yTile,i.level,i.row,e.key.level,e.key.row);S>=0&&S<this.tileCoordRange&&d>=0&&d<this.tileCoordRange&&l.push({symbol:P,xTransformed:S,yTransformed:d})}const h=[],c=e.key.level<i.level?1:1<<e.key.level-i.level,x=this._tiles.get(e.id).symbols.get(s);if(x){const P=x.flat;for(const S of l){let d,C=!1;const R=S.xTransformed,E=S.yTransformed;d=(0,M.pC)(x.index)?x.index.getCell(R,E):P;const T=S.symbol,D=T.hash;for(const W of d)if(D===W.hash&&Math.abs(R-W.xTile)<=c&&Math.abs(E-W.yTile)<=c){const N=W.unique;T.unique=N,N.tileSymbols.push(T),C=!0;break}C||h.push(T)}}h.length>0&&n.set(s,h)}for(const s of e.childrenTiles)this._matchSymbols(s,i,n)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,i=new Array(e.size);let t,n=0;for(const[s,o]of e){const l=new Array(o.size);t=0;for(const h of o)l[t++]=h;i[n]={styleLayerUID:s,uniqueSymbols:l},n++}return i}}var lt=g(2584),ht=g(9598);class ct extends ht.Z{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const i=xe.Z.pool.acquire(e),t=0===i.level?null:xe.Z.getId(i.level-1,i.row>>1,i.col>>1,i.world);return xe.Z.pool.release(i),t}getTileCoverage(e,i,t){const n=super.getTileCoverage(e,i,t);if(!n)return n;const s=1<<n.lodInfo.level;return n.spans=n.spans.filter(o=>o.row>=0&&o.row<s),n}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const i=this._fullCacheLodInfos;if(e>i[0].scale)return i[0].level;let t,n;for(let s=0;s<i.length-1;s++)if(n=i[s+1],e>n.scale)return t=i[s],t.level+(t.scale-e)/(t.scale-n.scale);return i[i.length-1].level}}_initializeFullCacheLODs(e){let i;i=0===e[0].level?e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale})):lt.Z.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map(s=>({level:s.level,resolution:s.resolution,scale:s.scale}));for(let t=0;t<i.length;t++)this._levelByScale[i[t].scale]=i[t].level;this._fullCacheLodInfos=i}}class Ce extends class Xe{constructor(e,i,t){this._layer=e,this._styleRepository=i,this.devicePixelRatio=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){var e;null==(e=this._connection)||e.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic=null,this._glyphMosaic=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}start(e){var i=this;return(0,j.Z)(function*(){i._spriteSourcePromise=i._layer.loadSpriteSource(i.devicePixelRatio,e),i._spriteSourcePromise.then(s=>{i._spriteMosaic=new _e(1024,1024,250),i._spriteMosaic.setSpriteSource(s)});const t=i._layer.currentStyleInfo.glyphsUrl,n=new G(t?(0,u.fl)(t,De(Re({},i._layer.customParameters),{token:i._layer.apiKey})):null);i._glyphMosaic=new re(1024,1024,n),i._broadcastPromise=(0,v.bA)("WorkerTileHandler",{client:i,schedule:e.schedule,signal:e.signal}).then(s=>{if(i._connection=s,i._layer&&!i._connection.closed){const o=s.broadcast("setStyle",i._layer.currentStyleInfo.style,e);Promise.all(o).catch(l=>(0,se.H9)(l))}})})()}updateStyle(e){var i=this;return(0,j.Z)(function*(){return yield i._broadcastPromise,i._broadcastPromise=Promise.all(i._connection.broadcast("updateStyle",e)),i._broadcastPromise})()}setSpriteSource(e){const i=new _e(1024,1024,250);return i.setSpriteSource(e),this._spriteMosaic=i,this._spriteSourcePromise=Promise.resolve(e),i}setStyle(e,i){var t=this;return(0,j.Z)(function*(){yield t._broadcastPromise,t._styleRepository=e,t._spriteSourcePromise=t._layer.loadSpriteSource(t.devicePixelRatio,null),t._spriteSourcePromise.then(s=>{t._spriteMosaic=new _e(1024,1024,250),t._spriteMosaic.setSpriteSource(s)});const n=new G(t._layer.currentStyleInfo.glyphsUrl?(0,u.fl)(t._layer.currentStyleInfo.glyphsUrl,De(Re({},t._layer.customParameters),{token:t._layer.apiKey})):null);return t._glyphMosaic=new re(1024,1024,n),t._broadcastPromise=Promise.all(t._connection.broadcast("setStyle",i)),t._broadcastPromise})()}fetchTileData(e,i){return this._getRefKeys(e,i).then(t=>{const n=this._layer.sourceNameToSource,s=[];for(const o in n)s.push(o);return this._getSourcesData(s,t,i)})}parseTileData(e,i){const t=e&&e.data;if(!t)return Promise.resolve(null);const{sourceName2DataAndRefKey:n,transferList:s}=t;return 0===Object.keys(n).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},De(Re({},i),{transferList:s})))}getSprites(e){var i=this;return(0,j.Z)(function*(){return yield i._spriteSourcePromise,i._spriteMosaic.getSpriteItems(e)})()}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}_getTilePayload(e,i,t){var n=this;return(0,j.Z)(function*(){const s=xe.Z.pool.acquire(e.id),o=n._layer.sourceNameToSource[i],{level:l,row:h,col:c}=s;xe.Z.pool.release(s);try{return{protobuff:yield o.requestTile(l,h,c,t),sourceName:i}}catch(x){if((0,se.D_)(x))throw x;return{protobuff:null,sourceName:i}}})()}_getRefKeys(e,i){const t=this._layer.sourceNameToSource,n=new Array;for(const s in t){const o=t[s].getRefKey(e,i);n.push(o)}return(0,se.as)(n)}_getSourcesData(e,i,t){const n=[];for(let s=0;s<i.length;s++)if(null==i[s].value||null==e[s])n.push(null);else{const o=this._getTilePayload(i[s].value,e[s],t);n.push(o)}return(0,se.as)(n).then(s=>{const o={},l=[];for(let h=0;h<s.length;h++){const c=s[h].value;c&&c.protobuff&&c.protobuff.byteLength>0&&(o[c.sourceName]={refKey:i[h].value.id,protobuff:c.protobuff},l.push(c.protobuff))}return{sourceName2DataAndRefKey:o,transferList:l}})}}{constructor(e,i,t,n,s){super(e,i,t),this._memCache=n,this._loader=s,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new ct(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}getVectorTile(e,i,t,n){var s=this;return(0,j.Z)(function*(){const o=new xe.Z(e,i,t,0);let l=s._memCache.get(o.id);if((0,M.pC)(l))return l.retain(),l;const h=yield s._getVectorTileData(o);if((0,se.k_)(n),!s._layer)return null;if(l=s._memCache.get(o.id),(0,M.pC)(l))return l.retain(),l;const c=s._layer.tileInfo.getTileBounds((0,y.Ue)(),o),x=s._tileInfoView.getTileResolution(e);return l=new Ye.i(o,x,c[0],c[3],512,512,s._styleRepository,s._memCache),(0,M.pC)(h)?(l.setData(h),l.retain(),s._memCache.put(o.id,l,l.memoryUsage*l.referenced,a.an)):l.setData(null),l.neededForCoverage=!0,l.transforms.tileUnitsToPixels=(0,_.f)(1/8,0,0,0,1/8,0,0,0,1),function at(p,e){const i=[],t=new ot(4096,i,()=>{const s=new $e.J;return s.show=!1,s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s}),n=new tt(i,t,(s,o,l)=>new Qe(s,o,l,p.styleRepository,p.key.level,0),(s,o)=>{(0,Se.C$)(s,o,!1)},()=>0,s=>{const o=e.getStyleLayerByUID(s).getLayoutProperty("visibility");return!o||o.getValue()!==K.EE.NONE});i.push(p),t.add(p),n.setScreenSize(512,512),n.continue(1/0)}(l,s._styleRepository),l})()}_getVectorTileData(e){const i=e.id;if(this._ongoingTileRequests.has(i))return this._ongoingTileRequests.get(i);const t=new AbortController,s=this._getParsedVectorTileData(e,{signal:t.signal}).then(o=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),o)).catch(()=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),null));return this._ongoingTileRequests.set(i,s),this._ongoingRequestToController.set(i,t),s}_getParsedVectorTileData(e,i){return this.fetchTileData(e,i).then(t=>this.parseTileData({key:e,data:t},i))}request(e,i){return this._loader.request(e,"binary",i)}}var Ee=g(21286),ut=g(67709),ce=g(39351),fe=g(39406),Te=g(5254);class Me{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,i){}draw(e,i,t){}drawMany(e,i,t){for(const n of i)n.visible&&this.draw(e,n,t)}}var dt=g(83994),_t=g(49353);const Ue=1/65536;var Le=g(9545),Ae=g(43289);const xt={vtlBackground:class ft extends Me{constructor(){super(...arguments),this._color=(0,ut.f)(1,0,0,1),this._patternMatrix=(0,_.c)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,i){const{context:t,painter:n,styleLayerUID:s,requestRender:o,allowDelayedRender:l}=e;this._loadWGLResources(e);const h=e.displayLevel,c=e.styleLayer,x=c.backgroundMaterial,P=n.vectorTilesMaterialManager,S=c.getPaintValue("background-color",h),d=c.getPaintValue("background-opacity",h),C=c.getPaintValue("background-pattern",h),R=void 0!==C,E=S[3]*d,T=1|window.devicePixelRatio,D=e.spriteMosaic;let W,N;const U=T>ce.a?2:1,O=e.drawPhase===fe.jx.HITTEST,z=this._programOptions;z.id=O,z.pattern=R;const L=P.getMaterialProgram(t,x,z);if(l&&(0,M.pC)(o)&&!L.compiled)o();else{if(t.bindVAO(this._vao),t.useProgram(L),R){const A=D.getMosaicItemPosition(C,!0);if((0,M.pC)(A)){const{tl:B,br:V,page:Y}=A;W=V[0]-B[0],N=V[1]-B[1];const Z=D.getPageSize(Y);(0,M.pC)(Z)&&(D.bind(t,f.cw.LINEAR,Y,ce.V4),L.setUniform4f("u_tlbr",B[0],B[1],V[0],V[1]),L.setUniform2fv("u_mosaicSize",Z),L.setUniform1i("u_texture",ce.V4))}L.setUniform1f("u_opacity",d)}else this._color[0]=E*S[0],this._color[1]=E*S[1],this._color[2]=E*S[2],this._color[3]=E,L.setUniform4fv("u_color",this._color);if(L.setUniform1f("u_depth",c.z||0),O){const A=(0,Te.Au)(s+1);L.setUniform4fv("u_id",A)}for(const A of i){if(L.setUniform1f("u_coord_range",A.rangeX),L.setUniformMatrix3fv("u_dvsMat3",A.transforms.dvs),R){const B=Math.max(2**(Math.round(h)-A.key.level),1),V=U*A.width*B,Y=V/(0,Ee.fp)(W),Z=V/(0,Ee.fp)(N);this._patternMatrix[0]=Y,this._patternMatrix[4]=Z,L.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}t.setStencilFunction(f.wb.EQUAL,0,255),t.drawArrays(f.MX.TRIANGLE_STRIP,0,4)}}}_loadWGLResources(e){if(this._vao)return;const{context:i,styleLayer:t}=e,n=t.backgroundMaterial,s=new Int8Array([0,0,1,0,0,1,1,1]),o=dt.f.createVertex(i,f.l1.STATIC_DRAW,s),l=new _t.U(i,n.getAttributeLocations(),n.getLayoutInfo(),{geometry:o});this._vao=l}},vtlFill:class pt extends Me{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,i){const{displayLevel:t,drawPhase:n,renderPass:s,spriteMosaic:o,styleLayerUID:l}=e;let h=!1;for(const U of i)if(U.layerData.has(l)){const O=U.layerData.get(l);if(O.fillIndexCount>0||O.outlineIndexCount>0){h=!0;break}}if(!h)return;const c=e.styleLayer,x=c.getPaintProperty("fill-pattern"),P=void 0!==x,S=P&&x.isDataDriven;let d;if(P&&!S){const U=x.getValue(t);d=o.getMosaicItemPosition(U,!0)}const C=!P&&c.getPaintValue("fill-antialias",t);let T,R=!0,E=1;if(!P){const U=c.getPaintProperty("fill-color"),O=c.getPaintProperty("fill-opacity");if(!(null!=U&&U.isDataDriven||null!=O&&O.isDataDriven)){const z=c.getPaintValue("fill-color",t);E=c.getPaintValue("fill-opacity",t)*z[3],E>=1&&(R=!1)}}if(R&&"opaque"===s)return;n===fe.jx.HITTEST&&(T=(0,Te.Au)(l+1));const D=c.getPaintValue("fill-translate",t),W=c.getPaintValue("fill-translate-anchor",t);(R||"translucent"!==s)&&this._drawFill(e,l,c,i,D,W,P,d,S,T),C&&"opaque"!==s&&!(!c.hasDataDrivenOutlineColor&&c.outlineUsesFillColor&&E<1)&&this._drawOutline(e,l,c,i,D,W,T)}_drawFill(e,i,t,n,s,o,l,h,c,x){if(l&&!c&&(0,M.Wi)(h))return;const{context:P,displayLevel:S,state:d,drawPhase:C,painter:R,pixelRatio:E,spriteMosaic:T,requestRender:D,allowDelayedRender:W}=e,N=t.fillMaterial,U=R.vectorTilesMaterialManager,O=E>ce.a?2:1,z=C===fe.jx.HITTEST,L=this._fillProgramOptions;L.id=z,L.pattern=l;const A=U.getMaterialProgram(P,N,L);if(W&&(0,M.pC)(D)&&!A.compiled)return void D();if(P.useProgram(A),(0,M.pC)(h)){const{page:V}=h,Y=T.getPageSize(V);(0,M.pC)(Y)&&(T.bind(P,f.cw.LINEAR,V,ce.V4),A.setUniform2fv("u_mosaicSize",Y),A.setUniform1i("u_texture",ce.V4))}A.setUniformMatrix3fv("u_displayMat3",o===K.fD.VIEWPORT?d.displayMat3:d.displayViewMat3),A.setUniform2fv("u_fillTranslation",s),A.setUniform1f("u_depth",t.z+Ue),z&&A.setUniform4fv("u_id",x);let B=-1;for(const V of n){if(!V.layerData.has(i))continue;V.key.level!==B&&(B=V.key.level,N.setDataUniforms(A,S,t,B,T));const Y=V.layerData.get(i);if(!Y.fillIndexCount)continue;Y.prepareForRendering(P);const Z=Y.fillVertexArrayObject;if(!(0,M.Wi)(Z)){if(P.bindVAO(Z),A.setUniformMatrix3fv("u_dvsMat3",V.transforms.dvs),P.setStencilFunction(f.wb.EQUAL,V.stencilRef,255),l){const le=Math.max(2**(Math.round(S)-V.key.level),1);A.setUniform1f("u_patternFactor",V.rangeX/(O*V.width*le))}if(c){const le=Y.patternMap;if(!le)continue;for(const[oe,ye]of le){const ve=T.getPageSize(oe);(0,M.pC)(ve)&&(T.bind(P,f.cw.LINEAR,oe,ce.V4),A.setUniform2fv("u_mosaicSize",ve),A.setUniform1i("u_texture",ce.V4),P.drawElements(f.MX.TRIANGLES,ye[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*ye[0]))}}else P.drawElements(f.MX.TRIANGLES,Y.fillIndexCount,f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*Y.fillIndexStart);V.triangleCount+=Y.fillIndexCount/3}}}_drawOutline(e,i,t,n,s,o,l){const{context:h,displayLevel:c,state:x,drawPhase:P,painter:S,pixelRatio:d,spriteMosaic:C,requestRender:R,allowDelayedRender:E}=e,T=t.outlineMaterial,D=S.vectorTilesMaterialManager,W=.75/d,N=P===fe.jx.HITTEST,U=this._outlineProgramOptions;U.id=N;const O=D.getMaterialProgram(h,T,U);if(E&&(0,M.pC)(R)&&!O.compiled)return void R();h.useProgram(O),O.setUniformMatrix3fv("u_displayMat3",o===K.fD.VIEWPORT?x.displayMat3:x.displayViewMat3),O.setUniform2fv("u_fillTranslation",s),O.setUniform1f("u_depth",t.z+Ue),O.setUniform1f("u_outline_width",W),N&&O.setUniform4fv("u_id",l);let z=-1;for(const L of n){if(!L.layerData.has(i))continue;L.key.level!==z&&(z=L.key.level,T.setDataUniforms(O,c,t,z,C));const A=L.layerData.get(i);if(A.prepareForRendering(h),!A.outlineIndexCount)continue;const B=A.outlineVertexArrayObject;(0,M.Wi)(B)||(h.bindVAO(B),O.setUniformMatrix3fv("u_dvsMat3",L.transforms.dvs),h.setStencilFunction(f.wb.EQUAL,L.stencilRef,255),h.drawElements(f.MX.TRIANGLES,A.outlineIndexCount,f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*A.outlineIndexStart),L.triangleCount+=A.outlineIndexCount/3)}}},vtlLine:class gt extends Me{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,state:s,drawPhase:o,painter:l,pixelRatio:h,spriteMosaic:c,styleLayerUID:x,requestRender:P,allowDelayedRender:S}=e;if(!i.some(Z=>{var le,oe;return null!=(oe=null==(le=Z.layerData.get(x))?void 0:le.lineIndexCount)&&oe}))return;const d=e.styleLayer,C=d.lineMaterial,R=l.vectorTilesMaterialManager,E=d.getPaintValue("line-translate",n),T=d.getPaintValue("line-translate-anchor",n),D=d.getPaintProperty("line-pattern"),W=void 0!==D,N=W&&D.isDataDriven;let U,O;if(W&&!N){const Z=D.getValue(n);U=c.getMosaicItemPosition(Z)}let z=!1;if(!W){const Z=d.getPaintProperty("line-dasharray");if(O=void 0!==Z,z=O&&Z.isDataDriven,O&&!z){const le=Z.getValue(n),oe=d.getDashKey(le,d.getLayoutValue("line-cap",n));U=c.getMosaicItemPosition(oe)}}const L=1/h,A=o===fe.jx.HITTEST,B=this._programOptions;B.id=A,B.pattern=W,B.sdf=O;const V=R.getMaterialProgram(t,C,B);if(S&&(0,M.pC)(P)&&!V.compiled)return void P();if(t.useProgram(V),V.setUniformMatrix3fv("u_displayViewMat3",s.displayViewMat3),V.setUniformMatrix3fv("u_displayMat3",T===K.fD.VIEWPORT?s.displayMat3:s.displayViewMat3),V.setUniform2fv("u_lineTranslation",E),V.setUniform1f("u_depth",d.z),V.setUniform1f("u_antialiasing",L),A){const Z=(0,Te.Au)(x+1);V.setUniform4fv("u_id",Z)}if(U&&(0,M.pC)(U)){const{page:Z}=U,le=c.getPageSize(Z);(0,M.pC)(le)&&(c.bind(t,f.cw.LINEAR,Z,ce.V4),V.setUniform2fv("u_mosaicSize",le),V.setUniform1i("u_texture",ce.V4))}let Y=-1;for(const Z of i){if(!Z.layerData.has(x))continue;Z.key.level!==Y&&(Y=Z.key.level,C.setDataUniforms(V,n,d,Y,c)),V.setUniform1f("u_zoomFactor",2**(n-Y)/h);const oe=Z.layerData.get(x);if(!oe.lineIndexCount)continue;oe.prepareForRendering(t);const ye=oe.lineVertexArrayObject;if(!(0,M.Wi)(ye)){if(t.bindVAO(ye),V.setUniformMatrix3fv("u_dvsMat3",Z.transforms.dvs),t.setStencilFunction(f.wb.EQUAL,Z.stencilRef,255),N||z){const ve=oe.patternMap;if(!ve)continue;for(const[be,ae]of ve){const Pe=c.getPageSize(be);(0,M.pC)(Pe)&&(c.bind(t,f.cw.LINEAR,be,ce.V4),V.setUniform2fv("u_mosaicSize",Pe),V.setUniform1i("u_texture",ce.V4),t.drawElements(f.MX.TRIANGLES,ae[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*ae[0]))}}else t.drawElements(f.MX.TRIANGLES,oe.lineIndexCount,f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*oe.lineIndexStart);Z.triangleCount+=oe.lineIndexCount/3}}}},vtlCircle:class mt extends Me{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,requiredLevel:s,state:o,drawPhase:l,painter:h,spriteMosaic:c,styleLayerUID:x,requestRender:P,allowDelayedRender:S}=e;if(!i.some(z=>{var L,A;return null!=(A=null==(L=z.layerData.get(x))?void 0:L.circleIndexCount)&&A}))return;const d=e.styleLayer,C=d.circleMaterial,R=h.vectorTilesMaterialManager,T=d.getPaintValue("circle-translate",n),D=d.getPaintValue("circle-translate-anchor",n),W=l===fe.jx.HITTEST,N=this._programOptions;N.id=W;const U=R.getMaterialProgram(t,C,N);if(S&&(0,M.pC)(P)&&!U.compiled)return void P();t.useProgram(U),U.setUniformMatrix3fv("u_displayMat3",D===K.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),U.setUniform2fv("u_circleTranslation",T),U.setUniform1f("u_depth",d.z),U.setUniform1f("u_antialiasingWidth",1.2);let O=-1;if(W){const z=(0,Te.Au)(x+1);U.setUniform4fv("u_id",z)}for(const z of i){if(!z.layerData.has(x))continue;z.key.level!==O&&(O=z.key.level,C.setDataUniforms(U,n,d,O,c));const L=z.layerData.get(x);if(!L.circleIndexCount)continue;L.prepareForRendering(t);const A=L.circleVertexArrayObject;(0,M.Wi)(A)||(t.bindVAO(A),U.setUniformMatrix3fv("u_dvsMat3",z.transforms.dvs),s!==z.key.level?t.setStencilFunction(f.wb.EQUAL,z.stencilRef,255):t.setStencilFunction(f.wb.GREATER,255,255),t.drawElements(f.MX.TRIANGLES,L.circleIndexCount,f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*L.circleIndexStart),z.triangleCount+=L.circleIndexCount/3)}}},vtlSymbol:class vt extends Me{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,Le.c)()}dispose(){}drawMany(e,i){const{drawPhase:t,styleLayerUID:n}=e,s=e.styleLayer;let o;t===fe.jx.HITTEST&&(o=(0,Te.Au)(n+1)),this._drawIcons(e,s,i,o),this._drawText(e,s,i,o)}_drawIcons(e,i,t,n){const{context:s,displayLevel:o,drawPhase:l,painter:h,spriteMosaic:c,state:x,styleLayerUID:P,requestRender:S,allowDelayedRender:d}=e,C=i.iconMaterial,R=h.vectorTilesMaterialManager;let E,T=!1;for(const Y of t)if(Y.layerData.has(P)&&(E=Y.layerData.get(P),E.iconPerPageElementsMap.size>0)){T=!0;break}if(!T)return;const D=i.getPaintValue("icon-translate",o),W=i.getPaintValue("icon-translate-anchor",o);let N=i.getLayoutValue("icon-rotation-alignment",o);N===K.aF.AUTO&&(N=i.getLayoutValue("symbol-placement",o)===K.R.POINT?K.aF.VIEWPORT:K.aF.MAP);const U=N===K.aF.MAP,O=i.getLayoutValue("icon-keep-upright",o)&&U,z=E.isIconSDF,L=l===fe.jx.HITTEST,A=this._iconProgramOptions;A.id=L,A.sdf=z;const B=R.getMaterialProgram(s,C,A);if(d&&(0,M.pC)(S)&&!B.compiled)return void S();s.useProgram(B),B.setUniformMatrix3fv("u_displayViewMat3",N===K.aF.MAP?x.displayViewMat3:x.displayMat3),B.setUniformMatrix3fv("u_displayMat3",W===K.fD.VIEWPORT?x.displayMat3:x.displayViewMat3),B.setUniform2fv("u_iconTranslation",D),B.setUniform1f("u_depth",i.z),B.setUniform1f("u_mapRotation",(0,Ae.s5)(x.rotation)),B.setUniform1f("u_keepUpright",O?1:0),B.setUniform1f("u_level",10*o),B.setUniform1i("u_texture",ce.V4),B.setUniform1f("u_fadeDuration",Ie.nN/1e3),L&&B.setUniform4fv("u_id",n);let V=-1;for(const Y of t){if(!Y.layerData.has(P)||(Y.key.level!==V&&(V=Y.key.level,C.setDataUniforms(B,o,i,V,c)),E=Y.layerData.get(P),0===E.iconPerPageElementsMap.size))continue;E.prepareForRendering(s),E.updateOpacityInfo();const Z=E.iconVertexArrayObject;if(!(0,M.Wi)(Z)){s.bindVAO(Z),B.setUniformMatrix3fv("u_dvsMat3",Y.transforms.dvs),B.setUniform1f("u_time",(performance.now()-E.lastOpacityUpdate)/1e3);for(const[le,oe]of E.iconPerPageElementsMap)this._renderIconRange(e,B,oe,le,Y)}}}_renderIconRange(e,i,t,n,s){const{context:o,spriteMosaic:l}=e;this._spritesTextureSize[0]=l.getWidth(n)/4,this._spritesTextureSize[1]=l.getHeight(n)/4,i.setUniform2fv("u_mosaicSize",this._spritesTextureSize),l.bind(o,f.cw.LINEAR,n,ce.V4),o.setStencilTestEnabled(!0),o.setStencilFunction(f.wb.GREATER,255,255),o.setStencilWriteMask(0),o.drawElements(f.MX.TRIANGLES,t[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3}_drawText(e,i,t,n){const{context:s,displayLevel:o,drawPhase:l,glyphMosaic:h,painter:c,pixelRatio:x,spriteMosaic:P,state:S,styleLayerUID:d,requestRender:C,allowDelayedRender:R}=e,E=i.textMaterial,T=c.vectorTilesMaterialManager;let D,W=!1;for(const me of t)if(me.layerData.has(d)&&(D=me.layerData.get(d),D.glyphPerPageElementsMap.size>0)){W=!0;break}if(!W)return;const N=i.getPaintProperty("text-opacity");if(N&&!N.isDataDriven&&0===N.getValue(o))return;const U=i.getPaintProperty("text-color"),O=!U||U.isDataDriven||U.getValue(o)[3]>0,z=i.getPaintProperty("text-halo-width"),L=i.getPaintProperty("text-halo-color"),A=(!z||z.isDataDriven||z.getValue(o)>0)&&(!L||L.isDataDriven||L.getValue(o)[3]>0);if(!O&&!A)return;let V=i.getLayoutValue("text-rotation-alignment",o);V===K.aF.AUTO&&(V=i.getLayoutValue("symbol-placement",o)===K.R.POINT?K.aF.VIEWPORT:K.aF.MAP);const Y=V===K.aF.MAP,Z=i.getLayoutValue("text-keep-upright",o)&&Y,le=l===fe.jx.HITTEST,oe=.8*3/x;this._glyphTextureSize||(this._glyphTextureSize=(0,Le.f)(h.width/4,h.height/4));const ye=i.getPaintValue("text-translate",o),ve=i.getPaintValue("text-translate-anchor",o),be=this._sdfProgramOptions;be.id=le;const ae=T.getMaterialProgram(s,E,be);if(R&&(0,M.pC)(C)&&!ae.compiled)return void C();s.useProgram(ae),ae.setUniformMatrix3fv("u_displayViewMat3",V===K.aF.MAP?S.displayViewMat3:S.displayMat3),ae.setUniformMatrix3fv("u_displayMat3",ve===K.fD.VIEWPORT?S.displayMat3:S.displayViewMat3),ae.setUniform2fv("u_textTranslation",ye),ae.setUniform1f("u_depth",i.z+152587890625e-16),ae.setUniform2fv("u_mosaicSize",this._glyphTextureSize),ae.setUniform1f("u_mapRotation",(0,Ae.s5)(S.rotation)),ae.setUniform1f("u_keepUpright",Z?1:0),ae.setUniform1f("u_level",10*o),ae.setUniform1i("u_texture",ce.CU),ae.setUniform1f("u_antialiasingWidth",oe),ae.setUniform1f("u_fadeDuration",Ie.nN/1e3),le&&ae.setUniform4fv("u_id",n);let Pe=-1;for(const me of t){if(!me.layerData.has(d)||(me.key.level!==Pe&&(Pe=me.key.level,E.setDataUniforms(ae,o,i,Pe,P)),D=me.layerData.get(d),0===D.glyphPerPageElementsMap.size))continue;D.prepareForRendering(s),D.updateOpacityInfo();const je=D.textVertexArrayObject;if((0,M.Wi)(je))continue;s.bindVAO(je),ae.setUniformMatrix3fv("u_dvsMat3",me.transforms.dvs),s.setStencilTestEnabled(!0),s.setStencilFunction(f.wb.GREATER,255,255),s.setStencilWriteMask(0);const Ft=(performance.now()-D.lastOpacityUpdate)/1e3;ae.setUniform1f("u_time",Ft),D.glyphPerPageElementsMap.forEach((Nt,kt)=>{this._renderGlyphRange(s,Nt,kt,h,ae,A,O,me)})}}_renderGlyphRange(e,i,t,n,s,o,l,h){n.bind(e,f.cw.LINEAR,t,ce.CU),o&&(s.setUniform1f("u_halo",1),e.drawElements(f.MX.TRIANGLES,i[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),h.triangleCount+=i[1]/3),l&&(s.setUniform1f("u_halo",0),e.drawElements(f.MX.TRIANGLES,i[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),h.triangleCount+=i[1]/3)}}};var ue=g(919);const wt={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}},Tt=new class Pt{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,i=new Map){if(i.has(e))return i.get(e);const t=this._read(e);if(!t)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let s=n.exec(t);const o=[];for(;null!=s;)o.push({path:s[1],start:s.index,length:s[0].length}),s=n.exec(t);let l=0,h="";return o.forEach(c=>{h+=t.slice(l,c.start),h+=i.has(c.path)?"":this._resolve(c.path,i),l=c.start+c.length}),h+=t.slice(l),i.set(e,h),h}_read(e){return this._readFile(e)}}(function St(p){let e=wt;return p.split("/").forEach(i=>{e&&(e=e[i])}),e});function de(p){return Tt.resolveIncludes(p)}function Mt(p){const{options:e,value:i}=p;return"number"==typeof e[i]}function ge(p){let e="";for(const i in p){const t=p[i];if("boolean"==typeof t)t&&(e+=`#define ${i}\n`);else if("number"==typeof t)e+=`#define ${i} ${t.toFixed()}\n`;else if("object"==typeof t)if(Mt(t)){const{value:n,options:s,namespace:o}=t,l=o?`${o}_`:"";for(const h in s)e+=`#define ${l}${h} ${s[h].toFixed()}\n`;e+=`#define ${i} ${l}${n}\n`}else{const n=t.options;let s=0;for(const o in n)e+=`#define ${n[o]} ${(s++).toFixed()}\n`;e+=`#define ${i} ${n[t.value]}\n`}}return e}const Oe=p=>ge({ID:p.id,PATTERN:p.pattern}),bt={shaders:p=>({vertexShader:Oe(p)+de("background/background.vert"),fragmentShader:Oe(p)+de("background/background.frag")})},ze=p=>ge({ID:p.id}),It={shaders:p=>({vertexShader:ze(p)+de("circle/circle.vert"),fragmentShader:ze(p)+de("circle/circle.frag")})},Ve=p=>ge({ID:p.id,PATTERN:p.pattern}),Rt={shaders:p=>({vertexShader:Ve(p)+de("fill/fill.vert"),fragmentShader:Ve(p)+de("fill/fill.frag")})},Fe=p=>ge({ID:p.id}),Dt={shaders:p=>({vertexShader:Fe(p)+de("outline/outline.vert"),fragmentShader:Fe(p)+de("outline/outline.frag")})},Ne=p=>ge({ID:p.id,SDF:p.sdf}),Ct={shaders:p=>({vertexShader:Ne(p)+de("icon/icon.vert"),fragmentShader:Ne(p)+de("icon/icon.frag")})},ke=p=>ge({ID:p.id,PATTERN:p.pattern,SDF:p.sdf}),Et={shaders:p=>({vertexShader:ke(p)+de("line/line.vert"),fragmentShader:ke(p)+de("line/line.frag")})},We=p=>ge({ID:p.id}),Ut={shaders:p=>({vertexShader:We(p)+de("text/text.vert"),fragmentShader:We(p)+de("text/text.frag")})};class Lt{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,i,t){const n=i.key<<3|this._getMaterialOptionsValue(i.type,t);if(this._programByKey.has(n))return this._programByKey.get(n);const s=this._getProgramTemplate(i.type),{shaders:o}=s,{vertexShader:l,fragmentShader:h}=o(t),c=i.getShaderHeader(),x=i.getShaderMain(),P=l.replace("#pragma header",c).replace("#pragma main",x),S=e.programCache.acquire(P,h,i.getAttributeLocations());return this._programByKey.set(n,S),S}_getMaterialOptionsValue(e,i){switch(e){case ue._K.BACKGROUND:case ue._K.FILL:return(i.pattern?1:0)<<1|(i.id?1:0);case ue._K.OUTLINE:return i.id?1:0;case ue._K.LINE:return(i.sdf?1:0)<<2|(i.pattern?1:0)<<1|(i.id?1:0);case ue._K.ICON:return(i.sdf?1:0)<<1|(i.id?1:0);case ue._K.CIRCLE:case ue._K.TEXT:return i.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case ue._K.BACKGROUND:return bt;case ue._K.CIRCLE:return It;case ue._K.FILL:return Rt;case ue._K.ICON:return Ct;case ue._K.LINE:return Et;case ue._K.OUTLINE:return Dt;case ue._K.TEXT:return Ut;default:return null}}}class He{constructor(e,i){this.spriteMosaic=e,this.glyphMosaic=i,this._brushCache=new Map,this._vtlMaterialManager=new Lt}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=(0,M.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,i,t){const{context:n}=e,s=t.layers;t.backgroundBucketIds.length>0&&(e.renderPass="background",t.backgroundBucketIds.forEach(o=>this._renderStyleLayer(t.getLayerById(o),e,i,!0))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(f.wb.LEQUAL),e.renderPass="opaque";for(let o=s.length-1;o>=0;o--)this._renderStyleLayer(s[o],e,i,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(f.zi.ONE,f.zi.ONE_MINUS_SRC_ALPHA,f.zi.ONE,f.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let o=0;o<s.length;o++)this._renderStyleLayer(s[o],e,i,!1);n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,i,t,n=!1){if(!(n||e&&t.layerData.has(e.uid)))return;const s=e.getLayoutProperty("visibility");if(s&&s.getValue()===K.EE.NONE)return;const{renderPass:o}=i;let l;switch(e.type){case K.fR.BACKGROUND:if("background"!==o)return;l="vtlBackground";break;case K.fR.FILL:if("opaque"!==o&&"translucent"!==i.renderPass)return;l="vtlFill";break;case K.fR.LINE:if("translucent"!==o)return;l="vtlLine";break;case K.fR.CIRCLE:if("translucent"!==o)return;l="vtlCircle";break;case K.fR.SYMBOL:if("translucent"!==o)return;l="vtlSymbol"}const h=i.displayLevel;void 0!==e.minzoom&&e.minzoom>h+1e-6||void 0!==e.maxzoom&&e.maxzoom<=h-1e-6||(i.styleLayerUID=e.uid,i.styleLayer=e,this._drawWithBrush(i,t,l))}_drawWithBrush(e,i,t){this._brushCache.has(t)||this._brushCache.set(t,new(0,xt[t])),this._brushCache.get(t).drawMany(e,[i])}}var Ge=g(78364),At=g(19702),Ot=g(50916),Ke=g(61779),zt=g(45611);let we=class extends((0,Ot.r)((0,At.A)(zt.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d"}initialize(){if((0,M.Wi)(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new k.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:p,spatialReference:e,state:i,viewingMode:t}=this.view,o="local"===t&&!(0,Ke.jO)(e)||Ke.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2),l=this._getTileInfoSupportError(o,this.layer.fullExtent);if((0,M.pC)(l))return this.addResolvingPromise(Promise.reject(l));const h=(0,H.N1)(()=>{var T,D;return null==(D=null==(T=this.view)?void 0:T.basemapTerrain)?void 0:D.tilingSchemeLocked}).then(()=>{var U;const T=p.tilingScheme,D=T.pixelSize;let W;this.schemaHelper=new r(D,(0,M.pC)(p.spatialReference)&&p.spatialReference.isGeographic),W=256===D?this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2):null!=(U=this.view.spatialReference)&&U.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const N=this._getTileInfoCompatibilityError(W,T);if(N)throw N;this.tileInfo=W});this._tileHandlerController=new AbortController;const c=this.view.resourceController;this._memCache=c.memoryController.newCache(this.layer.uid,T=>{T.release()});const x=new Ge.Z(this.layer.currentStyleInfo.style),P=p.mapTileRequester;this._tileHandler=new Ce(this.layer,x,i.contentPixelRatio,this._memCache,P);const S=this._tileHandlerController.signal,d=T=>c.immediate.schedule(T),C=this._tileHandler.start({signal:S,schedule:d}),R=this._tileHandler.spriteMosaic;R.then(T=>{!(0,se.Hc)(S)&&this._tileHandler&&(this.painter=new He(T,this._tileHandler.glyphMosaic))}),C.then(()=>this._tileHandlerController=null),this.updatingHandles.add(()=>{var T;return{style:this.layer.currentStyleInfo.style,pixelRatio:null==(T=this.view.state)?void 0:T.contentPixelRatio}},({style:T,pixelRatio:D})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const W=new Ge.Z(T),N=new Ce(this.layer,W,D,this._memCache,P),U=N.start({signal:this._tileHandlerController.signal,schedule:d}),O=N.spriteMosaic;U.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([U,O]).then(([,z])=>{const L=this._tileHandler,A=this.painter;this.painter=new He(z,N.glyphMosaic),this._tileHandler=N,this.emit("data-changed"),L.destroy(),A&&A.dispose()}))});const E=Promise.all([h,C,R]);this.addResolvingPromise(E)}destroy(){this.painter=(0,M.M2)(this.painter),this._tileHandlerController=(0,M.IM)(this._tileHandlerController),(0,M.SC)(this._tileHandler),this._memCache=(0,M.SC)(this._memCache),this._tileHandler=null}get dataLevelRange(){const p=this.tileInfo.lods,t=this.levelRangeFromScaleRange(p[0].scale,p[p.length-1].scale);return 1===t.minLevel&&256===this.tileInfo.size[0]&&(t.minLevel=0),t}fetchTile(p,e,i,t){var n=this;return(0,j.Z)(function*(){return n._tileHandler.getVectorTile(p,e,i,t)})()}};(0,X._)([(0,J.Cb)()],we.prototype,"layer",void 0),(0,X._)([(0,J.Cb)()],we.prototype,"dataLevelRange",null),(0,X._)([(0,J.Cb)()],we.prototype,"updatingProgressValue",void 0),we=(0,X._)([(0,b.j)("esri.views.3d.layers.VectorTileLayerView3D")],we);const Vt=we},45611:(he,Q,g)=>{g.d(Q,{Z:()=>y});var j=g(17626),X=g(14517),k=g(61885),M=g(80542),se=g(61996),H=g(63290),J=g(62208),ie=g(60330),ee=g(77712),a=(g(90912),g(85931),g(76898));let _=class extends((0,M.p)((0,se.IG)((0,ie.v)(k.Z.EventedMixin(X.Z))))){constructor(u){super(u),this.layer=null,this.parent=null}initialize(){this.when().catch(u=>{if("layerview:create-error"!==u.name){const v=this.layer&&this.layer.id||"no id",w=this.layer&&this.layer.title||"no title";H.Z.getLogger(this.declaredClass).error("#resolve()",`Failed to resolve layer view (layer title: '${w}', id: '${v}')`,u)}})}get fullOpacity(){return(0,J.Pt)(this.get("layer.opacity"),1)*(0,J.Pt)(this.get("parent.fullOpacity"),1)}get suspended(){return!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){var u;return!this.suspended&&!0===(null==(u=this.layer)?void 0:u.legendEnabled)}get updating(){var u;return!!(null!=(u=this.updatingHandles)&&u.updating||this.isUpdating())}get updatingProgress(){return this.updating?0:1}get visible(){var u;return!0===(null==(u=this.layer)?void 0:u.visible)}set visible(u){this._overrideIfSome("visible",u)}canResume(){var u,v,w;return this.visible&&(null==(u=this.layer)?void 0:u.loaded)&&!(null!=(v=this.parent)&&v.suspended)&&(null==(w=this.view)?void 0:w.ready)||!1}getSuspendInfo(){const u=this.parent&&this.parent.suspended?this.parent.suspendInfo:{};return this.view&&this.view.ready||(u.viewNotReady=!0),this.layer&&this.layer.loaded||(u.layerNotLoaded=!0),this.visible||(u.layerInvisible=!0),u}isUpdating(){return!1}};(0,j._)([(0,ee.Cb)()],_.prototype,"fullOpacity",null),(0,j._)([(0,ee.Cb)()],_.prototype,"layer",void 0),(0,j._)([(0,ee.Cb)()],_.prototype,"parent",void 0),(0,j._)([(0,ee.Cb)({readOnly:!0})],_.prototype,"suspended",null),(0,j._)([(0,ee.Cb)({readOnly:!0})],_.prototype,"suspendInfo",null),(0,j._)([(0,ee.Cb)({readOnly:!0})],_.prototype,"legendEnabled",null),(0,j._)([(0,ee.Cb)({type:Boolean,readOnly:!0})],_.prototype,"updating",null),(0,j._)([(0,ee.Cb)({readOnly:!0})],_.prototype,"updatingProgress",null),(0,j._)([(0,ee.Cb)()],_.prototype,"visible",null),(0,j._)([(0,ee.Cb)()],_.prototype,"view",void 0),_=(0,j._)([(0,a.j)("esri.views.layers.LayerView")],_);const y=_}}]);