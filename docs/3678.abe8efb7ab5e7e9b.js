"use strict";var es=Object.defineProperty,ss=Object.defineProperties,is=Object.getOwnPropertyDescriptors,Ze=Object.getOwnPropertySymbols,ns=Object.prototype.hasOwnProperty,rs=Object.prototype.propertyIsEnumerable,Qe=(Pe,re,at)=>re in Pe?es(Pe,re,{enumerable:!0,configurable:!0,writable:!0,value:at}):Pe[re]=at,Ve=(Pe,re)=>{for(var at in re||(re={}))ns.call(re,at)&&Qe(Pe,at,re[at]);if(Ze)for(var at of Ze(re))rs.call(re,at)&&Qe(Pe,at,re[at]);return Pe},Je=(Pe,re)=>ss(Pe,is(re));(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[3678],{986:(Pe,re,at)=>{at.d(re,{E:()=>Ft});const gt=new(at(6879).Z);function Ft(zt){if(null==zt)return["",!1];if(!gt.hasBidiChar(zt))return[zt,!1];let he;return he="rtl"===gt.checkContextual(zt)?"IDNNN":"ICNNN",[gt.bidiTransform(zt,he,"VLYSN"),!0]}},17002:(Pe,re,at)=>{at.d(re,{BN:()=>Nt,mx:()=>he});var Wt=at(15861),gt=at(59318);const zt=new Map;function he(Ct){return tt.apply(this,arguments)}function tt(){return(tt=(0,Wt.Z)(function*(Ct){const Ut=xt(Ct);let $t=zt.get(Ut);if($t)return $t;const st=new FontFace(Ct.family,`url('${gt.Z.fontsUrl}/woff2/${Ut}.woff2') format('woff2')`),ft=document.fonts;return ft.has(st)&&"loading"===st.status?st.loaded:($t=st.load(),zt.set(Ut,$t),ft.add(st),$t)})).apply(this,arguments)}function Nt(Ct){if(!Ct)return"arial-unicode-ms";const Ut=Ct.toLowerCase().split(" ").join("-");switch(Ut){case"serif":return"noto-serif";case"sans-serif":return"arial-unicode-ms";case"monospace":return"ubuntu-mono";case"fantasy":return"cabin-sketch";case"cursive":return"redressed";default:return Ut}}function xt(Ct){const Ut=function At(Ct){if(!Ct.weight)return"";switch(Ct.weight.toLowerCase()){case"bold":case"bolder":return"-bold"}return""}(Ct)+function dt(Ct){if(!Ct.style)return"";switch(Ct.style.toLowerCase()){case"italic":case"oblique":return"-italic"}return""}(Ct);return Nt(Ct.family)+(Ut.length>0?Ut:"-regular")}},72283:(Pe,re,at)=>{at.d(re,{GP:()=>zt,QK:()=>Q,XV:()=>Et,hh:()=>ft,ov:()=>st,qh:()=>Vt,v1:()=>Ht,wp:()=>$t,zY:()=>oe,zv:()=>Jt});var Wt=at(58817),gt=at(91179),Ft=at(97373);function zt(ot){const St=(0,Wt.d9)(ot);return function Ut(ot){ot&&((0,gt.oU)(ot)?Ct(ot.rings):(0,gt.l9)(ot)?Ct(ot.paths):(0,gt.aW)(ot)&&dt(ot.points),he(ot))}(St),St}function he(ot){ot&&((0,gt.wp)(ot)?ot.y=-ot.y:(0,gt.oU)(ot)?Nt(ot.rings):(0,gt.l9)(ot)?Nt(ot.paths):(0,gt.aW)(ot)&&tt(ot.points))}function tt(ot){if(ot){const St=ot.length;for(let Gt=0;Gt<St;Gt++)ot[Gt][1]=-ot[Gt][1]}}function Nt(ot){if(ot)for(const St of ot)tt(St)}function xt(ot){if(ot)for(let St=ot.length-1;St>0;--St)ot[St][0]-=ot[St-1][0],ot[St][1]-=ot[St-1][1]}function At(ot){if(ot)for(const St of ot)xt(St)}function dt(ot){if(ot){const St=ot.length;for(let Gt=1;Gt<St;++Gt)ot[Gt][0]+=ot[Gt-1][0],ot[Gt][1]+=ot[Gt-1][1]}}function Ct(ot){if(ot)for(const St of ot)dt(St)}function $t(ot){ot&&(he(ot),(0,gt.oU)(ot)?At(ot.rings):(0,gt.l9)(ot)?At(ot.paths):(0,gt.aW)(ot)&&xt(ot.points))}function st(ot){if(ot)for(const St of ot)ft(St)}function ft(ot){ot&&ot.reverse()}function Et(ot,St,Gt){return[ot[0]+(St[0]-ot[0])*Gt,ot[1]+(St[1]-ot[1])*Gt]}function Q(ot){return!(!ot||0===ot.length)&&ot[0][0]===ot[ot.length-1][0]&&ot[0][1]===ot[ot.length-1][1]}function Jt(ot){return ot[4]}function Vt(ot,St){ot[4]=St}class Ht{constructor(St,Gt,qt,Rt=0){this.isClosed=!1,this.multiPath=null,this.acceptPolygon=Gt,this.acceptPolyline=qt,this.geomUnitsPerPoint=Rt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,St&&((0,gt.oU)(St)?Gt&&(this.multiPath=St.rings,this.isClosed=!0):(0,gt.l9)(St)?qt&&(this.multiPath=St.paths,this.isClosed=!1):(0,gt.YX)(St)&&Gt&&(this.multiPath=ue(St).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Ft.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const St=this.processPath(this.multiPath[this.pathIndex]);if(St)return St}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class oe{constructor(St,Gt,qt,Rt=0){this.isClosed=!1,this.multiPath=null,this.inputGeometries=St,this.acceptPolygon=Gt,this.acceptPolyline=qt,this.geomUnitsPerPoint=Rt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let St=this.inputGeometries.next();for(;St;){if((0,gt.oU)(St)?this.acceptPolygon&&(this.multiPath=St.rings,this.isClosed=!0):(0,gt.l9)(St)?this.acceptPolyline&&(this.multiPath=St.paths,this.isClosed=!1):(0,gt.YX)(St)&&this.acceptPolygon&&(this.multiPath=ue(St).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}St=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const St=this.processPath(this.multiPath[this.pathIndex]);if(St)return St}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function ue(ot){return{rings:[[[ot.xmin,ot.ymin],[ot.xmin,ot.ymax],[ot.xmax,ot.ymax],[ot.xmax,ot.ymin],[ot.xmin,ot.ymin]]]}}},29214:(Pe,re,at)=>{at.d(re,{MU:()=>he,ib:()=>Nt,yn:()=>xt}),at(58817);var gt=at(13160);let zt;class he{constructor(dt){this._geometry=dt}next(){const dt=this._geometry;return this._geometry=null,dt}}function Nt(At,dt){let Ct,Ut;zt||(zt=new gt.bN(0,0,0,1)),zt.reset(gt.Vl.Polygon),zt.setPixelMargin(dt+1),zt.setExtent(512);for(const st of At.rings)if(st&&!(st.length<3)){Ct=st[0][0],Ut=-st[0][1],zt.moveTo(Ct,Ut);for(let ft=1;ft<st.length;ft++)Ct=st[ft][0],Ut=-st[ft][1],zt.lineTo(Ct,Ut);zt.close()}const $t=zt.result(!1);if($t){const st=[];for(const ft of $t){const Et=[];st.push(Et);for(const Q of ft)Et.push([Q.x,-Q.y])}return{rings:st}}return{rings:[]}}function xt(At,dt){let Ct,Ut;zt||(zt=new gt.bN(0,0,0,1)),zt.reset(gt.Vl.LineString),zt.setPixelMargin(dt+1),zt.setExtent(512);for(const st of At.paths)if(st&&!(st.length<2)){Ct=st[0][0],Ut=-st[0][1],zt.moveTo(Ct,Ut);for(let ft=1;ft<st.length;ft++)Ct=st[ft][0],Ut=-st[ft][1],zt.lineTo(Ct,Ut)}const $t=zt.result(!1);if($t){const st=[];for(const ft of $t){const Et=[];st.push(Et);for(const Q of ft)Et.push([Q.x,-Q.y])}return{paths:st}}return{paths:[]}}},95727:(Pe,re,at)=>{at.d(re,{h:()=>qe,W:()=>ts});var Wt=at(58817),gt=at(91179),Ft=at(72283);let zt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new he(i,n,P)}}return v.instance=null,v})();class he{constructor(e,i,n){this._inputGeometries=e,this._angleTolerance=void 0!==i.angleTolerance?i.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if((0,gt.oU)(e)){this._isClosed=!0;const i=(0,Wt.d9)(e);return this._processMultipath(i.rings),i}if((0,gt.l9)(e)){this._isClosed=!1;const i=(0,Wt.d9)(e);return this._processMultipath(i.paths),i}if((0,gt.YX)(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const i=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(i),{rings:[i]}}e=this._inputGeometries.next()}return null}_processMultipath(e){if(e)for(const i of e)this._processPath(i)}_processPath(e){if(e){let i,n,P,u,r,M,x=e.length,w=e[0];this._isClosed&&++x;for(let I=1;I<x;++I){let E;E=this._isClosed&&I===x-1?e[0]:e[I];const q=E[0]-w[0],K=E[1]-w[1],lt=Math.sqrt(q*q+K*K);I>1&&lt>0&&P>0&&(i*q+n*K)/lt/P<=this._maxCosAngle&&(0,Ft.qh)(w,1),1===I&&(u=q,r=K,M=lt),lt>0&&(w=E,i=q,n=K,P=lt)}this._isClosed&&P>0&&M>0&&(i*u+n*r)/M/P<=this._maxCosAngle&&(0,Ft.qh)(e[0],1)}}}var tt=at(7547);const Nt=.03;class xt{constructor(){this._path=[]}path(){return this._path}addPath(e,i){i||e.reverse(),Array.prototype.push.apply(this._path,e),i||e.reverse()}static mergePath(e,i){i&&Array.prototype.push.apply(e,i)}startPath(e){this._path.push(e)}lineTo(e){this._path.push(e)}close(){const e=this._path;e.length>1&&(e[0][0]===e[e.length-1][0]&&e[0][1]===e[e.length-1][1]||e.push([e[0][0],e[0][1]]))}}class At{constructor(e=0,i=!1){}normalize(e){const i=Math.sqrt(e[0]*e[0]+e[1]*e[1]);0!==i&&(e[0]/=i,e[1]/=i)}calculateLength(e,i){const n=i[0]-e[0],P=i[1]-e[1];return Math.sqrt(n*n+P*P)}calculateSegLength(e,i){return this.calculateLength(e[i],e[i+1])}calculatePathLength(e){let i=0;const n=e?e.length:0;for(let P=0;P<n-1;++P)i+=this.calculateSegLength(e,P);return i}calculatePathArea(e){let i=0;const n=e?e.length:0;for(let P=0;P<n-1;++P)i+=(e[P+1][0]-e[P][0])*(e[P+1][1]+e[P][1]);return i/2}getCoord2D(e,i,n){return[e[0]+(i[0]-e[0])*n,e[1]+(i[1]-e[1])*n]}getSegCoord2D(e,i,n){return this.getCoord2D(e[i],e[i+1],n)}getAngle(e,i,n){return Math.atan2(i[1]-e[1],i[0]-e[0])}getSegAngle(e,i,n){return this.getAngle(e[i],e[i+1],n)}getAngleCS(e,i,n){const P=i[0]-e[0],u=i[1]-e[1],r=Math.sqrt(P*P+u*u);return r>0?[P/r,u/r]:[1,0]}getSegAngleCS(e,i,n){return this.getAngleCS(e[i],e[i+1],n)}cut(e,i,n,P){return[n<=0?e[i]:this.getSegCoord2D(e,i,n),P>=1?e[i+1]:this.getSegCoord2D(e,i,P)]}addSegment(e,i,n){n&&e.push(i[0]),e.push(i[1])}getSubCurve(e,i,n){const P=[];return this.appendSubCurve(P,e,i,n)?P:null}appendSubCurve(e,i,n,P){const u=i?i.length-1:0;let r=0,M=!0,x=0;for(;x<u;){const w=this.calculateSegLength(i,x);if(0!==w){if(M){if(r+w>n){let E=1,q=!1;r+w>=P&&(E=(P-r)/w,q=!0);const K=this.cut(i,x,(n-r)/w,E);if(K&&this.addSegment(e,K,M),q)break;M=!1}}else{if(r+w>P){const I=this.cut(i,x,0,(P-r)/w);I&&this.addSegment(e,I,M);break}this.addSegment(e,[i[x],i[x+1]],M)}r+=w,++x}else++x}return!0}getCIMPointAlong(e,i){const n=e?e.length-1:0;let P=0,u=-1;for(;u<n;){++u;const r=this.calculateSegLength(e,u);if(0!==r){if(P+r>i)return this.getCoord2D(e[u],e[u+1],(i-P)/r);P+=r}}return null}isEmpty(e,i){if(!e||e.length<=1)return!0;const n=e?e.length-1:0;let P=-1;for(;P<n;)if(++P,e[P+1][0]!==e[P][0]||e[P+1][1]!==e[P][1]||i&&e[P+1][2]!==e[P][2])return!1;return!0}offset(e,i,n,P,u){if(!e||e.length<2)return null;let r=0,M=e[r++],x=r;for(;r<e.length;){const q=e[r];q[0]===M[0]&&q[1]===M[1]||(r!==x&&(e[x]=e[r]),M=e[x++]),r++}const w=e[0][0]===e[x-1][0]&&e[0][1]===e[x-1][1];if(w&&--x,x<(w?3:2))return null;const I=[];M=w?e[x-1]:null;let E=e[0];for(let q=0;q<x;q++){const K=q===x-1?w?e[0]:null:e[q+1];if(M)if(K){const lt=[K[0]-E[0],K[1]-E[1]];this.normalize(lt);const _t=[E[0]-M[0],E[1]-M[1]];this.normalize(_t);const kt=_t[0]*lt[1]-_t[1]*lt[0],Yt=_t[0]*lt[0]+_t[1]*lt[1];if(0===kt&&1===Yt){E=K;continue}if(kt>=0==i<=0){if(Yt<1){const ne=[lt[0]-_t[0],lt[1]-_t[1]];this.normalize(ne);const se=Math.sqrt((1+Yt)/2);if(se>1/P){const Bt=-Math.abs(i)/se;I.push([E[0]-ne[0]*Bt,E[1]-ne[1]*Bt])}}}else switch(n){case tt.id.Mitered:{const ne=Math.sqrt((1+Yt)/2);if(ne>0&&1/ne<P){const se=[lt[0]-_t[0],lt[1]-_t[1]];this.normalize(se);const Bt=Math.abs(i)/ne;I.push([E[0]-se[0]*Bt,E[1]-se[1]*Bt]);break}}case tt.id.Bevelled:I.push([E[0]+_t[1]*i,E[1]-_t[0]*i]),I.push([E[0]+lt[1]*i,E[1]-lt[0]*i]);break;case tt.id.Rounded:if(Yt<1){I.push([E[0]+_t[1]*i,E[1]-_t[0]*i]);const ne=Math.floor(2.5*(1-Yt));if(ne>0){const se=1/ne;let Bt=se;for(let Ce=1;Ce<ne;Ce++,Bt+=se){const ye=[_t[1]*(1-Bt)+lt[1]*Bt,-_t[0]*(1-Bt)-lt[0]*Bt];this.normalize(ye),I.push([E[0]+ye[0]*i,E[1]+ye[1]*i])}}I.push([E[0]+lt[1]*i,E[1]-lt[0]*i])}break;default:if(kt<0)I.push([E[0]+(_t[1]+_t[0])*i,E[1]+(_t[1]-_t[0])*i]),I.push([E[0]+(lt[1]-lt[0])*i,E[1]-(lt[0]+lt[1])*i]);else{const ne=Math.sqrt((1+Math.abs(Yt))/2),se=[lt[0]-_t[0],lt[1]-_t[1]];this.normalize(se);const Bt=i/ne;I.push([E[0]-se[0]*Bt,E[1]-se[1]*Bt])}}}else{const lt=[E[0]-M[0],E[1]-M[1]];this.normalize(lt),I.push([E[0]+lt[1]*i,E[1]-lt[0]*i])}else{const lt=[K[0]-E[0],K[1]-E[1]];this.normalize(lt),I.push([E[0]+lt[1]*i,E[1]-lt[0]*i])}M=E,E=K}return I.length<(w?3:2)?null:(w&&I.push([I[0][0],I[0][1]]),I)}}const dt=1.7320508075688772,Ut=tt.TF.OpenEnded;let $t=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new st(i,n,P)}}return v.instance=null,v})();class st extends Ft.zY{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new At,this._width=(void 0!==i.width?i.width:5)*n,this._arrowType=void 0!==i.geometricEffectArrowType?i.geometricEffectArrowType:void 0!==i.arrowType?i.arrowType:Ut,this._offsetFlattenError=Nt*n}processPath(e){switch(this._arrowType){case tt.TF.OpenEnded:default:return this._constructSimpleArrow(e,!0);case tt.TF.Block:return this._constructSimpleArrow(e,!1);case tt.TF.Crossed:return this._constructCrossedArrow(e)}}_constructSimpleArrow(e,i){const n=this._curveHelper.calculatePathLength(e);let P=this._width;n<2*P&&(P=n/2);const u=this._curveHelper.getSubCurve(e,0,n-P);if(!u)return null;const r=P/2;if(this._curveHelper.isEmpty(u,!1))return null;const M=this._constructOffset(u,-r);if(!M)return null;const x=this._constructOffset(u,r);if(!x)return null;const w=this._constructArrowBasePoint(M,-r/2);if(!w)return null;const I=this._constructArrowBasePoint(x,r/2);if(!I)return null;const E=e[e.length-1];i||(this._makeControlPoint(x,!0),this._makeControlPoint(M,!0));const q=new xt;return q.addPath(x,!0),q.lineTo(I),this._makeControlPoint(q.path()),q.lineTo(E),this._makeControlPoint(q.path()),q.lineTo(w),this._makeControlPoint(q.path()),q.addPath(M,!1),i?{paths:[q.path()]}:(q.close(),{rings:[q.path()]})}_constructCrossedArrow(e){const i=this._curveHelper.calculatePathLength(e);let n=this._width;i<n*(1+dt+1)&&(n=i/(1+dt+1));const P=this._curveHelper.getSubCurve(e,0,i-n*(1+dt));if(!P)return null;const u=n/2;if(this._curveHelper.isEmpty(P,!1))return null;const r=this._constructOffset(P,u);if(!r)return null;const M=this._constructOffset(P,-u);if(!M)return null;const x=this._curveHelper.getSubCurve(e,0,i-n);if(!x||this._curveHelper.isEmpty(x,!1))return null;const w=this._constructOffset(x,u);if(!w)return null;const I=this._constructOffset(x,-u);if(!I)return null;const E=w[w.length-1],q=this._constructArrowBasePoint(w,u/2);if(!q)return null;const K=I[I.length-1],lt=this._constructArrowBasePoint(I,-u/2);if(!lt)return null;const _t=e[e.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(M,!1);const kt=new xt;return kt.addPath(r,!0),this._makeControlPoint(kt.path()),kt.lineTo(K),kt.lineTo(lt),this._makeControlPoint(kt.path()),kt.lineTo(_t),this._makeControlPoint(kt.path()),kt.lineTo(q),this._makeControlPoint(kt.path()),kt.lineTo(E),this._makeControlPoint(kt.path()),kt.addPath(M,!1),{paths:[kt.path()]}}_constructOffset(e,i){return this._curveHelper.offset(e,i,tt.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(e,i){if(!e||e.length<2)return null;const n=e[e.length-2],P=e[e.length-1],u=[P[0]-n[0],P[1]-n[1]];return this._curveHelper.normalize(u),[P[0]+u[1]*i,P[1]-u[0]*i]}_makeControlPoint(e,i=!1){(0,Ft.qh)(i?e[0]:e[e.length-1],1)}}at(29132);var Et=at(62208),Q=at(29214),Jt=at(65234);let Vt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new Ht(i,n,P,u,r)}}return v.instance=null,v})();class Ht{constructor(e,i,n,P,u){this._inputGeometries=e,this._tileKey=P,this._geometryEngine=u,this._curveHelper=new At,this._size=(void 0!==i.size?i.size:1)*n,this._offsetFlattenError=Nt*n}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._size)return e;if((0,gt.YX)(e))if(this._size>0){const u=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],this._size,tt.id.Rounded,4,this._offsetFlattenError);if(u)return{rings:[u]}}else if(this._size<0&&Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._size>0)return{xmin:e.xmin-this._size,xmax:e.xmax+this._size,ymin:e.ymin-this._size,ymax:e.ymax+this._size};const i=this._geometryEngine;if((0,Et.Wi)(i))return null;let n=e;if((!(0,gt.oU)(e)||!this._tileKey||(n=(0,Q.ib)(e,Math.abs(this._size)+1),n&&n.rings&&0!==n.rings.length))&&(!(0,gt.l9)(e)||!this._tileKey||(n=(0,Q.yn)(e,Math.abs(this._size)+1),n&&n.paths&&0!==n.paths.length)))return i.buffer(Jt.Z.WebMercator,n,this._size,1)}return null}}let oe=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new ue(i,n,P)}}return v.instance=null,v})();class ue{constructor(e,i,n){var P;this._defaultPointSize=20,this._inputGeometries=e,this._geomUnitsPerPoint=n,this._rule=null!=(P=i.rule)?P:tt.Em.FullGeometry,this._defaultSize=this._defaultPointSize*n}next(){let e;for(;e=this._inputGeometries.next();){let i;if((0,gt.wp)(e)?i=this._processGeom([[[e.x,e.y]]]):(0,gt.aW)(e)?i=this._processGeom([e.points]):(0,gt.l9)(e)?i=this._processGeom(e.paths):(0,gt.oU)(e)&&(i=this._processGeom(e.rings)),i&&i.length)return{paths:i}}return null}_clone(e){return[e[0],e[1]]}_mid(e,i){return[(e[0]+i[0])/2,(e[1]+i[1])/2]}_mix(e,i,n,P){return[e[0]*i+n[0]*P,e[1]*i+n[1]*P]}_add(e,i){return[e[0]+i[0],e[1]+i[1]]}_add2(e,i,n){return[e[0]+i,e[1]+n]}_sub(e,i){return[e[0]-i[0],e[1]-i[1]]}_dist(e,i){return Math.sqrt((e[0]-i[0])*(e[0]-i[0])+(e[1]-i[1])*(e[1]-i[1]))}_norm(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}_normalize(e,i=1){const n=i/this._norm(e);e[0]*=n,e[1]*=n}_leftPerpendicular(e){const n=e[0];e[0]=-e[1],e[1]=n}_leftPerp(e){return[-e[1],e[0]]}_rightPerpendicular(e){const n=-e[0];e[0]=e[1],e[1]=n}_rightPerp(e){return[e[1],-e[0]]}_dotProduct(e,i){return e[0]*i[0]+e[1]*i[1]}_crossProduct(e,i){return e[0]*i[1]-e[1]*i[0]}_rotateDirect(e,i,n){const u=e[0]*n+e[1]*i;e[0]=e[0]*i-e[1]*n,e[1]=u}_makeCtrlPt(e){const i=[e[0],e[1]];return(0,Ft.qh)(i,1),i}_addAngledTicks(e,i,n,P){const u=this._sub(n,i);this._normalize(u);const r=this._crossProduct(u,this._sub(P,i));let M;M=r>0?this._rightPerp(u):this._leftPerp(u);const x=Math.abs(r)/2,w=[];w.push([i[0]+(M[0]-u[0])*x,i[1]+(M[1]-u[1])*x]),w.push(i),w.push(n),w.push([n[0]+(M[0]+u[0])*x,n[1]+(M[1]+u[1])*x]),e.push(w)}_addBezier2(e,i,n,P,u){if(0==u--)return void e.push(P);const r=this._mid(i,n),M=this._mid(n,P),x=this._mid(r,M);this._addBezier2(e,i,r,x,u),this._addBezier2(e,x,M,P,u)}_addBezier3(e,i,n,P,u,r){if(0==r--)return void e.push(u);const M=this._mid(i,n),x=this._mid(n,P),w=this._mid(P,u),I=this._mid(M,x),E=this._mid(x,w),q=this._mid(I,E);this._addBezier3(e,i,M,I,q,r),this._addBezier3(e,q,E,w,u,r)}_add90DegArc(e,i,n,P,u){const r=null!=u?u:this._crossProduct(this._sub(n,i),this._sub(P,i))>0,M=this._mid(i,n),x=this._sub(M,i);r?this._leftPerpendicular(x):this._rightPerpendicular(x),M[0]+=x[0],M[1]+=x[1],this._addBezier3(e,i,this._mix(i,.33333,M,.66667),this._mix(n,.33333,M,.66667),n,4)}_addArrow(e,i,n){const P=i[0],u=i[1],r=i[i.length-1],M=this._sub(P,u);this._normalize(M);const x=this._crossProduct(M,this._sub(r,u)),w=.5*x,I=this._leftPerp(M),E=[r[0]-I[0]*x,r[1]-I[1]*x],q=i.length-1,K=[];K.push(n?[-I[0],-I[1]]:I);let lt=[-M[0],-M[1]];for(let _t=1;_t<q-1;_t++){const kt=this._sub(i[_t+1],i[_t]);this._normalize(kt);const Yt=this._dotProduct(kt,lt),ne=this._crossProduct(kt,lt),se=Math.sqrt((1+Yt)/2),Bt=this._sub(kt,lt);this._normalize(Bt),Bt[0]/=se,Bt[1]/=se,K.push(ne<0?[-Bt[0],-Bt[1]]:Bt),lt=kt}K.push(this._rightPerp(lt));for(let _t=K.length-1;_t>0;_t--)e.push([i[_t][0]+K[_t][0]*w,i[_t][1]+K[_t][1]*w]);e.push([E[0]+K[0][0]*w,E[1]+K[0][1]*w]),e.push([E[0]+K[0][0]*x,E[1]+K[0][1]*x]),e.push(P),e.push([E[0]-K[0][0]*x,E[1]-K[0][1]*x]),e.push([E[0]-K[0][0]*w,E[1]-K[0][1]*w]);for(let _t=1;_t<K.length;_t++)e.push([i[_t][0]-K[_t][0]*w,i[_t][1]-K[_t][1]*w])}_cp2(e,i,n){return e.length>=2?e[1]:this._add2(e[0],i*this._defaultSize,n*this._defaultSize)}_cp3(e,i,n,P){if(e.length>=3)return e[2];const u=this._mix(e[0],1-n,i,n),r=this._sub(i,e[0]);return this._normalize(r),this._rightPerpendicular(r),[u[0]+r[0]*P*this._defaultSize,u[1]+r[1]*P*this._defaultSize]}_arrowPath(e){if(e.length>2)return e;const i=e[0],n=this._cp2(e,-4,0),P=this._sub(i,n);this._normalize(P);const u=this._rightPerp(P);return[i,n,[i[0]+(u[0]-P[0])*this._defaultSize,i[1]+(u[1]-P[1])*this._defaultSize]]}_arrowLastSeg(e){const i=e[0],n=this._cp2(e,-4,0);let P;if(e.length>=3)P=e[e.length-1];else{const u=this._sub(i,n);this._normalize(u);const r=this._rightPerp(u);P=[i[0]+(r[0]-u[0])*this._defaultSize,i[1]+(r[1]-u[1])*this._defaultSize]}return[n,P]}_processGeom(e){if(!e)return null;const i=[];for(const n of e){if(!n||0===n.length)continue;const P=n.length;let u=n[0];switch(this._rule){case tt.Em.PerpendicularFromFirstSegment:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,4),x=[];x.push(M),x.push(this._mid(u,r)),i.push(x);break}case tt.Em.ReversedFirstSegment:{const r=this._cp2(n,0,-1);i.push([r,u]);break}case tt.Em.PerpendicularToSecondSegment:{const r=this._cp2(n,-4,1),M=this._cp3(n,r,.882353,-1.94),x=[];x.push(this._mid(r,M)),x.push(u),i.push(x);break}case tt.Em.SecondSegmentWithTicks:{const r=this._cp2(n,-4,1),M=this._cp3(n,r,.882353,-1.94),x=this._sub(M,r);let w;w=this._crossProduct(x,this._sub(u,r))>0?this._rightPerp(w):this._leftPerp(x);const I=[];I.push([r[0]+(w[0]-x[0])/3,r[1]+(w[1]-x[1])/3]),I.push(r),I.push(M),I.push([M[0]+(w[0]+x[0])/3,M[1]+(w[1]+x[1])/3]),i.push(I);break}case tt.Em.DoublePerpendicular:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,3),x=this._mid(u,r),w=this._sub(x,M);this._normalize(w);const I=this._crossProduct(w,this._sub(u,M));this._leftPerpendicular(w);const E=[];E.push(u),E.push([M[0]+w[0]*I,M[1]+w[1]*I]),i.push(E);const q=[];q.push([M[0]-w[0]*I,M[1]-w[1]*I]),q.push(r),i.push(q);break}case tt.Em.OppositeToFirstSegment:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,3),x=this._mid(u,r),w=this._sub(x,M);this._normalize(w);const I=this._crossProduct(w,this._sub(u,M));this._leftPerpendicular(w);const E=[];E.push([M[0]+w[0]*I,M[1]+w[1]*I]),E.push([M[0]-w[0]*I,M[1]-w[1]*I]),i.push(E);break}case tt.Em.TriplePerpendicular:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,4),x=this._mid(u,r),w=this._sub(x,M);this._normalize(w);const I=this._crossProduct(w,this._sub(u,M));this._leftPerpendicular(w);const E=[];E.push([M[0]+w[0]*I*.8,M[1]+w[1]*I*.8]),E.push([x[0]+.8*(u[0]-x[0]),x[1]+.8*(u[1]-x[1])]),i.push(E),i.push([M,x]);const q=[];q.push([M[0]-w[0]*I*.8,M[1]-w[1]*I*.8]),q.push([x[0]+.8*(r[0]-x[0]),x[1]+.8*(r[1]-x[1])]),i.push(q);break}case tt.Em.HalfCircleFirstSegment:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,4),x=this._mid(u,r);let w=this._sub(r,u);const I=Math.cos(Math.PI/18),E=Math.sin(Math.PI/18),q=Math.sqrt((1+I)/2),K=Math.sqrt((1-I)/2),lt=[];let _t;this._crossProduct(w,this._sub(M,u))>0?(lt.push(u),w=this._sub(u,x),_t=r):(lt.push(r),w=this._sub(r,x),_t=u),this._rotateDirect(w,q,K),w[0]/=q,w[1]/=q;for(let kt=1;kt<=18;kt++)lt.push(this._add(x,w)),this._rotateDirect(w,I,E);lt.push(_t),i.push(lt);break}case tt.Em.HalfCircleSecondSegment:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,1,-1);let x=this._sub(u,r);this._normalize(x);const w=this._crossProduct(x,this._sub(M,r))/2;this._leftPerpendicular(x);const I=[r[0]+x[0]*w,r[1]+x[1]*w];x=this._sub(r,I);const E=Math.cos(Math.PI/18);let q=Math.sin(Math.PI/18);w>0&&(q=-q);const K=[r];for(let lt=1;lt<=18;lt++)this._rotateDirect(x,E,q),K.push(this._add(I,x));i.push(K);break}case tt.Em.HalfCircleExtended:{const r=this._cp2(n,0,-2),M=this._cp3(n,r,1,-1);let x;if(P>=4)x=n[3];else{const lt=this._sub(u,r);x=this._add(M,lt)}const w=this._dist(r,M)/2/.75,I=this._sub(r,u);this._normalize(I,w);const E=this._sub(M,x);this._normalize(E,w),i.push([x,M]);const K=[this._clone(M)];this._addBezier3(K,M,this._add(M,E),this._add(r,I),r,4),K.push(u),i.push(K);break}case tt.Em.OpenCircle:{const r=this._cp2(n,-2,0),M=this._sub(r,u),x=Math.cos(Math.PI/18),w=-Math.sin(Math.PI/18),I=[r];for(let E=1;E<=33;E++)this._rotateDirect(M,x,w),I.push(this._add(u,M));i.push(I);break}case tt.Em.CoverageEdgesWithTicks:{const r=this._cp2(n,0,-1);let M,x;if(P>=3)M=n[2];else{const q=this._sub(r,u),K=this._leftPerp(q);M=[u[0]+K[0]-.25*q[0],u[1]+K[1]-.25*q[1]]}if(P>=4)x=n[3];else{const q=this._mid(u,r),K=this._sub(u,r);this._normalize(K),this._leftPerpendicular(K);const lt=this._crossProduct(K,this._sub(M,q));this._rightPerpendicular(K),x=[M[0]+K[0]*lt*2,M[1]+K[1]*lt*2]}const w=this._sub(r,u);let I,E;I=this._crossProduct(w,this._sub(M,u))>0?this._rightPerp(w):this._leftPerp(w),E=[],E.push(M),E.push(u),E.push([u[0]+(I[0]-w[0])/3,u[1]+(I[1]-w[1])/3]),i.push(E),I=this._crossProduct(w,this._sub(x,r))>0?this._rightPerp(I):this._leftPerp(w),E=[],E.push([r[0]+(I[0]+w[0])/3,r[1]+(I[1]+w[1])/3]),E.push(r),E.push(x),i.push(E);break}case tt.Em.GapExtentWithDoubleTicks:{const r=this._cp2(n,0,2),M=this._cp3(n,r,0,1);let x;if(P>=4)x=n[3];else{const w=this._sub(r,u);x=this._add(M,w)}this._addAngledTicks(i,u,r,this._mid(M,x)),this._addAngledTicks(i,M,x,this._mid(u,r));break}case tt.Em.GapExtentMidline:{const r=this._cp2(n,2,0),M=this._cp3(n,r,0,1);let x;if(P>=4)x=n[3];else{const I=this._sub(r,u);x=this._add(M,I)}const w=[];w.push(this._mid(u,M)),w.push(this._mid(r,x)),i.push(w);break}case tt.Em.Chevron:{const r=this._cp2(n,-1,-1);let M;if(P>=3)M=n[2];else{const x=this._sub(r,u);this._leftPerpendicular(x),M=this._add(u,x)}i.push([r,this._makeCtrlPt(u),M]);break}case tt.Em.PerpendicularWithArc:{const r=this._cp2(n,0,-2),M=this._cp3(n,r,.5,-1);let x=this._sub(r,u);const w=this._norm(x);x[0]/=w,x[1]/=w;const I=this._crossProduct(x,this._sub(M,u));let E=this._dotProduct(x,this._sub(M,u));E<.05*w?E=.05*w:E>.95*w&&(E=.95*w);const q=[u[0]+x[0]*E,u[1]+x[1]*E];this._leftPerpendicular(x);let K=[];K.push([q[0]-x[0]*I,q[1]-x[1]*I]),K.push([q[0]+x[0]*I,q[1]+x[1]*I]),i.push(K);const lt=[r[0]+x[0]*I,r[1]+x[1]*I];x=this._sub(r,lt);const _t=Math.cos(Math.PI/18);let kt=Math.sin(Math.PI/18);I<0&&(kt=-kt),K=[u,r];for(let Yt=1;Yt<=9;Yt++)this._rotateDirect(x,_t,kt),K.push(this._add(lt,x));i.push(K);break}case tt.Em.ClosedHalfCircle:{const r=this._cp2(n,2,0),M=this._mid(u,r),x=this._sub(r,M),w=Math.cos(Math.PI/18),I=Math.sin(Math.PI/18),E=[u,r];for(let q=1;q<=18;q++)this._rotateDirect(x,w,I),E.push(this._add(M,x));i.push(E);break}case tt.Em.TripleParallelExtended:{const r=this._cp2(n,0,-2),M=this._cp3(n,r,1,-2),x=this._mid(u,r),w=this._sub(M,r);this._normalize(w);const I=Math.abs(this._crossProduct(w,this._sub(x,r)))/2,E=this._dist(r,M),q=[r,u];q.push([u[0]+w[0]*E*.5,u[1]+w[1]*E*.5]),i.push(q);const K=[];K.push([x[0]-w[0]*I,x[1]-w[1]*I]),K.push([x[0]+w[0]*E*.375,x[1]+w[1]*E*.375]),(0,Ft.qh)(K[K.length-1],1),K.push([x[0]+w[0]*E*.75,x[1]+w[1]*E*.75]),i.push(K),i.push([r,M]);break}case tt.Em.ParallelWithTicks:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._sub(M,r);this._normalize(x);const w=this._crossProduct(x,this._sub(M,u));this._leftPerpendicular(x),this._addAngledTicks(i,u,r,M),this._addAngledTicks(i,this._mix(u,1,x,w),this._mix(r,1,x,w),this._mid(u,r));break}case tt.Em.Parallel:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._sub(r,u);this._normalize(x);const w=this._leftPerp(x),I=this._crossProduct(x,this._sub(M,u));let E=[u,r];i.push(E),E=[],E.push([u[0]+w[0]*I,u[1]+w[1]*I]),E.push([r[0]+w[0]*I,r[1]+w[1]*I]),i.push(E);break}case tt.Em.PerpendicularToFirstSegment:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._mid(u,r),w=this._sub(r,u);this._normalize(w);const I=this._crossProduct(w,this._sub(M,u));this._leftPerpendicular(w);const E=[];E.push([x[0]-w[0]*I*.25,x[1]-w[1]*I*.25]),E.push([x[0]+w[0]*I*1.25,x[1]+w[1]*I*1.25]),i.push(E);break}case tt.Em.ParallelOffset:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._sub(r,u);this._normalize(x);const w=this._crossProduct(x,this._sub(M,u));this._leftPerpendicular(x);const I=[];I.push([u[0]-x[0]*w,u[1]-x[1]*w]),I.push([r[0]-x[0]*w,r[1]-x[1]*w]),i.push(I);const E=[];E.push([u[0]+x[0]*w,u[1]+x[1]*w]),E.push([r[0]+x[0]*w,r[1]+x[1]*w]),i.push(E);break}case tt.Em.OffsetOpposite:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._sub(r,u);this._normalize(x);const w=this._crossProduct(x,this._sub(M,u));this._leftPerpendicular(x);const I=[];I.push([u[0]-x[0]*w,u[1]-x[1]*w]),I.push([r[0]-x[0]*w,r[1]-x[1]*w]),i.push(I);break}case tt.Em.OffsetSame:{const r=this._cp2(n,3,0),M=this._cp3(n,r,.5,-1),x=this._sub(r,u);this._normalize(x);const w=this._crossProduct(x,this._sub(M,u));this._leftPerpendicular(x);const I=[];I.push([u[0]+x[0]*w,u[1]+x[1]*w]),I.push([r[0]+x[0]*w,r[1]+x[1]*w]),i.push(I);break}case tt.Em.CircleWithArc:{let r=this._cp2(n,3,0);const M=this._cp3(n,r,.5,-1);let x,w;if(P>=4)x=n[3],w=this._crossProduct(this._sub(x,r),this._sub(M,r))>0;else{x=r,w=this._crossProduct(this._sub(x,u),this._sub(M,u))>0;const lt=24*this._geomUnitsPerPoint,_t=this._sub(x,u);this._normalize(_t,lt);const kt=Math.sqrt(2)/2;this._rotateDirect(_t,kt,w?kt:-kt),r=this._add(u,_t)}const I=this._sub(r,u),E=Math.cos(Math.PI/18),q=Math.sin(Math.PI/18),K=[r];for(let lt=1;lt<=36;lt++)this._rotateDirect(I,E,q),K.push(this._add(u,I));this._add90DegArc(K,r,x,M,w),(0,Ft.qh)(K[K.length-8],1),i.push(K);break}case tt.Em.DoubleJog:{let r,M,x=this._cp2(n,-3,1);if(r=P>=3?n[2]:this._add(u,this._sub(u,x)),P>=4)M=n[3];else{const Yt=u;u=x,M=r;const ne=this._dist(u,Yt),se=this._dist(M,Yt);let Bt=30*this._geomUnitsPerPoint;.5*ne<Bt&&(Bt=.5*ne),.5*se<Bt&&(Bt=.5*se),x=this._mix(u,Bt/ne,Yt,(ne-Bt)/ne),r=this._mix(M,Bt/se,Yt,(se-Bt)/se)}const w=this._mid(u,x),I=this._mid(M,r),E=this._dist(u,x),q=this._dist(r,M);let K=Math.min(E,q)/8;K=Math.min(K,24*this._geomUnitsPerPoint);const lt=Math.cos(Math.PI/4);let _t=this._sub(u,x);this._normalize(_t,K),this._crossProduct(_t,this._sub(M,x))>0?this._rotateDirect(_t,lt,-lt):this._rotateDirect(_t,lt,lt);let kt=[];kt.push(x),kt.push(this._add(w,_t)),kt.push(this._sub(w,_t)),kt.push(u),i.push(kt),_t=this._sub(M,r),this._normalize(_t,K),this._crossProduct(_t,this._sub(u,r))<0?this._rotateDirect(_t,lt,lt):this._rotateDirect(_t,lt,-lt),kt=[],kt.push(r),kt.push(this._add(I,_t)),kt.push(this._sub(I,_t)),kt.push(M),i.push(kt);break}case tt.Em.PerpendicularOffset:{const r=this._cp2(n,-4,1),M=this._cp3(n,r,.882353,-1.94),x=this._sub(M,r);this._crossProduct(x,this._sub(u,r))>0?this._rightPerpendicular(x):this._leftPerpendicular(x);const w=[x[0]/8,x[1]/8],I=this._sub(this._mid(r,M),w);i.push([I,u]);break}case tt.Em.LineExcludingLastSegment:{const r=this._arrowPath(n),M=[];let x=r.length-2;for(;x--;)M.push(r[x]);i.push(M);break}case tt.Em.MultivertexArrow:{const r=this._arrowPath(n),M=[];this._addArrow(M,r,!1),i.push(M);break}case tt.Em.CrossedArrow:{const r=this._arrowPath(n),M=[];this._addArrow(M,r,!0),i.push(M);break}case tt.Em.ChevronArrow:{const[r,M]=this._arrowLastSeg(n),x=10*this._geomUnitsPerPoint,w=this._sub(u,r);this._normalize(w);const I=this._crossProduct(w,this._sub(M,r)),E=this._leftPerp(w),q=[M[0]-E[0]*I*2,M[1]-E[1]*I*2],K=[];K.push([M[0]+w[0]*x,M[1]+w[1]*x]),K.push(u),K.push([q[0]+w[0]*x,q[1]+w[1]*x]),i.push(K);break}case tt.Em.ChevronArrowOffset:{const[r,M]=this._arrowLastSeg(n),x=this._sub(u,r);this._normalize(x);const w=this._crossProduct(x,this._sub(M,r));this._leftPerpendicular(x);const I=[M[0]-x[0]*w,M[1]-x[1]*w],E=[];E.push([I[0]+x[0]*w*.5,I[1]+x[1]*w*.5]),E.push(this._mid(I,u)),E.push([I[0]-x[0]*w*.5,I[1]-x[1]*w*.5]),i.push(E);break}case tt.Em.PartialFirstSegment:{const[r,M]=this._arrowLastSeg(n),x=this._sub(u,r);this._normalize(x);const w=this._crossProduct(x,this._sub(M,r));this._leftPerpendicular(x),i.push([r,[M[0]-x[0]*w,M[1]-x[1]*w]]);break}case tt.Em.Arch:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,1),x=this._sub(u,r),w=this._mix(M,1,x,.55),I=this._mix(M,1,x,-.55),E=[u];this._addBezier2(E,u,w,M,4),this._addBezier2(E,M,I,r,4),i.push(E);break}case tt.Em.CurvedParallelTicks:{const r=this._cp2(n,-4,1),M=this._cp3(n,r,.882353,-1.94),x=this._sub(M,r);this._crossProduct(x,this._sub(u,r))>0?this._rightPerpendicular(x):this._leftPerpendicular(x);const w=[x[0]/8,x[1]/8],I=this._sub(this._mid(r,M),w),E=this._sub(this._mix(r,.75,M,.25),w),q=this._sub(this._mix(r,.25,M,.75),w),K=[r];this._addBezier2(K,r,E,I,3),this._addBezier2(K,I,q,M,3),i.push(K);for(let lt=0;lt<8;lt++){const _t=K[2*lt+1],kt=[this._clone(_t)];kt.push(this._add(_t,[x[0]/4,x[1]/4])),i.push(kt)}break}case tt.Em.Arc90Degrees:{const r=this._cp2(n,0,-1),M=this._cp3(n,r,.5,1),x=[r];this._add90DegArc(x,r,u,M),i.push(x);break}default:i.push(n)}}return i}}let ot=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new St(i,n,P)}}return v.instance=null,v})();class St extends Ft.zY{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new At,this._beginCut=(void 0!==i.beginCut?i.beginCut:1)*n,this._endCut=(void 0!==i.endCut?i.endCut:1)*n,this._middleCut=(void 0!==i.middleCut?i.middleCut:0)*n,this._invert=void 0!==i.invert&&i.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(e){const i=this._beginCut,n=this._endCut,P=this._middleCut,u=this._curveHelper.calculatePathLength(e),r=[];if(this._invert){if(0!==i||0!==n||0!==P)if(i+n+P>=u)r.push(e);else{let M=this._curveHelper.getSubCurve(e,0,i);M&&r.push(M),M=this._curveHelper.getSubCurve(e,.5*(u-P),.5*(u+P)),M&&r.push(M),M=this._curveHelper.getSubCurve(e,u-n,n),M&&r.push(M)}}else if(0===i&&0===n&&0===P)r.push(e);else if(!(i+n+P>=u))if(0===P){const M=this._curveHelper.getSubCurve(e,i,u-n);M&&r.push(M)}else{let M=this._curveHelper.getSubCurve(e,i,.5*(u-P));M&&r.push(M),M=this._curveHelper.getSubCurve(e,.5*(u+P),u-n),M&&r.push(M)}return 0===r.length?null:{paths:r}}}class qt{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(e,i,n=!0){if(this._setEmpty(),!e||0===e.length)return!1;for(let P=0;P<e.length;P++){let u=Math.abs(e[P]);n&&u<1e-7&&(u=1e-7),this._values.push(u),this._length+=u}return i&&1&e.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(e){const i=this._values?this._values.length:0;for(let n=0;n<i;++n)this._values[n]*=e;this._length*=e,this.extPtGap*=e,this.ctrlPtGap*=e}addValue(e){this._length+=e,this._values.push(e)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class Rt{constructor(){this.pt=null,this.ca=0,this.sa=0}}var ie,v;(v=ie||(ie={}))[v.FAIL=0]="FAIL",v[v.END=1]="END",v[v.CONTINUE=2]="CONTINUE";class Ot{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(e){e.segment=this.segment,e.segmentLength=this.segmentLength,e.abscissa=this.abscissa,e.isPathEnd=this.isPathEnd,e.isPartEnd=this.isPartEnd}}class pt extends At{constructor(e=0,i=!1){super(e,i),this._tolerance=Nt,this._currentPosition=new Ot}updateTolerance(e){this._tolerance=Nt*e}init(e,i,n=!0){return n?(this._patternLength=i.length(),this._partExtPtGap=i.extPtGap,this._partCtrlPtGap=i.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=e,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(e,i=ie.FAIL){const n=new Ot;return!!this._nextPosition(e,n,null,i)&&(n.copyTo(this._currentPosition),!0)}curPointAndAngle(e){e.pt=this._getPoint(this._currentPosition);const[i,n]=this._getAngle(this._currentPosition);e.ca=i,e.sa=n}nextPointAndAngle(e,i,n=ie.FAIL){const P=new Ot;if(!this._nextPosition(e,P,null,n))return!1;P.copyTo(this._currentPosition),i.pt=this._getPoint(P);const[u,r]=this._getAngle(P);return i.ca=u,i.sa=r,!0}nextCurve(e){if(0===e)return null;const i=[],n=new Ot;return this._nextPosition(e,n,i,ie.END)?(n.copyTo(this._currentPosition),i):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(e,i,n,P){if(this._currentPosition.isPathEnd)return!1;let u=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(u/=this._currentPosition.segmentLength),this._currentPosition.copyTo(i);i.abscissa+e*this._partLengthRatio>i.segmentLength+this._tolerance;){if(n){if(0===n.length)if(0===u){const M=this._path[i.segment];n.push([M[0],M[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,u));const r=this._path[i.segment+1];n.push([r[0],r[1]])}if(u=0,e-=(i.segmentLength-i.abscissa)/this._partLengthRatio,this._partSegCount)i.segment=this._nextSegment(),i.segmentLength=this.calculateSegLength(this._path,i.segment),i.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return P!==ie.FAIL&&(i.segmentLength=this.calculateSegLength(this._path,i.segment),i.isPartEnd=!0,P===ie.END?(i.abscissa=i.segmentLength,i.isPathEnd=!0):i.abscissa=i.segmentLength+e,!0);this._currentPosition.copyTo(i)}}if(i.abscissa+=e*this._partLengthRatio,n){if(0===n.length)if(0===u){const M=this._path[i.segment];n.push([M[0],M[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,u));const r=i.abscissa/i.segmentLength;if(1===r){const M=this._path[i.segment+1];n.push([M[0],M[1]])}else n.push(this.getSegCoord2D(this._path,i.segment,r))}return this._partSegCount||Math.abs(i.abscissa-i.segmentLength)<this._tolerance&&(i.isPathEnd=this._partIsLast,i.isPartEnd=!0),!0}_getPoint(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_getAngle(e){if(-1===e.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,e.segment,e.segmentLength<=0?0:e.abscissa/e.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Ft.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let e=this._partSegCount;for(;e;)this._previousSegment(),--e;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const i=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Ft.zv)(this._path[i]);let n=i+this._partSegCount+1;if(n>=this._path.length&&(n=0),this._ctrlPtEnd=1===(0,Ft.zv)(this._path[n]),this._patternLength>0){const P=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,u=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(P+u))/this._patternLength);r<=0&&(r=P+u>0?0:1),this._partLengthRatio=this._partLength/(P+u+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let Mt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new ut(i,n,P)}}return v.instance=null,v})();class ut extends Ft.zY{constructor(e,i,n){var P,u;super(e,!0,!0),this._firstCurve=null,this._walker=new pt,this._walker.updateTolerance(n),this._endings=i.lineDashEnding,this._customDashPos=-(null!=(P=i.offsetAlongLine)?P:0)*n,this._offsetAtEnd=(null!=(u=i.customEndingOffset)?u:0)*n,this._pattern=new qt,this._pattern.init(i.dashTemplate,!0),this._pattern.scale(n)}processPath(e){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[e]};if(!this.iteratePath){let P=!0;switch(this._endings){case tt.sj.HalfPattern:case tt.sj.HalfGap:default:this._pattern.extPtGap=0;break;case tt.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case tt.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case tt.sj.NoConstraint:this.isClosed||(P=!1);break;case tt.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const u=this._walker.calculatePathLength(e);if(this._pattern.isEmpty()||u<.1*this._pattern.length())return{paths:[e]};if(!this._walker.init(e,this._pattern,P))return{paths:[e]}}let i;if(this.iteratePath)i=this._pattern.nextValue();else{let P;switch(this._endings){case tt.sj.HalfPattern:default:P=.5*this._pattern.firstValue();break;case tt.sj.HalfGap:P=.5*-this._pattern.lastValue();break;case tt.sj.FullGap:P=-this._pattern.lastValue();break;case tt.sj.FullPattern:P=0;break;case tt.sj.NoConstraint:case tt.sj.Custom:P=-this._customDashPos}let u=P/this._pattern.length();u-=Math.floor(u),P=u*this._pattern.length(),this._pattern.reset(),i=this._pattern.nextValue();let r=!1;for(;P>=i;)P-=i,i=this._pattern.nextValue(),r=!r;i-=P,r?(this._walker.nextPosition(i),i=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(i),i=this._pattern.nextValue(),this._walker.nextPosition(i),i=this._pattern.nextValue())}let n=this._walker.nextCurve(i);return n?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),xt.mergePath(n,this._firstCurve),this._firstCurve=null)):(i=this._pattern.nextValue(),!this._walker.nextPosition(i)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(n=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,n=this._firstCurve,this._firstCurve=null),{paths:[n]}}}let Pt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new wt(i,n,P,u,r)}}return v.instance=null,v})();class wt{constructor(e,i,n,P,u){this._inputGeometries=e,this._tileKey=P,this._geometryEngine=u,this._width=(void 0!==i.width?i.width:2)*n,this._option=i.option}next(){let e;for(;e=this._inputGeometries.next();){if((0,gt.YX)(e)&&this._width>0){if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)-2*this._width<0)return e;const i=[];return i.push([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]),i.push([[e.xmin+this._width,e.ymin+this._width],[e.xmax-this._width,e.ymin+this._width],[e.xmax-this._width,e.ymax-this._width],[e.xmin+this._width,e.ymax-this._width],[e.xmin+this._width,e.ymin+this._width]]),{rings:i}}if((0,gt.oU)(e)){let i=null;const n=this._geometryEngine;let P=e;if(this._tileKey&&(P=(0,Q.ib)(e,Math.abs(this._width)+1),!P||!P.rings||0===P.rings.length))continue;if((0,Et.pC)(n)&&(i=n.buffer(Jt.Z.WebMercator,P,-this._width,1)),this._width>0){const u=[];for(const r of e.rings)r&&u.push(r);if(i)for(const r of i.rings)r&&u.push(r.reverse());if(u.length)return{rings:u}}}}return null}}let Dt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new te(i,n,P)}}return v.instance=null,v})();class te extends Ft.zY{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new At,this._length=(void 0!==i.length?i.length:20)*n,this._angle=void 0!==i.angle?i.angle:225,this._position=void 0!==i.position?i.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(e){if(this._curveHelper.isEmpty(e,!1))return null;const i=e[0],n=e[e.length-1];this._curveHelper.normalize([n[0]-i[0],n[1]-i[1]]);const u=[i[0]+(n[0]-i[0])*this._position/100,i[1]+(n[1]-i[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let M=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(M=-M),this._mirror=!this._mirror,{paths:[[i,[u[0]-this._length/2*r,u[1]-this._length/2*M],[u[0]+this._length/2*r,u[1]+this._length/2*M],n]]}}}let Kt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new ce(i,n,P)}}return v.instance=null,v})();class ce{constructor(e,i,n){this._inputGeometries=e,this._offsetX=void 0!==i.offsetX?i.offsetX*n:0,this._offsetY=void 0!==i.offsetY?-i.offsetY*n:0}next(){let e=this._inputGeometries.next();for(;e;){if((0,gt.YX)(e))return{xmin:e.xmin+this._offsetX,xmax:e.xmax+this._offsetX,ymin:e.ymin+this._offsetY,ymax:e.ymax+this._offsetY};if((0,gt.oU)(e)){const i=(0,Wt.d9)(e);return this._moveMultipath(i.rings,this._offsetX,this._offsetY),i}if((0,gt.l9)(e)){const i=(0,Wt.d9)(e);return this._moveMultipath(i.paths,this._offsetX,this._offsetY),i}if((0,gt.aW)(e)){const i=(0,Wt.d9)(e);return this._movePath(i.points,this._offsetX,this._offsetY),i}if((0,gt.wp)(e))return{x:e.x+this._offsetX,y:e.y+this._offsetY};e=this._inputGeometries.next()}return null}_moveMultipath(e,i,n){if(e)for(const P of e)this._movePath(P,i,n)}_movePath(e,i,n){if(e)for(const P of e)P[0]+=i,P[1]+=n}}let fe=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new It(i,n,P,u,r)}}return v.instance=null,v})();class It{constructor(e,i,n,P,u){var r;this._inputGeometries=e,this._tileKey=P,this._geometryEngine=u,this._curveHelper=new At,this._offset=(null!=(r=i.offset)?r:1)*n,this._method=i.method,this._option=i.option,this._offsetFlattenError=Nt*n}next(){let e;for(;e=this._inputGeometries.next();){if(0===this._offset)return e;if((0,gt.YX)(e)){if(this._method===tt.id.Rounded&&this._offset>0){const u=this._curveHelper.offset([[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return u?{rings:[u]}:null}if(Math.min(e.xmax-e.xmin,e.ymax-e.ymin)+2*this._offset>0)return{xmin:e.xmin-this._offset,xmax:e.xmax+this._offset,ymin:e.ymin-this._offset,ymax:e.ymax+this._offset}}const i=this._geometryEngine;if((0,Et.Wi)(i))return null;let n=e;if((0,gt.oU)(e)){if(this._tileKey&&(n=(0,Q.ib)(e,Math.abs(this._offset)+1),!n||!n.rings||0===n.rings.length))continue}else if((0,gt.l9)(e)&&this._tileKey&&(n=(0,Q.yn)(e,Math.abs(this._offset)+1),!n||!n.paths||0===n.paths.length))continue;return i.offset(Jt.Z.WebMercator,n,-this._offset,1,this._method,4,this._offsetFlattenError)}return null}}let y=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new k(i,n,P)}}return v.instance=null,v})();class k{constructor(e,i,n){this._inputGeometries=e,this._reverse=void 0===i.reverse||i.reverse}next(){let e=this._inputGeometries.next();for(;e;){if(!this._reverse)return e;if((0,gt.l9)(e)){const i=(0,Wt.d9)(e);return(0,Ft.ov)(i.paths),i}e=this._inputGeometries.next()}return null}}var W=at(65401),N=at(32442);let j=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new ct(i,n,P)}}return v.instance=null,v})();class ct{constructor(e,i,n){this._inputGeometries=e,this._rotateAngle=void 0!==i.angle?i.angle*Math.PI/180:0}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._rotateAngle)return e;const i=(0,W.Ue)();(0,N.$P)(i,e);const n=(i[2]+i[0])/2,P=(i[3]+i[1])/2;if((0,gt.YX)(e)){const u={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._rotateMultipath(u.rings,n,P),u}if((0,gt.oU)(e)){const u=(0,Wt.d9)(e);return this._rotateMultipath(u.rings,n,P),u}if((0,gt.l9)(e)){const u=(0,Wt.d9)(e);return this._rotateMultipath(u.paths,n,P),u}if((0,gt.aW)(e)){const u=(0,Wt.d9)(e);return this._rotatePath(u.points,n,P),u}if((0,gt.wp)(e))return e;e=this._inputGeometries.next()}return null}_rotateMultipath(e,i,n){if(e)for(const P of e)this._rotatePath(P,i,n)}_rotatePath(e,i,n){if(e){const P=Math.cos(this._rotateAngle),u=Math.sin(this._rotateAngle);for(const r of e){const M=r[0]-i,x=r[1]-n;r[0]=i+M*P-x*u,r[1]=n+M*u+x*P}}}}let Z=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new yt(i,n,P)}}return v.instance=null,v})();class yt{constructor(e,i,n){this._inputGeometries=e,this._xFactor=void 0!==i.xScaleFactor?i.xScaleFactor:1.15,this._yFactor=void 0!==i.yScaleFactor?i.yScaleFactor:1.15}next(){let e=this._inputGeometries.next();for(;e;){if(1===this._xFactor&&1===this._yFactor)return e;const i=(0,W.Ue)();(0,N.$P)(i,e);const n=(i[2]+i[0])/2,P=(i[3]+i[1])/2;if((0,gt.YX)(e)){const u={rings:[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]};return this._scaleMultipath(u.rings,n,P),u}if((0,gt.oU)(e)){const u=(0,Wt.d9)(e);return this._scaleMultipath(u.rings,n,P),u}if((0,gt.l9)(e)){const u=(0,Wt.d9)(e);return this._scaleMultipath(u.paths,n,P),u}if((0,gt.aW)(e)){const u=(0,Wt.d9)(e);return this._scalePath(u.points,n,P),u}if((0,gt.wp)(e))return e;e=this._inputGeometries.next()}return null}_scaleMultipath(e,i,n){if(e)for(const P of e)this._scalePath(P,i,n)}_scalePath(e,i,n){if(e)for(const P of e){const r=(P[1]-n)*this._yFactor;P[0]=i+(P[0]-i)*this._xFactor,P[1]=n+r}}}let Tt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new T(i,n,P)}}return v.instance=null,v})();class T{constructor(e,i,n){this._inputGeometries=e,this._height=(void 0!==i.amplitude?i.amplitude:2)*n,this._period=(void 0!==i.period?i.period:3)*n,this._style=i.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new qt,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new pt,this._walker.updateTolerance(n)}next(){let e=this._inputGeometries.next();for(;e;){if(0===this._height||0===this._period)return e;if((0,gt.l9)(e)){const i=this._processGeom(e.paths);if(i.length)return{paths:i}}if((0,gt.oU)(e)){const i=this._processGeom(e.rings);if(i.length)return{rings:i}}e=this._inputGeometries.next()}return null}_processGeom(e){const i=[];for(const n of e)if(this._walker.init(n,this._pattern))switch(this._style){case tt.zQ.Sinus:default:i.push(this._constructCurve(n,!1));break;case tt.zQ.Square:i.push(this._constructSquare(n));break;case tt.zQ.Triangle:i.push(this._constructTriangle(n));break;case tt.zQ.Random:i.push(this._constructCurve(n,!0))}else i.push(n);return i}_constructCurve(e,i){const n=new xt,P=this._walker.calculatePathLength(e);let u=Math.round(P/this._period);0===u&&(u=1);const x=this._period/16,w=1/(16*u+1),I=2*Math.PI*P/(P/u),E=2*Math.PI*Math.random(),q=2*Math.PI*Math.random(),K=2*Math.PI*Math.random(),lt=.75-Math.random()/2,_t=.75-Math.random()/2,kt=new Rt;this._walker.curPointAndAngle(kt),n.startPath(kt.pt);let Yt=0;for(;;){if(!this._walker.nextPointAndAngle(x,kt)){n.lineTo(e[e.length-1]);break}{const ne=Yt;let se;if(Yt+=w,i){const Bt=this._height/2*(1+.3*Math.sin(lt*I*ne+E));se=Bt*Math.sin(I*ne+q),se+=Bt*Math.sin(_t*I*ne+K),se/=2}else se=.5*this._height*Math.sin(.5*I*ne);n.lineTo([kt.pt[0]-se*kt.sa,kt.pt[1]+se*kt.ca])}}return n.path()}_constructSquare(e){const i=new xt,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let P=!0;for(;;){let u=!1;if(this._walker.curPositionIsValid()){const r=new Rt;this._walker.curPointAndAngle(r);const M=new Rt;if(this._walker.nextPointAndAngle(this._period,M)){const x=new Rt;this._walker.nextPointAndAngle(this._period,x)&&(P?(i.startPath(r.pt),P=!1):i.lineTo(r.pt),i.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),i.lineTo([M.pt[0]-this._height/2*M.sa,M.pt[1]+this._height/2*M.ca]),i.lineTo([M.pt[0]+this._height/2*M.sa,M.pt[1]-this._height/2*M.ca]),i.lineTo([x.pt[0]+this._height/2*x.sa,x.pt[1]-this._height/2*x.ca]),u=!0)}}if(!u){i.lineTo(this._walker.getPathEnd());break}}return i.path()}_constructTriangle(e){const i=new xt,n=this._walker.calculatePathLength(e);Math.round(n/this._period);let P=!0;for(;;){let u=!1;if(this._walker.curPositionIsValid()){const r=new Rt;this._walker.curPointAndAngle(r);const M=new Rt;if(this._walker.nextPointAndAngle(this._period/2,M)){const x=new Rt;this._walker.nextPointAndAngle(this._period,x)&&(this._walker.nextPosition(this._period/2)&&(P?(i.startPath(r.pt),P=!1):i.lineTo(r.pt),i.lineTo([M.pt[0]-this._height/2*M.sa,M.pt[1]+this._height/2*M.ca]),i.lineTo([x.pt[0]+this._height/2*x.sa,x.pt[1]-this._height/2*x.ca])),u=!0)}}if(!u){i.lineTo(this._walker.getPathEnd());break}}return i.path()}}let S=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new L(i,n,P)}}return v.instance=null,v})();class L extends Ft.v1{constructor(e,i,n){var P;super(e,!0,!0),this._geometryWalker=new pt,this._geometryWalker.updateTolerance(n),this._angleToLine=null==(P=i.angleToLine)||P,this._offset=(i.offset?i.offset:0)*n,this._originalEndings=i.endings,this._offsetAtEnd=(i.customEndingOffset?i.customEndingOffset:0)*n,this._position=-(i.offsetAlongLine?i.offsetAlongLine:0)*n,this._pattern=new qt,this._pattern.init(i.placementTemplate,!1),this._pattern.scale(n),this._endings=this._originalEndings}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath)i=this._pattern.nextValue();else{this._endings=this._originalEndings===tt.JS.WithFullGap&&this.isClosed?tt.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let P,u=!0;switch(this._endings){case tt.JS.NoConstraint:P=-this._position,P=this._adjustPosition(P),u=!1;break;case tt.JS.WithHalfGap:default:P=-this._pattern.lastValue()/2;break;case tt.JS.WithFullGap:P=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case tt.JS.WithMarkers:P=0;break;case tt.JS.Custom:P=-this._position,P=this._adjustPosition(P),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(e,this._pattern,u))return null;this._pattern.reset();let r=0;for(;P>r;)P-=r,r=this._pattern.nextValue();r-=P,i=r,this.iteratePath=!0}const n=new Rt;return this._geometryWalker.nextPointAndAngle(i,n)?this._endings===tt.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===tt.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(n.pt[0]-this._offset*n.sa,n.pt[1]+this._offset*n.ca),this._angleToLine&&this.internalPlacement.setRotateCS(n.ca,n.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(e){let i=e/this._pattern.length();return i-=Math.floor(i),i*this._pattern.length()}}let O=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new J(i,n,P)}}return v.instance=null,v})();class J extends Ft.v1{constructor(e,i,n){super(e,!1,!0),this._curveHelper=new At,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._type=i.extremityPlacement,this._position=void 0!==i.offsetAlongLine?i.offsetAlongLine*n:0,this._beginProcessed=!1}processPath(e){let i;switch(this._type){case tt.Tx.Both:default:this._beginProcessed?(i=this._atExtremities(e,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(i=this._atExtremities(e,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case tt.Tx.JustBegin:i=this._atExtremities(e,this._position,!0);break;case tt.Tx.JustEnd:i=this._atExtremities(e,this._position,!1);case tt.Tx.None:}return i}_atExtremities(e,i,n){const P=e.length;if(P<2)return null;const r=n?P:-1,M=n?1:-1;let x,w=0,I=n?e[0]:e[P-1];for(let E=n?1:P-2;E!==r;E+=M){x=I,I=e[E];const q=this._curveHelper.calculateLength(x,I);if(w+q>i){const K=(i-w)/q,[lt,_t]=this._curveHelper.getAngleCS(x,I,K),kt=(0,Ft.XV)(x,I,K);return this.internalPlacement.setTranslate(kt[0]-this._offset*_t,kt[1]+this._offset*lt),this._angleToLine&&this.internalPlacement.setRotateCS(-lt,-_t),this.internalPlacement}w+=q}return null}}let U=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new it(i,n,P)}}return v.instance=null,v})();class it extends Ft.v1{constructor(e,i,n){super(e,!0,!0),this._walker=new pt,this._walker.updateTolerance(n),this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._beginGap=void 0!==i.beginPosition?i.beginPosition*n:0,this._endGap=void 0!==i.endPosition?i.endPosition*n:0,this._flipFirst=void 0===i.flipFirst||i.flipFirst,this._pattern=new qt,this._pattern.init(i.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(e){if(this._pattern.isEmpty())return null;let i;if(this.iteratePath){const M=this._pattern.nextValue()*this._subPathLen,x=this._beginGap+M;i=x-this._prevPos,this._prevPos=x}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(e)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(e,this._pattern,!1))return null;this._pattern.reset();const M=this._pattern.nextValue()*this._subPathLen,x=this._beginGap+M;i=x-this._prevPos,this._prevPos=x,this.iteratePath=!0}const n=new Rt;if(!this._walker.nextPointAndAngle(i,n,ie.END))return this.iteratePath=!1,null;let u,r;return this.internalPlacement.setTranslate(n.pt[0]-this._offset*n.sa,n.pt[1]+this._offset*n.ca),this._angleToLine?(u=n.ca,r=n.sa):(u=1,r=0),this._isFirst&&this._flipFirst&&(u=-u,r=-r),this.internalPlacement.setRotateCS(u,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var ht=at(4619),Y=at(97373);const a=512,R=24;let nt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new rt(i,n,P,u,r)}}return v.instance=null,v})();class rt{constructor(e,i,n,P,u){var r,M,x,w,I,E,q,K,lt;if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(null!=(r=i.stepX)?r:16)*n,this._stepY=Math.abs(null!=(M=i.stepY)?M:16)*n,0!==this._stepX&&0!==this._stepY&&e&&function mt(v){return void 0!==v.rings}(e)&&e.rings){if(this._gridType=null!=(x=i.gridType)?x:tt.bj.Fixed,this._gridType===tt.bj.Random){const _t=null!=(w=i.seed)?w:13;this._randomLCG=new ht.Z(1*_t),this._randomness=(null!=(I=i.randomness)?I:100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues()}else{if(this._randomness=0,this._gridAngle=null!=(E=i.gridAngle)?E:0,this._shiftOddRows=null!=(q=i.shiftOddRows)&&q,this._offsetX=(null!=(K=i.offsetX)?K:0)*n,this._offsetY=(null!=(lt=i.offsetY)?lt:0)*n,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=P){const[_t,kt,Yt]=P.split("/"),ne=parseFloat(kt),se=parseFloat(Yt);this._graphicOriginX=-se*a,this._graphicOriginY=ne*a,this._testInsidePolygon=!0}this._internalPlacement=new Y.u,this._calculateMinMax(e),this._geometry=e}}next(){return this._geometry?this._nextInside():null}_buildRandomValues(){if(!rt._randValues){rt._randValues=[];for(let e=0;e<R;e++)for(let i=0;i<R;i++)rt._randValues.push(this._randomLCG.getFloat()),rt._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(e){let i,n,P,u,r,M,x,w,I,E,q,K,lt,_t;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,x=w=lt=q=Number.MAX_VALUE,I=E=_t=K=-Number.MAX_VALUE;const kt=1!==this._cosAngle;let Yt=0;for(const Bt of e.rings){const Ce=Bt?Bt.length:0;for(let ye=0;ye<Ce;ye++)M=Bt[ye][0],r=Bt[ye][1],i=M-this._graphicOriginX-this._offsetX,n=r-this._graphicOriginY-this._offsetY,kt?(P=this._cosAngle*i-this._sinAngle*n,u=this._sinAngle*i+this._cosAngle*n):(P=i,u=n),x=Math.min(x,P),I=Math.max(I,P),w=Math.min(w,u),E=Math.max(E,u),q=Math.min(q,r),K=Math.max(K,r),lt=Math.min(lt,M),_t=Math.max(_t,M),Yt++}q=q!==Number.MAX_VALUE?q:-a-this._stepY,K=K!==-Number.MAX_VALUE?K:this._stepY,lt=lt!==Number.MAX_VALUE?lt:-this._stepX,_t=_t!==-Number.MAX_VALUE?_t:a+this._stepX;const ne=K-q,se=_t-lt;if(this._verticalSubdivision=ne>=se,this._polygonMin=this._verticalSubdivision?q:lt,this._testInsidePolygon){let Bt=0-this._graphicOriginX-this._offsetX-this._stepX,Ce=a-this._graphicOriginX-this._offsetX+this._stepX,ye=-a-this._graphicOriginY-this._offsetY-this._stepY,Te=0-this._graphicOriginY-this._offsetY+this._stepY;if(kt){const je=[[Bt,ye],[Bt,Te],[Ce,ye],[Ce,Te]];Bt=ye=Number.MAX_VALUE,Ce=Te=-Number.MAX_VALUE;for(const Fe of je){const xe=this._cosAngle*Fe[0]-this._sinAngle*Fe[1],Ne=this._sinAngle*Fe[0]+this._cosAngle*Fe[1];Bt=Math.min(Bt,xe),Ce=Math.max(Ce,xe),ye=Math.min(ye,Ne),Te=Math.max(Te,Ne)}}x=x!==Number.MAX_VALUE?Math.max(x,Bt):Bt,w=w!==Number.MAX_VALUE?Math.max(w,ye):ye,I=I!==-Number.MAX_VALUE?Math.min(I,Ce):Ce,E=E!==-Number.MAX_VALUE?Math.min(E,Te):Te}this._xMin=Math.round(x/this._stepX),this._xMax=Math.round(I/this._stepX),this._yMin=Math.round(w/this._stepY),this._yMax=Math.round(E/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._testInsidePolygon&&Yt>12&&(ne>25||se>25)&&this._buildAccelerationMap(e,lt,_t,q,K)}_buildAccelerationMap(e,i,n,P,u){const{rings:r}=e,M=new Map,x=this._verticalSubdivision,w=x?u-P:n-i;let I=Math.ceil(w/10);if(I<=1)return;const E=Math.floor(w/I);let q,K,lt,_t,kt,Yt,ne,se,Bt,Ce;I++,this._delta=E,x?(se=-a-this._stepY,Bt=this._stepY,Ce=P):(se=-this._stepX,Bt=a+this._stepX,Ce=i);for(let ye=0;ye<r.length;ye++)if(q=r[ye],!(q.length<2))for(let Te=1;Te<q.length;Te++){if(K=q[Te-1],lt=q[Te],x){if(K[1]===lt[1]||K[1]<se&&lt[1]<se||K[1]>Bt&&lt[1]>Bt)continue;_t=Math.min(K[1],lt[1]),kt=Math.max(K[1],lt[1])}else{if(K[0]===lt[0]||K[0]<se&&lt[0]<se||K[0]>Bt&&lt[0]>Bt)continue;_t=Math.min(K[0],lt[0]),kt=Math.max(K[0],lt[0])}for(;_t<kt;)Yt=Math.floor((_t-Ce)/E),bt(Yt,ye,Te,M),_t+=E;ne=Math.floor((kt-Ce)/E),ne>Yt&&bt(ne,ye,Te,M)}this._accelerationMap=M}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let e=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(e+=.5*this._stepX);const i=this._currentY*this._stepY+this._offsetY;let n,P;if(this._currentX++,this._gridType===tt.bj.Random){const u=(this._currentX%R+R)%R,r=(this._currentY%R+R)%R;n=this._graphicOriginX+e+this._stepX*this._randomness*(.5-rt._randValues[r*R+u])*2/3,P=this._graphicOriginY+i+this._stepY*this._randomness*(.5-rt._randValues[r*R+u+1])*2/3}else n=this._graphicOriginX+this._cosAngle*e+this._sinAngle*i,P=this._graphicOriginY-this._sinAngle*e+this._cosAngle*i;if(!this._testInsidePolygon||this._isInsidePolygon(n,P,this._geometry))return this._internalPlacement.setTranslate(n,P),this._internalPlacement}}_isInsidePolygon(e,i,n){const{rings:P}=n;if((0,Et.Wi)(this._accelerationMap))return function et(v,e,i){const{rings:n}=i;let P,u,r,M=0;for(const x of n){P=x.length;for(let w=1;w<P;++w)u=x[w-1],r=x[w],u[1]>e!=r[1]>e&&((r[0]-u[0])*(e-u[1])-(r[1]-u[1])*(v-u[0])>0?M++:M--)}return 0!==M}(e,i,n);const u=this._verticalSubdivision,M=Math.floor(((u?i:e)-this._polygonMin)/this._delta),x=this._accelerationMap.get(M);if(!x)return!1;let w,I,E,q,K,lt=0;for(const _t of x){K=_t[0];const kt=P[K];if(q=_t[1],w=kt[q-1],I=kt[q],u){if(w[1]>i==I[1]>i)continue;E=(I[0]-w[0])*(i-w[1])-(I[1]-w[1])*(e-w[0])}else{if(w[0]>e==I[0]>e)continue;E=(I[1]-w[1])*(e-w[0])-(I[0]-w[0])*(i-w[1])}E>0?lt++:lt--}return 0!==lt}}function bt(v,e,i,n){let P=n.get(v);P||(P=[],n.set(v,P)),P.push([e,i])}let Xt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new jt(i,n,P)}}return v.instance=null,v})();class jt extends Ft.v1{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new At,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._relativeTo=i.relativeTo,this._position=void 0!==i.startPointOffset?i.startPointOffset*n:0,this._epsilon=.001*n}processPath(e){const i=this._position;if(this._relativeTo===tt.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=e.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const P=this._curSegment;this._curSegment++;const u=e[P-1],r=e[P],M=this._curveHelper.calculateLength(u,r);if(M<this._epsilon)continue;const x=.5+this._position/M,[w,I]=this._curveHelper.getAngleCS(u,r,x),E=(0,Ft.XV)(u,r,x);return this.internalPlacement.setTranslate(E[0]-this._offset*I,E[1]+this._offset*w),this._angleToLine&&this.internalPlacement.setRotateCS(w,I),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===tt.CS.LineEnd&&(0,Ft.hh)(e);const n=this.onLine(e,i);return this._relativeTo===tt.CS.LineEnd&&(0,Ft.hh)(e),n}onLine(e,i){let n,P=!1;switch(this._relativeTo){case tt.CS.LineMiddle:default:n=this._curveHelper.calculatePathLength(e)/2+i;break;case tt.CS.LineBeginning:n=i;break;case tt.CS.LineEnd:n=i,P=!0}const u=e.length;let r,M=0,x=e[0];for(let w=1;w<u;++w){r=x,x=e[w];const I=this._curveHelper.calculateLength(r,x);if(M+I>n){const E=(n-M)/I,[q,K]=this._curveHelper.getAngleCS(r,x,E),lt=(0,Ft.XV)(r,x,E),_t=P?-this._offset:this._offset;return this.internalPlacement.setTranslate(lt[0]-_t*K,lt[1]+_t*q),this._angleToLine&&(P?this.internalPlacement.setRotateCS(-q,-K):this.internalPlacement.setRotateCS(q,K)),this.internalPlacement}M+=I}return null}}let vt=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new Zt(i,n,P)}}return v.instance=null,v})();class Zt extends Ft.v1{constructor(e,i,n){super(e,!0,!0),this._curveHelper=new At,this._angleToLine=void 0===i.angleToLine||i.angleToLine,this._offset=void 0!==i.offset?i.offset*n:0,this._endPoints=void 0===i.placeOnEndPoints||i.placeOnEndPoints,this._controlPoints=void 0===i.placeOnControlPoints||i.placeOnControlPoints,this._regularVertices=void 0===i.placeOnRegularVertices||i.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(e){if(this.iteratePath||(this._preparePath(e),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const i=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(i[2]);let n=i[0],P=i[1];if(0!==this._offset){const u=Math.cos(i[2]),r=Math.sin(i[2]);n-=this._offset*r,P+=this._offset*u}return this.internalPlacement.setTranslate(n,P),this._tagIterator++,this.internalPlacement}_preparePath(e){this._tags.length=0,this._tagIterator=0;const i=(0,Ft.QK)(e),n=e.length-1;let P,u,r=0,M=0,x=0,w=0,I=0;for(;r<n;){r++,P=e[r-1],u=e[r];const E=(0,Ft.zv)(P),q=(0,Ft.zv)(u);(this._angleToLine||0!==this._offset)&&(w=this._curveHelper.getAngle(P,u,0)),1===r?i?(M=w,x=E):(this._endPoints||this._controlPoints&&1===E)&&this._tags.push([P[0],P[1],w]):1===E?this._controlPoints&&this._tags.push([P[0],P[1],le(I,w)]):this._regularVertices&&this._tags.push([P[0],P[1],le(I,w)]),(this._angleToLine||0!==this._offset)&&(I=this._curveHelper.getAngle(P,u,1)),r===n&&(i?1===q||1===x?this._controlPoints&&this._tags.push([u[0],u[1],le(I,M)]):this._regularVertices&&this._tags.push([u[0],u[1],le(I,M)]):(this._endPoints||this._controlPoints&&1===q)&&this._tags.push([u[0],u[1],I]))}this._tagIterator=0}}function le(v,e){const i=Math.PI;for(;Math.abs(e-v)>i+2e-15;)e-v>i?e-=2*i:e+=2*i;return(v+e)/2}var ee=at(8314),Qt=at(27105);class Me{constructor(e=pe){this._data=[],this._compare=e}get size(){return this._data.length}enqueue(e){if(null==e)return;const{_data:i,_compare:n}=this;i.push(e);let P=i.length-1>>>0;const u=i[P];for(;P>0;){const r=P-1>>1,M=i[r];if(!(n(M,u)<=0))break;i[r]=u,i[P]=M,P=r}}dequeue(){const{_data:e,_compare:i}=this,n=e[0],P=e.pop();if(0===e.length)return n;e[0]=P;let u=0;const r=e.length,M=e[0];let x,w,I=null;for(;;){const E=2*u+1,q=2*u+2;if(I=null,E<r&&(x=e[E],i(x,M)>0&&(I=E)),q<r&&(w=e[q],(null===I&&i(w,M)<=0||null!==I&&i(w,x)<=0)&&(I=q)),null===I)break;e[u]=e[I],e[I]=M,u=I}return n}}const pe=(v,e)=>v<e?-1:v>e?1:0;var me=at(25748),we=at(11519);function Se(v,e){const{rings:i}=e;let n=0;for(const P of i){const u=P.length;for(let r=1;r<u;++r){const M=P[r-1],x=P[r];M[1]>v[1]!=x[1]>v[1]&&((x[0]-M[0])*(v[1]-M[1])-(x[1]-M[1])*(v[0]-M[0])>0?n++:n--)}}return 0!==n}function _e(v,e,i){if(i&&Se(v,e))return{coord:v,distance:0};let n=1/0,P=0,u=0;const r=[0,0],{rings:M}=e;for(const x of M)if(!(x.length<2))for(let w=0;w<x.length-1;w++){(0,me.Tx)(r,v,x,w);const I=be(v,r);I<n&&(n=I,P=r[0],u=r[1])}return{coord:[P,u],distance:Math.sqrt(n)}}function ge(v,e,i,n){const P=[e,0];let u=1/0,r=1/0,M=!1,x=!1;const w=[[e,n[1]-1],[e,n[3]+1]],I=[0,0],E=[0,0],q=[0,0],K=[[0,0],[0,0]],lt=(0,W.Ue)(),{rings:_t}=v;for(const kt of _t)if(!(kt.length<2))for(let Yt=1;Yt<kt.length;Yt++){if(K[0][0]=kt[Yt-1][0],K[0][1]=kt[Yt-1][1],K[1][0]=kt[Yt][0],K[1][1]=kt[Yt][1],null===ke(lt,K)||(E[0]=w[0][0],E[1]=w[0][1],q[0]=w[1][0],q[1]=w[1][1],0===Ge(lt,E,q))||!(0,we.UT)(w[0],w[1],K[0],K[1],I))continue;const ne=I[1];u>r?ne<u&&(u=ne,M=!0):ne<r&&(r=ne,x=!0)}return M&&x?P[1]=(u+r)/2:P[0]=P[1]=NaN,P}function ke(v,e){if(e.length<2)return null;v||(v=(0,W.Ue)());const[i,n]=e[0],[P,u]=e[1];return v[0]=Math.min(i,P),v[1]=Math.min(n,u),v[2]=Math.max(i,P),v[3]=Math.max(n,u),v}function Ge(v,e,i){let n=Ie(e,v),P=Ie(i,v);const u=v[0],r=v[1],M=v[2],x=v[3];if(n&P)return 0;if(!(n|P))return 4;const w=(n?1:0)|(P?2:0);do{const I=i[0]-e[0],E=i[1]-e[1];if(I>E)3&n?(1&n?(e[1]+=E*(u-e[0])/I,e[0]=u):(e[1]+=E*(M-e[0])/I,e[0]=M),n=Ie(e,v)):3&P?(1&P?(i[1]+=E*(u-i[0])/I,i[0]=u):(i[1]+=E*(M-i[0])/I,i[0]=M),P=Ie(i,v)):n?(4&n?(e[0]+=I*(r-e[1])/E,e[1]=r):(e[0]+=I*(x-e[1])/E,e[1]=x),n=Ie(e,v)):(4&P?(i[0]+=I*(r-i[1])/E,i[1]=r):(i[0]+=I*(x-i[1])/E,i[1]=x),P=Ie(i,v));else if(12&n?(4&n?(e[0]+=I*(r-e[1])/E,e[1]=r):(e[0]+=I*(x-e[1])/E,e[1]=x),n=Ie(e,v)):12&P?(4&P?(i[0]+=I*(r-i[1])/E,i[1]=r):(i[0]+=I*(x-i[1])/E,i[1]=x),P=Ie(i,v)):n?(1&n?(e[1]+=E*(u-e[0])/I,e[0]=u):(e[1]+=E*(M-e[0])/I,e[0]=M),n=Ie(e,v)):(1&P?(i[1]+=E*(u-i[0])/I,i[0]=u):(i[1]+=E*(M-i[0])/I,i[0]=M),P=Ie(i,v)),n&P)return 0}while(n|P);return w}function Ie(v,e){return(v[0]<e[0]?1:0)|(v[0]>e[2]?1:0)<<1|(v[1]<e[1]?1:0)<<2|(v[1]>e[3]?1:0)<<3}function Re(v,e,i){return v+(e-v)*i}function be(v,e){return(v[0]-e[0])*(v[0]-e[0])+(v[1]-e[1])*(v[1]-e[1])}function He(v,e){if(v<e)return-1;if(v>e)return 1;if(v===e)return 0;const i=isNaN(v),n=isNaN(e);return i<n?-1:i>n?1:0}class ze{constructor(e,i,n,P){this.x=e,this.y=i,this.cellSize=n,this.distancefromCellCenter=(0,me.ko)(e,i,P),this.maxDistanceToPolygon=this.distancefromCellCenter+this.cellSize*Math.SQRT2}}let Be=(()=>{class v{static local(){return null===v.instance&&(v.instance=new v),v.instance}execute(i,n,P,u,r){return new Ae(i,n,P)}}return v.instance=null,v})();class Ae{constructor(e,i,n){this._geometry=e,this._offsetX=void 0!==i.offsetX?i.offsetX*n:0,this._offsetY=void 0!==i.offsetY?i.offsetY*n:0,this._method=void 0!==i.method?i.method:tt.Lh.OnPolygon,this._internalPlacement=new Y.u}next(){const e=this._geometry;return this._geometry=null,e&&function Ue(v){return void 0!==v.rings}(e)?this._polygonCenter(e):null}_polygonCenter(e){let i=!1;switch(this._method){case tt.Lh.CenterOfMass:{const n=(0,Qt.NA)(e);n&&(this._internalPlacement.setTranslate(n[0]+this._offsetX,n[1]+this._offsetY),i=!0)}break;case tt.Lh.BoundingBoxCenter:{const n=(0,W.Ue)();(0,N.$P)(n,e),n&&(this._internalPlacement.setTranslate((n[2]+n[0])/2+this._offsetX,(n[3]+n[1])/2+this._offsetY),i=!0)}break;default:{let n;n=(0,ee.Z)("polylabel-placement-enabled")?function Ye(v){if(!v||!v.rings||0===v.rings.length)return null;const e=(0,N.lC)((0,W.Ue)(),v.rings[0]);if(!e)return null;const i=e[2]-e[0],n=e[3]-e[1];if(0===i||0===n)return[e[0]+i/2,e[1]+n/2];const P=Math.max(Math.min(i,n)/100,1),u=new Me((K,lt)=>lt.maxDistanceToPolygon-K.maxDistanceToPolygon),r=Math.min(i,n);let M=r/2,x=0,w=0;for(x=e[0];x<e[2];x+=r)for(w=e[1];w<e[3];w+=r)u.enqueue(new ze(x+M,w+M,M,v));const I=(0,Qt.a)(v.rings,!1);if(null===I)return null;let E,q=new ze(I[0],I[1],0,v);for(;u.size>0;)E=(0,Et.Wg)(u.dequeue()),E.distancefromCellCenter>q.distancefromCellCenter&&(q=E),E.maxDistanceToPolygon-q.distancefromCellCenter<=P||(M=E.cellSize/2,u.enqueue(new ze(E.x-M,E.y-M,M,v)),u.enqueue(new ze(E.x+M,E.y-M,M,v)),u.enqueue(new ze(E.x-M,E.y+M,M,v)),u.enqueue(new ze(E.x+M,E.y+M,M,v)));return[q.x,q.y]}(e):function ve(v){const{rings:e}=v;if(!e||0===e.length)return null;const i=(0,N.$P)((0,W.Ue)(),v);if(!i)return null;const n=4*(Math.abs(i[0])+Math.abs(i[2])+Math.abs(i[1])+Math.abs(i[3])+1)*222045e-19;let P=0,u=0;for(let xe=0;xe<e.length;xe++){const Ne=(0,me.Sm)(e[xe]);Ne>u&&(u=Ne,P=xe)}if(Math.abs(u)<=2*n*n){const xe=(0,N.lC)((0,W.Ue)(),e[P]);return[(xe[0]+xe[2])/2,(xe[1]+xe[3])/2]}const r=(0,Qt.DS)(e[P],!1,(0,W.Ue)());if(null===r)return null;if(1===e.length&&e[0].length<4)return r;const M=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],x=[NaN,NaN,NaN,NaN],w=[NaN,NaN,NaN,NaN];let I=!1,E=_e(r,v,!0);0===E.distance&&(I=!0,M[0][0]=r[0],M[0][1]=r[1],E=_e(r,v,!1)),x[0]=E.distance,w[0]=0;const q=[NaN,NaN];let K=!1,lt=.25,_t=-1;const kt=(0,N.lC)((0,W.Ue)(),e[P]);let Yt=NaN;do{if(Yt=NaN,M[1]=ge(v,Re(kt[0],kt[2],lt),0,i),isNaN(M[1][0])||isNaN(M[1][1])||(E=_e(M[1],v,!1),Yt=E.distance),!isNaN(Yt)&&Yt>n&&Se(M[1],v))K=!0,x[1]=Yt,w[1]=be(M[1],r);else if(!isNaN(Yt)&&Yt>_t&&(_t=Yt,q[0]=M[1][0],q[1]=M[1][1]),lt-=.01,lt<.1){if(!(_t>=0))break;K=!0,x[1]=_t,M[1][0]=q[0],M[1][1]=q[1],w[1]=be(M[1],r)}}while(!K);K=!1,lt=.5,_t=-1;let ne=.01,se=1;do{if(Yt=NaN,M[2]=ge(v,Re(kt[0],kt[2],lt),0,i),isNaN(M[2][0])||isNaN(M[2][1])||(E=_e(M[2],v,!1),Yt=E.distance),!isNaN(Yt)&&Yt>n&&Se(M[2],v))K=!0,x[2]=Yt,w[2]=be(M[2],r);else if(!isNaN(Yt)&&Yt>_t)_t=Yt,q[0]=M[2][0],q[1]=M[2][1];else if(Yt>_t&&(_t=Yt,q[0]=M[2][0],q[1]=M[2][1]),lt=.5+ne*se,ne+=.01,se*=-1,lt<.3||lt>.7){if(!(_t>=0))break;K=!0,x[2]=_t,M[2][0]=q[0],M[2][1]=q[1],w[2]=be(M[2],r)}}while(!K);K=!1,lt=.75,_t=-1;do{if(Yt=NaN,M[3]=ge(v,Re(kt[0],kt[2],lt),0,i),isNaN(M[3][0])||isNaN(M[3][1])||(E=_e(M[3],v,!1),Yt=E.distance),!isNaN(Yt)&&Yt>n&&Se(M[3],v))K=!0,x[3]=Yt,w[3]=be(M[3],r);else if(Yt>_t&&(_t=Yt,q[0]=M[3][0],q[1]=M[3][1]),lt+=.01,lt>.9){if(!(_t>=0))break;K=!0,x[3]=_t,M[3][0]=q[0],M[3][1]=q[1],w[3]=be(M[3],r)}}while(!K);const Bt=[0,1,2,3],Ce=I?0:1;let ye;for(let xe=Ce;xe<4;xe++)for(let Ne=Ce;Ne<3;Ne++){const $e=w[Ne],Ke=w[Ne+1];He($e,Ke)>0&&(ye=Bt[Ne],Bt[Ne]=Bt[Ne+1],Bt[Ne+1]=ye,w[Ne]=Ke,w[Ne+1]=$e)}let Te=Ce,je=0,Fe=0;for(let xe=Ce;xe<4;xe++){switch(xe){case 0:Fe=2*x[Bt[xe]];break;case 1:Fe=1.66666666*x[Bt[xe]];break;case 2:Fe=1.33333333*x[Bt[xe]];break;case 3:Fe=x[Bt[xe]]}Fe>je&&(je=Fe,Te=Bt[xe])}return M[Te]}(e),null!==n&&(this._internalPlacement.setTranslate(n[0]+this._offsetX,n[1]+this._offsetY),i=!0)}}return i?this._internalPlacement:null}}function qe(v){if(!v)return null;switch(v.type){case"CIMGeometricEffectAddControlPoints":return zt.local();case"CIMGeometricEffectArrow":return $t.local();case"CIMGeometricEffectBuffer":return Vt.local();case"CIMGeometricEffectControlMeasureLine":return oe.local();case"CIMGeometricEffectCut":return ot.local();case"CIMGeometricEffectDashes":return Mt.local();case"CIMGeometricEffectDonut":return Pt.local();case"CIMGeometricEffectJog":return Dt.local();case"CIMGeometricEffectMove":return Kt.local();case"CIMGeometricEffectOffset":return fe.local();case"CIMGeometricEffectReverse":return y.local();case"CIMGeometricEffectRotate":return j.local();case"CIMGeometricEffectScale":return Z.local();case"CIMGeometricEffectWave":return Tt.local()}return null}function ts(v){if(!v)return null;switch(v.type){case"CIMMarkerPlacementAlongLineSameSize":return S.local();case"CIMMarkerPlacementAtExtremities":return O.local();case"CIMMarkerPlacementAtRatioPositions":return U.local();case"CIMMarkerPlacementInsidePolygon":return nt.local();case"CIMMarkerPlacementOnLine":return Xt.local();case"CIMMarkerPlacementOnVertices":return vt.local();case"CIMMarkerPlacementPolygonCenter":return Be.local()}return null}},97373:(Pe,re,at)=>{at.d(re,{u:()=>Wt});class Wt{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rzCos&&0!==this.rzSin)&&(this.rz=Math.atan2(this.rzSin,this.rzCos)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rzCos=1,this.rzSin=0}setTranslate(zt,he){this.tx=zt,this.ty=he}setTranslateZ(zt){this.tz=zt}setRotateCS(zt,he){this.rz=void 0,this.rzCos=zt,this.rzSin=he}setRotate(zt){this.rz=zt,this.rzCos=void 0,this.rzSin=void 0}setRotateY(zt){this.ry=zt}setScale(zt){this.s=zt}setMeasure(zt){this.m=zt}}},26933:(Pe,re,at)=>{at.d(re,{cD:()=>Mt,uQ:()=>Ot,zA:()=>Rt}),at(986);var gt=at(17002),Ft=at(58817),zt=at(63290),he=at(62208),tt=at(27899),Nt=at(23841),xt=at(65401),At=at(32442),dt=at(27105),Ct=at(91179),Ut=at(29214);class $t{applyColorSubstituition(y,k){if(!k)return y;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:W,height:N}=y,j=this._rasterizationCanvas,ct=j.getContext("2d");y!==j&&(j.width=W,j.height=N,ct.drawImage(y,0,0,W,N));const Z=ct.getImageData(0,0,W,N).data;if(k)for(const Tt of k)if(Tt&&Tt.oldColor&&4===Tt.oldColor.length&&Tt.newColor&&4===Tt.newColor.length){const[T,S,L,O]=Tt.oldColor,[J,U,it,ht]=Tt.newColor;if(T===J&&S===U&&L===it&&O===ht)continue;for(let Y=0;Y<Z.length;Y+=4)T===Z[Y]&&S===Z[Y+1]&&L===Z[Y+2]&&O===Z[Y+3]&&(Z[Y]=J,Z[Y+1]=U,Z[Y+2]=it,Z[Y+3]=ht)}const yt=new ImageData(Z,W,N);return ct.putImageData(yt,0,0),j}tintImageData(y,k){if(!k||k.length<4)return y;this._rasterizationCanvas||(this._rasterizationCanvas=document.createElement("canvas"));const{width:W,height:N}=y,j=this._rasterizationCanvas,ct=j.getContext("2d");y!==j&&(j.width=W,j.height=N,ct.drawImage(y,0,0,W,N));const Z=ct.getImageData(0,0,W,N),yt=new Uint8Array(Z.data),Tt=[k[0]/255,k[1]/255,k[2]/255,k[3]/255];for(let S=0;S<yt.length;S+=4)yt[S+0]*=Tt[0],yt[S+1]*=Tt[1],yt[S+2]*=Tt[2],yt[S+3]*=Tt[3];const T=new ImageData(new Uint8ClampedArray(yt.buffer),W,N);return ct.putImageData(T,0,0),j}}var st=at(95727),ft=at(97373),Et=at(7547);function Q(It){const y=It.getFrame(0);if(y instanceof HTMLImageElement||y instanceof HTMLCanvasElement)return y;const k=document.createElement("canvas");k.width=It.width,k.height=It.height;const W=k.getContext("2d");return y instanceof ImageData?W.putImageData(y,0,0):W.drawImage(y,0,0),k}var Jt=at(31375),Vt=at(68937),Ht=at(80991);at(40028),at(39351),at(25797);const St=Math.PI/180,qt=zt.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class Rt{constructor(y){this._t=y}static createIdentity(){return new Rt([1,0,0,0,1,0])}clone(){return new Rt(this._t.slice())}transform(y){const k=this._t;return[k[0]*y[0]+k[1]*y[1]+k[2],k[3]*y[0]+k[4]*y[1]+k[5]]}static createScale(y,k){return new Rt([y,0,0,0,k,0])}scale(y,k){const W=this._t;return W[0]*=y,W[1]*=y,W[2]*=y,W[3]*=k,W[4]*=k,W[5]*=k,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(y,k){return new Rt([0,0,y,0,0,k])}translate(y,k){const W=this._t;return W[2]+=y,W[5]+=k,this}static createRotate(y){const k=Math.cos(y),W=Math.sin(y);return new Rt([k,-W,0,W,k,0])}rotate(y){return Rt.multiply(this,Rt.createRotate(y),this)}angle(){const y=this._t[0],k=this._t[3],W=Math.sqrt(y*y+k*k);return[y/W,k/W]}static multiply(y,k,W){const N=y._t,j=k._t,Z=N[1]*j[0]+N[4]*j[1],yt=N[2]*j[0]+N[5]*j[1]+j[2],Tt=N[0]*j[3]+N[3]*j[4],T=N[1]*j[3]+N[4]*j[4],S=N[2]*j[3]+N[5]*j[4]+j[5],L=W._t;return L[0]=N[0]*j[0]+N[3]*j[1],L[1]=Z,L[2]=yt,L[3]=Tt,L[4]=T,L[5]=S,W}invert(){const y=this._t;let k=y[0]*y[4]-y[1]*y[3];return 0===k?new Rt([0,0,0,0,0,0]):(k=1/k,new Rt([y[4]*k,-y[1]*k,(y[1]*y[5]-y[2]*y[4])*k,-y[3]*k,y[0]*k,(y[2]*y[3]-y[0]*y[5])*k]))}}class ie{constructor(y,k){this._resourceManager=y,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new tt.Z(ft.u,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(k||Rt.createIdentity()),this._sizeTransfos.push(k?k.scaleRatio():1)}setTransform(y,k){this._transfos=[y||Rt.createIdentity()],this._sizeTransfos=[k||(y?y.scaleRatio():1)]}setGeomUnitsPerPoint(y){this._geomUnitsPerPoint=y}transformPt(y){return this._transfos[this._transfos.length-1].transform(y)}transformSize(y){return y*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(y){return this._transfos[this._transfos.length-1].invert().transform(y)}reverseTransformSize(y){return y/this._sizeTransfos[this._sizeTransfos.length-1]}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(y,k){const W=k?y.scaleRatio():1;Rt.multiply(y,this.back(),y),this._transfos.push(y),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*W)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(y,k,W){if(y)switch(y.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(y,k);break;case"CIMTextSymbol":this.drawTextSymbol(y,k,W)}}drawMultiLayerSymbol(y,k){if(!y||!k)return;const W=y.symbolLayers;if(!W)return;const N=y.effects;if(N&&N.length>0){const j=this.executeEffects(N,k);if(j){let ct=j.next();for(;ct;)this.drawSymbolLayers(W,ct),ct=j.next()}}else this.drawSymbolLayers(W,k)}executeEffects(y,k){const W=this._resourceManager.geometryEngine;let N=new Ut.MU(k);for(const j of y){const ct=(0,st.h)(j);ct&&(N=ct.execute(N,j,this.geomUnitsPerPoint(),null,W))}return N}drawSymbolLayers(y,k){let W=y.length;for(;W--;){const N=y[W];if(!N||!1===N.enable)continue;const j=N.effects;if(j&&j.length>0){const ct=this.executeEffects(j,k);if(ct){let Z=null;for(;(Z=ct.next())&&(this.drawSymbolLayer(N,Z),!this._earlyReturn););}}else this.drawSymbolLayer(N,k);if(this._earlyReturn)return}}drawSymbolLayer(y,k){switch(y.type){case"CIMSolidFill":this.drawSolidFill(k,y.color);break;case"CIMHatchFill":this.drawHatchFill(k,y);break;case"CIMPictureFill":this.drawPictureFill(k,y);break;case"CIMGradientFill":this.drawGradientFill(k,y);break;case"CIMSolidStroke":this.drawSolidStroke(k,y.color,y.width,y.capStyle,y.joinStyle,y.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(k,y);break;case"CIMGradientStroke":this.drawGradientStroke(k,y);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(y,k)}}drawHatchFill(y,k){const W=this._buildHatchPolyline(k,y,this.geomUnitsPerPoint());W&&(this.pushClipPath(y),this.drawMultiLayerSymbol(k.lineSymbol,W),this.popClipPath())}drawPictureFill(y,k){}drawGradientFill(y,k){}drawPictureStroke(y,k){}drawGradientStroke(y,k){}drawMarkerLayer(y,k){const W=y.markerPlacement;if(W){const N=(0,st.W)(W);if(N){const j="CIMMarkerPlacementInsidePolygon"===W.type||"CIMMarkerPlacementPolygonCenter"===W.type&&W.clipAtBoundary;j&&this.pushClipPath(k);const ct=N.execute(k,W,this.geomUnitsPerPoint(),null,this._resourceManager.geometryEngine);if(ct){let Z=null;for(;(Z=ct.next())&&(this.drawMarker(y,Z),!this._earlyReturn););}j&&this.popClipPath()}}else{const N=this._placementPool.acquire();if((0,Ct.wp)(k))N.tx=k.x,N.ty=k.y,this.drawMarker(y,N);else if((0,Ct.oU)(k)){const j=(0,dt.tO)(k);j&&([N.tx,N.ty]=j,this.drawMarker(y,N))}else for(const j of k.points)if(N.tx=j[0],N.ty=j[1],this.drawMarker(y,N),this._earlyReturn)break;this._placementPool.release(N)}}drawMarker(y,k){switch(y.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(y,k);break;case"CIMVectorMarker":this.drawVectorMarker(y,k)}}drawPictureMarker(y,k){var it,ht,Y,a,A;if(!y)return;const W=this._resourceManager.getResource(y.url),N=null!=(it=y.size)?it:10;if((0,he.Wi)(W)||N<=0)return;const j=W.width,ct=W.height;if(!j||!ct)return;const Z=j/ct,yt=null!=(ht=y.scaleX)?ht:1,Tt=Rt.createIdentity(),T=y.anchorPoint;if(T){let F=T.x,$=T.y;"Absolute"!==y.anchorPointUnits&&(F*=N*Z*yt,$*=N),Tt.translate(-F,-$)}let S=null!=(Y=y.rotation)?Y:0;y.rotateClockwise&&(S=-S),this._mapRotation&&(S+=this._mapRotation),S&&Tt.rotate(S*St);let L=null!=(a=y.offsetX)?a:0,O=null!=(A=y.offsetY)?A:0;if(L||O){if(this._mapRotation){const F=St*this._mapRotation,$=Math.cos(F),R=Math.sin(F),mt=L*R+O*$;L=L*$-O*R,O=mt}Tt.translate(L,O)}const J=this.geomUnitsPerPoint();1!==J&&Tt.scale(J,J);const U=k.getAngle();U&&Tt.rotate(U),Tt.translate(k.tx,k.ty),this.push(Tt,!1),this.drawImage(y,N),this.pop()}drawVectorMarker(y,k){var U,it,ht,Y;if(!y)return;const W=y.markerGraphics;if(!W)return;const N=null!=(U=y.size)?U:10,j=y.frame,ct=j?j.ymax-j.ymin:0,Z=N&&ct?N/ct:1,yt=Rt.createIdentity();j&&yt.translate(.5*-(j.xmax+j.xmin),.5*-(j.ymax+j.ymin));const Tt=y.anchorPoint;if(Tt){let a=Tt.x,A=Tt.y;"Absolute"!==y.anchorPointUnits?j&&(a*=j.xmax-j.xmin,A*=j.ymax-j.ymin):(a/=Z,A/=Z),yt.translate(-a,-A)}1!==Z&&yt.scale(Z,Z);let T=null!=(it=y.rotation)?it:0;y.rotateClockwise&&(T=-T),this._mapRotation&&(T+=this._mapRotation),T&&yt.rotate(T*St);let S=null!=(ht=y.offsetX)?ht:0,L=null!=(Y=y.offsetY)?Y:0;if(S||L){if(this._mapRotation){const a=St*this._mapRotation,A=Math.cos(a),F=Math.sin(a),$=S*F+L*A;S=S*A-L*F,L=$}yt.translate(S,L)}const O=this.geomUnitsPerPoint();1!==O&&yt.scale(O,O);const J=k.getAngle();J&&yt.rotate(J),yt.translate(k.tx,k.ty),this.push(yt,y.scaleSymbolsProportionally);for(const a of W)if(a&&a.symbol&&a.geometry||qt.error("Invalid marker graphic",a),this.drawSymbol(a.symbol,a.geometry,a.textString),this._earlyReturn)break;this.pop()}drawTextSymbol(y,k,W){var Tt,T,S,L;if(!y||!(0,Ct.wp)(k)||(null!=(Tt=y.height)?Tt:10)<=0)return;const N=Rt.createIdentity();let j=null!=(T=y.angle)?T:0;j=-j,j&&N.rotate(j*St);const ct=null!=(S=y.offsetX)?S:0,Z=null!=(L=y.offsetY)?L:0;(ct||Z)&&N.translate(ct,Z);const yt=this.geomUnitsPerPoint();1!==yt&&N.scale(yt,yt),N.translate(k.x,k.y),this.push(N,!1),this.drawText(y,W),this.pop()}_buildHatchPolyline(y,k,W){let N=(void 0!==y.separation?y.separation:4)*W,j=void 0!==y.rotation?y.rotation:0;if(0===N)return null;N<0&&(N=-N);let ct=0;const Z=.5*N;for(;ct>Z;)ct-=N;for(;ct<-Z;)ct+=N;const yt=(0,xt.Ue)();(0,At.$P)(yt,k),yt[0]-=Z,yt[1]-=Z,yt[2]+=Z,yt[3]+=Z;const Tt=[[yt[0],yt[1]],[yt[0],yt[3]],[yt[2],yt[3]],[yt[2],yt[1]]];for(;j>180;)j-=180;for(;j<0;)j+=180;const T=Math.cos(j*St),S=Math.sin(j*St),L=-N*S,O=N*T;let J,U,it,ht;ct=(void 0!==y.offsetX?y.offsetX*W:0)*S-(void 0!==y.offsetY?y.offsetY*W:0)*T,J=it=Number.MAX_VALUE,U=ht=-Number.MAX_VALUE;for(const mt of Tt){const nt=mt[0],rt=mt[1],et=T*nt+S*rt,bt=-S*nt+T*rt;J=Math.min(J,et),it=Math.min(it,bt),U=Math.max(U,et),ht=Math.max(ht,bt)}it=Math.floor(it/N)*N;let Y=T*J-S*it-L*ct/N,a=S*J+T*it-O*ct/N,A=T*U-S*it-L*ct/N,F=S*U+T*it-O*ct/N;const $=1+Math.round((ht-it)/N),R=[];for(let mt=0;mt<$;mt++)Y+=L,a+=O,A+=L,F+=O,R.push([[Y,a],[A,F]]);return{paths:R}}}class Ot extends ie{constructor(y,k){super(y,k),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new Jt.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,xt.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(y){if(y&&!(this._clipCount>0))if((0,Ct.oU)(y))this._processPath(y.rings,0);else if((0,Ct.l9)(y))this._processPath(y.paths,0);else if((0,Ct.YX)(y)){const k=Pt(y);k&&this._processPath(k.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(y,k,W){if(!y||this._clipCount>0)return;const N=.5*this.transformSize(null!=W?W:0);if((0,Ct.oU)(y))this._processPath(y.rings,N);else if((0,Ct.l9)(y))this._processPath(y.paths,N);else if((0,Ct.YX)(y)){const j=Pt(y);j&&this._processPath(j.rings,N)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(y,k){(0,Ct.oU)(k)&&y.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===y.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===y.markerPlacement.type&&y.markerPlacement.clipAtBoundary)?this._processPath(k.rings,0):super.drawMarkerLayer(y,k)}drawHatchFill(y,k){this.drawSolidFill(y)}drawPictureFill(y,k){this.drawSolidFill(y)}drawGradientFill(y,k){this.drawSolidFill(y)}drawPictureStroke(y,k){this.drawSolidStroke(y,null,k.width)}drawGradientStroke(y,k){this.drawSolidStroke(y,null,k.width)}pushClipPath(y){this.drawSolidFill(y),this._clipCount++}popClipPath(){this._clipCount--}drawImage(y,k){var yt;const{url:W}=y,N=null!=(yt=y.scaleX)?yt:1;let j=N*k,ct=k;const Z=this._resourceManager.getResource(W);!k&&(0,he.pC)(Z)&&(j=N*Z.width,ct=Z.height),this._merge(this.transformPt([-j/2,-ct/2]),0),this._merge(this.transformPt([-j/2,ct/2]),0),this._merge(this.transformPt([j/2,-ct/2]),0),this._merge(this.transformPt([j/2,ct/2]),0)}drawText(y,k){if(!k||0===k.length)return;this._textRasterizer||(this._textRasterizer=new Vt.Z);const W=Kt(y),[N,j]=this._textRasterizer.computeTextSize(k,W);let ct=0;switch(y.horizontalAlignment){case"Left":ct=N/2;break;case"Right":ct=-N/2}let Z=0;switch(y.verticalAlignment){case"Bottom":Z=j/2;break;case"Top":Z=-j/2;break;case"Baseline":Z=j/6}this._merge(this.transformPt([-N/2+ct,-j/2+Z]),0),this._merge(this.transformPt([-N/2+ct,j/2+Z]),0),this._merge(this.transformPt([N/2+ct,-j/2+Z]),0),this._merge(this.transformPt([N/2+ct,j/2+Z]),0)}_processPath(y,k){if(y)for(const W of y){const N=W?W.length:0;if(N>1){this._merge(this.transformPt(W[0]),k);for(let j=1;j<N;j++)this._merge(this.transformPt(W[j]),k)}}}_merge(y,k){y[0]-k<this._xmin&&(this._xmin=y[0]-k),y[0]+k>this._xmax&&(this._xmax=y[0]+k),y[1]-k<this._ymin&&(this._ymin=y[1]-k),y[1]+k>this._ymax&&(this._ymax=y[1]+k)}}class Mt extends ie{constructor(y,k,W,N){super(k,W),this._applyAdditionalRenderProps=N,this._colorSubstitutionHelper=new $t,this._ctx=y}drawSolidFill(y,k){var N;if(!y)return;if((0,Ct.oU)(y))this._buildPath(y.rings,!0);else if((0,Ct.l9)(y))this._buildPath(y.paths,!0);else if((0,Ct.YX)(y))this._buildPath(Pt(y).rings,!0);else{if(!(0,Ct.aW)(y))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const W=this._ctx;W.fillStyle="string"==typeof k?k:"rgba("+Math.round(k[0])+","+Math.round(k[1])+","+Math.round(k[2])+","+(null!=(N=k[3])?N:255)/255+")",W.fill("evenodd")}drawSolidStroke(y,k,W,N,j,ct){var yt;if(!y||!k||0===W)return;if((0,Ct.oU)(y))this._buildPath(y.rings,!0);else if((0,Ct.l9)(y))this._buildPath(y.paths,!1);else{if(!(0,Ct.YX)(y))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(Pt(y).rings,!0)}const Z=this._ctx;Z.strokeStyle="string"==typeof k?k:"rgba("+Math.round(k[0])+","+Math.round(k[1])+","+Math.round(k[2])+","+(null!=(yt=k[3])?yt:255)/255+")",Z.lineWidth=Math.max(this.transformSize(W),.5),this._setCapStyle(N),this._setJoinStyle(j),Z.miterLimit=ct,Z.stroke()}pushClipPath(y){if(this._ctx.save(),(0,Ct.oU)(y))this._buildPath(y.rings,!0);else if((0,Ct.l9)(y))this._buildPath(y.paths,!0);else{if(!(0,Ct.YX)(y))return;this._buildPath(Pt(y).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(y,k){var ht;const{colorSubstitutions:W,url:N,tintColor:j}=y,ct=null!=(ht=y.scaleX)?ht:1,Z=this._resourceManager.getResource(N);if((0,he.Wi)(Z))return;let yt=k*(Z.width/Z.height),Tt=k;k||(yt=Z.width,Tt=Z.height);const T=(0,Ht.TB)(N)||"src"in Z&&(0,Ht.TB)(Z.src);let S="getFrame"in Z?Q(Z):Z;W&&(S=this._colorSubstitutionHelper.applyColorSubstituition(S,W)),this._applyAdditionalRenderProps&&!T&&j&&(S=this._colorSubstitutionHelper.tintImageData(S,j));const L=this.transformPt([0,0]),[O,J]=this.getTransformAngle(),U=this.transformSize(1),it=this._ctx;it.save(),it.setTransform({m11:ct*U*O,m12:ct*U*J,m21:-U*J,m22:U*O,m41:L[0],m42:L[1]}),it.drawImage(S,-yt/2,-Tt/2,yt,Tt),it.restore()}drawText(y,k){if(!k||0===k.length)return;this._textRasterizer||(this._textRasterizer=new Vt.Z);const W=Kt(y);W.size*=this.transformSize((0,Nt.Wz)(1));const N=this._textRasterizer.rasterizeText(k,W);if(!N)return;const{size:j,anchorX:ct,anchorY:Z,canvas:yt}=N,Tt=j[0]*(ct+.5),T=j[1]*(Z-.5),S=this._ctx,L=this.transformPt([0,0]),[O,J]=this.getTransformAngle();S.save(),S.setTransform({m11:1*O,m12:1*J,m21:-1*J,m22:1*O,m41:L[0]-1*Tt,m42:L[1]+1*T}),S.drawImage(yt,0,0),S.restore()}drawPictureFill(y,k){if(!y)return;let{colorSubstitutions:W,height:N,offsetX:j,offsetY:ct,rotation:Z,scaleX:yt,tintColor:Tt,url:T}=k;const S=this._resourceManager.getResource(T);if((0,he.Wi)(S))return;if((0,Ct.oU)(y))this._buildPath(y.rings,!0);else if((0,Ct.l9)(y))this._buildPath(y.paths,!0);else if((0,Ct.YX)(y))this._buildPath(Pt(y).rings,!0);else{if(!(0,Ct.aW)(y))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const L=this._ctx,O=(0,Ht.TB)(T)||"src"in S&&(0,Ht.TB)(S.src);let J,U="getFrame"in S?Q(S):S;if(W&&(U=this._colorSubstitutionHelper.applyColorSubstituition(U,W)),this._applyAdditionalRenderProps){O||Tt&&(U=this._colorSubstitutionHelper.tintImageData(U,Tt)),J=L.createPattern(U,"repeat");const it=this.transformSize(1);Z||(Z=0),j?j*=it:j=0,ct?ct*=it:ct=0,N&&(N*=it);const ht=N?N/S.height:1,Y=yt&&N?yt*N/S.width:1;if(0!==Z||1!==ht||1!==Y||0!==j||0!==ct){const a=new DOMMatrix;a.rotateSelf(0,0,-Z).translateSelf(j,ct).scaleSelf(Y,ht,1),J.setTransform(a)}}else J=L.createPattern(U,"repeat");L.save(),L.fillStyle=J,L.fill("evenodd"),L.restore()}drawPictureStroke(y,k){if(!y)return;let{colorSubstitutions:W,capStyle:N,joinStyle:j,miterLimit:ct,tintColor:Z,url:yt,width:Tt}=k;const T=this._resourceManager.getResource(yt);if((0,he.Wi)(T))return;let S;if((0,Ct.oU)(y))S=y.rings;else if((0,Ct.l9)(y))S=y.paths;else{if(!(0,Ct.YX)(y))return(0,Ct.aW)(y)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;S=Pt(y).rings}Tt||(Tt=T.width);const L=(0,Ht.TB)(yt)||"src"in T&&(0,Ht.TB)(T.src);let O="getFrame"in T?Q(T):T;W&&(O=this._colorSubstitutionHelper.applyColorSubstituition(O,W)),this._applyAdditionalRenderProps&&(L||Z&&(O=this._colorSubstitutionHelper.tintImageData(O,Z)));const J=Math.max(this.transformSize((0,Nt.F2)(Tt)),.5),U=J/O.width,it=this._ctx,ht=it.createPattern(O,"repeat-y");let Y,a;it.save(),this._setCapStyle(N),this._setJoinStyle(j),void 0!==ct&&(it.miterLimit=ct),it.lineWidth=J;for(let A of S)if(A=(0,Ft.d9)(A),fe(A),A&&!(A.length<=1)){Y=this.transformPt(A[0]);for(let F=1;F<A.length;F++){a=this.transformPt(A[F]);const $=ut(Y,a),R=new DOMMatrix;R.translateSelf(0,Y[1]-J/2).scaleSelf(U,U,1).rotateSelf(0,0,90-$),ht.setTransform(R),it.strokeStyle=ht,it.beginPath(),it.moveTo(Y[0],Y[1]),it.lineTo(a[0],a[1]),it.stroke(),Y=a}}it.restore()}_buildPath(y,k){const W=this._ctx;if(W.beginPath(),y)for(const N of y){const j=N?N.length:0;if(j>1){let ct=this.transformPt(N[0]);W.moveTo(ct[0],ct[1]);for(let Z=1;Z<j;Z++)ct=this.transformPt(N[Z]),W.lineTo(ct[0],ct[1]);k&&W.closePath()}}}_setCapStyle(y){switch(y){case Et.kP.Butt:this._ctx.lineCap="butt";break;case Et.kP.Round:this._ctx.lineCap="round";break;case Et.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(y){switch(y){case Et.r4.Bevel:this._ctx.lineJoin="bevel";break;case Et.r4.Round:this._ctx.lineJoin="round";break;case Et.r4.Miter:this._ctx.lineJoin="miter"}}}function ut(It,y){return 180/Math.PI*Math.atan2(y[1]-It[1],y[0]-It[0])}const Pt=It=>It?{spatialReference:It.spatialReference,rings:[[[It.xmin,It.ymin],[It.xmin,It.ymax],[It.xmax,It.ymax],[It.xmax,It.ymin],[It.xmin,It.ymin]]]}:null;function Kt(It,y=1){const k=(0,Ht.BX)(It),W=(0,Ht.wi)(It.fontStyleName),N=(0,gt.BN)(It.fontFamilyName),{weight:j,style:ct}=W,Z=y*(It.height||5),yt=(0,Ht.X_)(It.horizontalAlignment),Tt=(0,Ht.FG)(It.verticalAlignment),T=(0,Ht.W7)(It),S=(0,Ht.$Z)(It.haloSymbol),L=S?y*(0|It.haloSize):0;return{color:T,size:Z,horizontalAlignment:yt,verticalAlignment:Tt,font:{family:N,style:(0,Ht.pJ)(ct),weight:(0,Ht.On)(j),decoration:k},halo:{size:L||0,color:S,style:ct},pixelRatio:1,premultiplyColors:!0}}function fe(It){let y,k,W,N,j,ct=It[0],Z=1;for(;Z<It.length;)y=It[Z][0]-ct[0],k=It[Z][1]-ct[1],N=0!==y?k/y:Math.PI/2,void 0!==W&&N-W<=1e-4?(It.splice(Z-1,1),ct=j):(j=ct,ct=It[Z],Z++),W=N}},35909:(Pe,re,at)=>{at.d(re,{B$:()=>wt,E0:()=>Dt,U1:()=>N});var Wt=at(15861),gt=at(91558),Ft=at(986),zt=at(58817),he=at(63290),tt=at(62208),Nt=at(4619),xt=at(23841),Ct=(at(65401),at(32442),at(46679)),Ut=at(97373),$t=at(26933),st=at(7547),ft=at(80991),Et=at(39236),Jt=(at(86575),at(39351));at(25797);const Ht=Math.PI,oe=Ht/2,Gt=96/72,Rt=(Math,he.Z.getLogger("esri.symbols.cim.CIMSymbolHelper"));function Ot(T,S,L){switch(S.type){case"CIMSymbolReference":return Ot(T,S.symbol,L);case"CIMPointSymbol":null==L&&(L={x:0,y:0}),T.drawSymbol(S,L);break;case"CIMLineSymbol":null==L&&(L={paths:[[[0,0],[10,0]]]}),T.drawSymbol(S,L);break;case"CIMPolygonSymbol":null==L&&(L={rings:[[[0,0],[0,10],[10,10],[10,0],[0,0]]]}),T.drawSymbol(S,L);break;case"CIMTextSymbol":T.drawSymbol(S,{x:0,y:0});break;case"CIMVectorMarker":{const O=new Ut.u;T.drawMarker(S,O);break}}return T.envelope()}class wt{static getEnvelope(S,L,O){if(!S)return null;const J=new $t.uQ(O);if(Array.isArray(S)){let U;for(const it of S)U?U.union(Ot(J,it,L)):U=Ot(J,it,L);return U}return Ot(J,S,L)}static getTextureAnchor(S,L){const O=this.getEnvelope(S,null,L);if(!O)return[0,0,0];const ht=O.height*Gt+2;return[-(O.x+.5*O.width)*Gt/(O.width*Gt+2),-(O.y+.5*O.height)*Gt/ht,ht]}static rasterize(S,L,O,J,U=!0){const it=O||this.getEnvelope(L,null,J);if(!it)return[null,0,0,0,0];const ht=(it.x+.5*it.width)*Gt,Y=(it.y+.5*it.height)*Gt;S.width=it.width*Gt,S.height=it.height*Gt,O||(S.width+=2,S.height+=2);const a=S.getContext("2d"),A=$t.zA.createScale(Gt,-Gt);A.translate(.5*S.width-ht,.5*S.height+Y);const F=new $t.cD(a,J,A);switch(L.type){case"CIMPointSymbol":F.drawSymbol(L,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const mt=new Ut.u;F.drawMarker(L,mt);break}}const $=a.getImageData(0,0,S.width,S.height),R=new Uint8Array($.data);if(U){let mt;for(let nt=0;nt<R.length;nt+=4)mt=R[nt+3]/255,R[nt]=R[nt]*mt,R[nt+1]=R[nt+1]*mt,R[nt+2]=R[nt+2]*mt}return[R,S.width,S.height,-ht/S.width,-Y/S.height]}static fromTextSymbol(S){const{angle:L,color:O,font:J,haloColor:U,haloSize:it,horizontalAlignment:ht,kerning:Y,text:a,verticalAlignment:A,xoffset:F,yoffset:$,backgroundColor:R,borderLineColor:mt,borderLineSize:nt}=S;let rt,et,bt,Lt,Xt,jt;J&&(rt=J.family,et=J.style,bt=J.weight,Lt=J.size,Xt=J.decoration);let vt=!1;return a&&(vt=(0,Ft.E)(a)[1]),(R||nt)&&(jt={type:"CIMBackgroundCallout",margin:null,backgroundSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",color:It(R)},{type:"CIMSolidStroke",color:It(mt),width:nt}]},accentBarSymbol:null,gap:null,leaderLineSymbol:null,lineStyle:null}),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:L,blockProgression:st.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:st.eZ.Normal,fontEncoding:st.DD.Unicode,fontFamilyName:rt||"Arial",fontStyleName:y(et,bt),fontType:st.Ky.Unspecified,haloSize:it,height:Lt,hinting:st.Dd.Default,horizontalAlignment:ce(null!=ht?ht:"center"),kerning:Y,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,ft.NA)(F),offsetY:(0,ft.NA)($),strikethrough:"line-through"===Xt,underline:"underline"===Xt,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:It(O)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:It(U)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:vt?st.UX.RTL:st.UX.LTR,verticalAlignment:fe(null!=A?A:"baseline"),verticalGlyphOrientation:st.RS.Right,wordSpacing:100,billboardMode3D:st.UR.FaceNearPlane,callout:jt},textString:a}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(S){var nt;const{height:L,outline:O,width:J,xoffset:U,xscale:it,yoffset:ht,yscale:Y}=S,a=[],A={type:"CIMPolygonSymbol",symbolLayers:a};if(O){const{cap:rt,join:et,miterLimit:bt,width:Lt}=O;a.push({type:"CIMSolidStroke",color:It(O.color),capStyle:te(rt),joinStyle:Kt(et),miterLimit:bt,width:Lt})}let F=S.url;"esriPFS"===S.type&&S.imageData&&(F=S.imageData);const $="angle"in S&&null!=(nt=S.angle)?nt:0;return a.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:st.Qb.Picture,tintColor:null,url:F,height:(null!=L?L:0)*(Y||1),width:(null!=J?J:0)*(it||1),offsetX:(0,ft.NA)(U),offsetY:(0,ft.NA)(ht),rotation:(0,ft.NA)(-$),colorSubstitutions:null}),A}static fromSimpleFillSymbol(S){const{color:L,style:O,outline:J}=S,U=[],it={type:"CIMPolygonSymbol",symbolLayers:U};let ht=null;if(J){const{cap:Y,join:a,style:A}=J;"solid"!==A&&"none"!==A&&"esriSLSSolid"!==A&&"esriSLSNull"!==A&&(ht=[{type:"CIMGeometricEffectDashes",dashTemplate:N(A,Y),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),U.push({type:"CIMSolidStroke",color:It(J.color),capStyle:te(Y),joinStyle:Kt(a),miterLimit:J.miterLimit,width:J.width,effects:ht})}if(O&&"solid"!==O&&"none"!==O&&"esriSFSSolid"!==O&&"esriSFSNull"!==O){const Y={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:It(L),capStyle:st.kP.Butt,joinStyle:st.r4.Miter,width:.75}]};let a=0;const A=(0,xt.Wz)(Z(O)?8:10);switch(O){case"vertical":case"esriSFSVertical":a=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":a=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":a=45;break;case"cross":case"esriSFSCross":a=0}U.push({type:"CIMHatchFill",lineSymbol:Y,offsetX:0,offsetY:0,rotation:a,separation:A}),"cross"===O||"esriSFSCross"===O?U.push({type:"CIMHatchFill",lineSymbol:(0,zt.d9)(Y),offsetX:0,offsetY:0,rotation:90,separation:A}):"diagonal-cross"!==O&&"esriSFSDiagonalCross"!==O||U.push({type:"CIMHatchFill",lineSymbol:(0,zt.d9)(Y),offsetX:0,offsetY:0,rotation:45,separation:A})}else!O||"solid"!==O&&"esriSFSSolid"!==O||U.push({type:"CIMSolidFill",enable:!0,color:It(L)});return it}static fromSimpleLineSymbol(S){const{cap:L,color:O,join:J,marker:U,miterLimit:it,style:ht,width:Y}=S;let a=null;"solid"!==ht&&"none"!==ht&&"esriSLSSolid"!==ht&&"esriSLSNull"!==ht&&(a=[{type:"CIMGeometricEffectDashes",dashTemplate:N(ht,L),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const A=[];if(U){let F;switch(U.placement){case"begin-end":F=st.Tx.Both;break;case"begin":F=st.Tx.JustBegin;break;case"end":F=st.Tx.JustEnd;break;default:F=st.Tx.None}const $=wt.fromSimpleMarker(U,Y,O).symbolLayers[0];$.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:F,offsetAlongLine:0},A.push($)}return"none"!==ht&&"esriSLSNull"!==ht&&A.push({type:"CIMSolidStroke",color:It(O),capStyle:te(L),joinStyle:Kt(J),miterLimit:it,width:Y,effects:a}),{type:"CIMLineSymbol",symbolLayers:A}}static fromPictureMarker(S){const{angle:L,height:O,width:J,xoffset:U,yoffset:it}=S;let ht=S.url;return"esriPMS"===S.type&&S.imageData&&(ht=S.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:st.Qb.Picture,tintColor:null,url:ht,size:O,width:J,offsetX:(0,ft.NA)(U),offsetY:(0,ft.NA)(it),rotation:(0,ft.NA)(-L)}]}}static fromSimpleMarker(S,L,O){var a;const{style:J}=S,U=null!=(a=S.color)?a:O;if("path"===J){const A=[];if("outline"in S&&S.outline){const R=S.outline;A.push({type:"CIMSolidStroke",enable:!0,width:(0,xt.F2)(Math.round((0,xt.Wz)(R.width))),color:It(R.color)})}A.push({type:"CIMSolidFill",enable:!0,color:It(U),path:S.path});const[F,$]=ct("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,ft.NA)(-S.angle),size:(0,ft.NA)(S.size||6),offsetX:(0,ft.NA)(S.xoffset),offsetY:(0,ft.NA)(S.yoffset),frame:F,markerGraphics:[{type:"CIMMarkerGraphic",geometry:$,symbol:{type:"CIMPolygonSymbol",symbolLayers:A}}]}]}}const[it,ht]=ct(J);let Y;if(ht&&it){const A=[];if("outline"in S&&S.outline){const $=S.outline;A.push({type:"CIMSolidStroke",enable:!0,width:null!=$.width&&$.width>.667?(0,xt.F2)(Math.round((0,xt.Wz)($.width))):$.width,color:It($.color)})}else!L||"line-marker"!==S.type||"cross"!==S.style&&"x"!==S.style||A.push({type:"CIMSolidStroke",enable:!0,width:L,color:It(U)});A.push({type:"CIMSolidFill",enable:!0,color:It(U)});const F={type:"CIMPolygonSymbol",symbolLayers:A};Y={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,ft.NA)(-S.angle),size:(0,ft.NA)(S.size||6*L),offsetX:(0,ft.NA)(S.xoffset),offsetY:(0,ft.NA)(S.yoffset),frame:it,markerGraphics:[{type:"CIMMarkerGraphic",geometry:ht,symbol:F}]}]}}return Y}static fromCIMHatchFill(S,L){var Y,a;const O=L*(null!=(Y=S.separation)?Y:4),J=O/2,U=(0,zt.d9)(S.lineSymbol);null==(a=U.symbolLayers)||a.forEach(A=>{var F;switch(A.type){case"CIMSolidStroke":null!=A.width&&(A.width*=L),null==(F=A.effects)||F.forEach($=>{"CIMGeometricEffectDashes"===$.type&&($.dashTemplate=$.dashTemplate.map(R=>R*L))});break;case"CIMVectorMarker":{null!=A.size&&(A.size*=L);const $=A.markerPlacement;null!=$&&"placementTemplate"in $&&($.placementTemplate=$.placementTemplate.map(R=>R*L));break}}});let it=this._getLineSymbolPeriod(U)||4;for(;it<4;)it*=2;const ht=it/2;return{type:"CIMVectorMarker",frame:{xmin:-ht,xmax:ht,ymin:-J,ymax:J},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-ht,0],[ht,0]]]},symbol:U}],size:O}}static fetchResources(S,L,O){if(S&&L)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{const J=S.symbolLayers;if(!J)return;for(const U of J)switch(Tt(U,L,O),U.type){case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMCharacterMarker":case"CIMPictureMarker":"url"in U&&U.url&&O.push(L.fetchResource(U.url,null));break;case"CIMVectorMarker":{const it=U.markerGraphics;if(!it)continue;for(const ht of it)if(ht){const Y=ht.symbol;Y&&wt.fetchResources(Y,L,O)}}}}}}static _getLineSymbolPeriod(S){if(S){const L=this._getEffectsRepeat(S.effects);if(L)return L;if(S.symbolLayers)for(const O of S.symbolLayers)if(O){const J=this._getEffectsRepeat(O.effects);if(J)return J;switch(O.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const U=this._getPlacementRepeat(O.markerPlacement);if(U)return U}}}}return 0}static _getEffectsRepeat(S){if(S)for(const L of S)if(L)switch(L.type){case"CIMGeometricEffectDashes":{const O=L.dashTemplate;if(O&&O.length){let J=0;for(const U of O)J+=U;return 1&O.length&&(J*=2),J}break}case"CIMGeometricEffectWave":return L.period;default:Rt.error(`unsupported geometric effect type ${L.type}`)}return 0}static _getPlacementRepeat(S){if(S)switch(S.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const L=S.placementTemplate;if(L&&L.length){let O=0;for(const J of L)O+=+J;return 1&L.length&&(O*=2),O}break}}return 0}static fromCIMInsidePolygon(S){var F;const L=S.markerPlacement,O=Ve({},S);O.markerPlacement=null,O.anchorPoint=null;const J=Math.abs(L.stepX),U=Math.abs(L.stepY),it=(null!=(F=L.randomness)?F:100)/100;let ht,Y,a,A;if("Random"===L.gridType){const $=(0,xt.Wz)(Jt.C1),R=Math.max(Math.floor($/J),1),mt=Math.max(Math.floor($/U),1);ht=R*J/2,Y=mt*U/2,a=2*Y;const nt=new Nt.Z(L.seed),rt=it*J/1.5,et=it*U/1.5;A=[];for(let bt=0;bt<R;bt++)for(let Lt=0;Lt<mt;Lt++){const Xt=bt*J-ht+rt*(.5-nt.getFloat()),jt=Lt*U-Y+et*(.5-nt.getFloat());A.push({x:Xt,y:jt}),0===bt&&A.push({x:Xt+2*ht,y:jt}),0===Lt&&A.push({x:Xt,y:jt+2*Y})}}else!0===L.shiftOddRows?(ht=J/2,Y=U,a=2*U,A=[{x:-ht,y:0},{x:ht,y:0},{x:0,y:Y},{x:0,y:-Y}]):(ht=J/2,Y=U/2,a=U,A=[{x:-J,y:0},{x:0,y:-U},{x:-J,y:-U},{x:0,y:0},{x:J,y:0},{x:0,y:U},{x:J,y:U},{x:-J,y:U},{x:J,y:-U}]);return{type:"CIMVectorMarker",frame:{xmin:-ht,xmax:ht,ymin:-Y,ymax:Y},markerGraphics:A.map($=>({type:"CIMMarkerGraphic",geometry:$,symbol:{type:"CIMPointSymbol",symbolLayers:[O]}})),size:a}}static getSize(S){if(S)switch(S.type){case"CIMTextSymbol":return S.height;case"CIMPointSymbol":{let L=0;if(S.symbolLayers)for(const O of S.symbolLayers)if(O)switch(O.type){case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":{const J=O.size;null!=J&&J>L&&(L=J);break}}return L}case"CIMLineSymbol":case"CIMPolygonSymbol":{let L=0;if(S.symbolLayers)for(const O of S.symbolLayers)if(O)switch(O.type){case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const J=O.width;null!=J&&J>L&&(L=J);break}case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":case"CIMObjectMarker3D":case"CIMglTFMarker3D":if(O.markerPlacement&&(0,ft.gJ)(O.markerPlacement)){const J=O.size;null!=J&&J>L&&(L=J)}}return L}}}static getMarkerScaleRatio(S){return S&&"CIMVectorMarker"===S.type&&!1!==S.scaleSymbolsProportionally&&S.frame&&null!=S.size?S.size/(S.frame.ymax-S.frame.ymin):1}}class Dt{static findApplicableOverrides(S,L,O){if(S&&L){if(S.primitiveName){let J=!1;for(const U of O)if(U.primitiveName===S.primitiveName){J=!0;break}if(!J)for(const U of L)U.primitiveName===S.primitiveName&&O.push(U)}switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(S.effects)for(const J of S.effects)Dt.findApplicableOverrides(J,L,O);if(S.symbolLayers)for(const J of S.symbolLayers)Dt.findApplicableOverrides(J,L,O);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(S.effects)for(const J of S.effects)Dt.findApplicableOverrides(J,L,O);if(S.markerPlacement&&Dt.findApplicableOverrides(S.markerPlacement,L,O),"CIMVectorMarker"===S.type){if(S.markerGraphics)for(const J of S.markerGraphics)Dt.findApplicableOverrides(J,L,O),Dt.findApplicableOverrides(J.symbol,L,O)}else"CIMCharacterMarker"===S.type?Dt.findApplicableOverrides(S.symbol,L,O):"CIMHatchFill"===S.type?Dt.findApplicableOverrides(S.lineSymbol,L,O):"CIMPictureMarker"===S.type&&Dt.findApplicableOverrides(S.animatedSymbolProperties,L,O)}}}static findEffectOverrides(S,L,O){var U;if(!L||!S)return;const J=S.length;for(let it=0;it<J;it++){const ht=null==(U=S[it])?void 0:U.primitiveName;if(ht){let Y=!1;for(const a of O)if(a.primitiveName===ht){Y=!0;break}if(!Y)for(const a of L)a.primitiveName===ht&&O.push(a)}}}static resolveSymbolOverrides(S,L,O,J,U,it,ht){return(0,Wt.Z)(function*(){if(!S||!S.symbol)return null;let{symbol:Y,primitiveOverrides:a}=S;const A=!!a;if(!A&&!J)return Y;Y=(0,zt.d9)(Y);let F=!0;if(L||(L={attributes:{}},F=!1),A){if(F||(a=a.filter($=>{var R;return!(null!=(R=$.valueExpressionInfo)&&R.expression.includes("$feature"))})),ht||(a=a.filter($=>{var R;return!(null!=(R=$.valueExpressionInfo)&&R.expression.includes("$view"))})),a.length>0){const $=(0,ft.Qf)(L.attributes);yield Dt.evaluateOverrides(a,L,{spatialReference:O,fields:$,geometryType:U},it,ht)}Dt.applyOverrides(Y,a)}return J&&Dt.applyDictionaryTextOverrides(Y,L,J),Y})()}static evaluateOverrides(S,L,O,J,U){return(0,Wt.Z)(function*(){if(!L)return;let it;for(const ht of S){const Y=ht.valueExpressionInfo;if(Y&&O&&O.geometryType){it||(it=[]),ht.value=void 0;const a=(0,Ct.Yi)(Y.expression,O.spatialReference,O.fields).then(A=>{ht.value=(0,Et.Z)(A,L,{$view:U},O.geometryType,J)});it.push(a)}}void 0!==it&&it.length>0&&(yield Promise.all(it))})()}static applyDictionaryTextOverrides(S,L,O,J="Normal"){if(S&&S.type)switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const U=S.symbolLayers;if(!U)return;for(const it of U)it&&"CIMVectorMarker"===it.type&&Dt.applyDictionaryTextOverrides(it,L,O,"CIMTextSymbol"===S.type?S.textCase:J)}break;case"CIMVectorMarker":{const U=S.markerGraphics;if(!U)return;for(const it of U)it&&Dt.applyDictionaryTextOverrides(it,L,O)}break;case"CIMMarkerGraphic":{const U=S.textString;if(U&&U.includes("[")){const it=(0,ft.H1)(U,O);S.textString=(0,ft.E_)(L,it,J)}}}}static applyOverrides(S,L,O,J){if(S.primitiveName)for(const U of L)if(U.primitiveName===S.primitiveName){const it=yt(U.propertyName);if(J&&J.push({cim:S,nocapPropertyName:it,value:S[it]}),U.expression&&(U.value=Dt.toValue(U.propertyName,U.expression)),O){let ht=!1;for(const Y of O)Y.primitiveName===S.primitiveName&&(ht=!0);ht||O.push(U)}(0,tt.pC)(U.value)&&(S[it]=U.value)}switch(S.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(S.effects)for(const U of S.effects)Dt.applyOverrides(U,L,O,J);if(S.symbolLayers)for(const U of S.symbolLayers)Dt.applyOverrides(U,L,O,J);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(S.effects)for(const U of S.effects)Dt.applyOverrides(U,L,O,J);if("CIMVectorMarker"===S.type&&S.markerGraphics)for(const U of S.markerGraphics)Dt.applyOverrides(U,L,O,J),Dt.applyOverrides(U.symbol,L,O,J)}}static restoreOverrides(S){for(const L of S)L.cim[L.nocapPropertyName]=L.value}static buildOverrideKey(S){let L="";for(const O of S)void 0!==O.value&&(L+=`${O.primitiveName}${O.propertyName}${JSON.stringify(O.value)}`);return L}static toValue(S,L){if("DashTemplate"===S)return L.split(" ").map(O=>Number(O));if("Color"===S){const O=new gt.Z(L).toRgba();return O[3]*=255,O}return L}}const te=T=>{if(!T)return st.kP.Butt;switch(T){case"butt":return st.kP.Butt;case"square":return st.kP.Square;case"round":return st.kP.Round}},Kt=T=>{if(!T)return st.r4.Miter;switch(T){case"miter":return st.r4.Miter;case"round":return st.r4.Round;case"bevel":return st.r4.Bevel}},ce=T=>{if((0,tt.Wi)(T))return"Center";switch(T){case"left":return"Left";case"right":return"Right";case"center":return"Center"}},fe=T=>{if((0,tt.Wi)(T))return"Center";switch(T){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},It=T=>{if(!T)return[0,0,0,0];const{r:S,g:L,b:O,a:J}=T;return[S,L,O,255*J]},y=(T,S)=>{const L=k(S),O=W(T);return L&&O?`${L}-${O}`:`${L}${O}`},k=T=>{if(!T)return"";switch(T.toLowerCase()){case"bold":case"bolder":return"bold"}return""},W=T=>{if(!T)return"";switch(T.toLowerCase()){case"italic":case"oblique":return"italic"}return""},N=(T,S)=>{const L="butt"===S;switch(T){case"dash":case"esriSLSDash":return L?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return L?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return L?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return L?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return L?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return L?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return L?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return L?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return L?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return L?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return Rt.error("Unexpected: style does not require rasterization"),[0,0];default:return Rt.error(`Tried to rasterize SLS, but found an unexpected style: ${T}!`),[0,0]}},ct=T=>{let O,J;const U=T;if("circle"===U||"esriSMSCircle"===U){let ht=Math.acos(.995),Y=Math.ceil(Ht/ht/4);0===Y&&(Y=1),ht=oe/Y,Y*=4;const a=[];a.push([50,0]);for(let A=1;A<Y;A++)a.push([50*Math.cos(A*ht),-50*Math.sin(A*ht)]);a.push([50,0]),O={rings:[a]},J={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===U||"esriSMSCross"===U)O={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===U||"esriSMSDiamond"===U)O={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===U||"esriSMSSquare"===U)O={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===U||"esriSMSX"===U)O={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===U||"esriSMSTriangle"===U){const it=57.735026918962575,ht=-it,Y=2/3*100,a=Y-100;O={rings:[[[ht,a],[0,Y],[it,a],[ht,a]]]},J={xmin:ht,ymin:a,xmax:it,ymax:Y}}else"arrow"===U&&(O={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},J={xmin:-50,ymin:-50,xmax:50,ymax:50});return[J,O]},Z=T=>"vertical"===T||"horizontal"===T||"cross"===T||"esriSFSCross"===T||"esriSFSVertical"===T||"esriSFSHorizontal"===T,yt=T=>T&&T.charAt(0).toLowerCase()+T.substr(1);function Tt(T,S,L){if(T.effects&&!(0,tt.pC)(S.geometryEngine)){if(S.geometryEnginePromise)return void L.push(S.geometryEnginePromise);(0,ft.Cc)(T.effects)&&(S.geometryEnginePromise=(0,ft.RI)(),L.push(S.geometryEnginePromise),S.geometryEnginePromise.then(O=>S.geometryEngine=O))}}},31375:(Pe,re,at)=>{at.d(re,{Z:()=>Wt});class Wt{constructor(Ft=0,zt=0,he=0,tt=0){this.x=Ft,this.y=zt,this.width=he,this.height=tt}get isEmpty(){return this.width<=0||this.height<=0}union(Ft){this.x=Math.min(this.x,Ft.x),this.y=Math.min(this.y,Ft.y),this.width=Math.max(this.width,Ft.width),this.height=Math.max(this.height,Ft.height)}}},47139:(Pe,re,at)=>{at.d(re,{Fp:()=>zt,RL:()=>dt,UV:()=>At,bk:()=>xt});var Wt=at(36161),gt=at(91179),Ft=at(31375);function zt(st){var ft;if(!st)return null;switch(st.type){case"CIMPointSymbol":{const Et=st.symbolLayers;return Et&&1===Et.length?zt(Et[0]):null}case"CIMVectorMarker":{const Et=st.markerGraphics;if(!Et||1!==Et.length)return null;const Q=Et[0];if(!Q)return null;const Jt=Q.geometry;if(!Jt)return null;const Vt=Q.symbol;return!Vt||"CIMPolygonSymbol"!==Vt.type&&"CIMLineSymbol"!==Vt.type||(null==(ft=Vt.symbolLayers)?void 0:ft.some(Ht=>!!Ht.effects))?null:{geom:Jt,asFill:"CIMPolygonSymbol"===Vt.type}}case"sdf":return{geom:st.geom,asFill:st.asFill}}return null}function Nt(st){let ft=1/0,Et=-1/0,Q=1/0,Jt=-1/0;for(const Vt of st)for(const Ht of Vt)Ht[0]<ft&&(ft=Ht[0]),Ht[0]>Et&&(Et=Ht[0]),Ht[1]<Q&&(Q=Ht[1]),Ht[1]>Jt&&(Jt=Ht[1]);return[ft,Q,Et,Jt]}function xt(st){return st?st.rings?Nt(st.rings):st.paths?Nt(st.paths):(0,gt.YX)(st)?[st.xmin,st.ymin,st.xmax,st.ymax]:null:null}function At(st,ft,Et,Q,Jt){const[Vt,Ht,oe,ue]=st;if(oe<Vt||ue<Ht)return[0,0,0];const ot=oe-Vt,St=ue-Ht,Rt=Math.floor(31.5),ie=(128-2*(Rt+1))/Math.max(ot,St),Ot=Math.round(ot*ie)+2*Rt,pt=Math.round(St*ie)+2*Rt;let Mt=1;ft&&(Mt=pt/ie/(ft.ymax-ft.ymin));let ut=0,Pt=0,wt=1;Q&&(Jt?ft&&Et&&ft.ymax-ft.ymin>0&&(wt=(ft.xmax-ft.xmin)/(ft.ymax-ft.ymin),ut=Q.x/(Et*wt),Pt=Q.y/Et):(ut=Q.x,Pt=Q.y)),ft&&(ut=.5*(ft.xmax+ft.xmin)+ut*(ft.xmax-ft.xmin),Pt=.5*(ft.ymax+ft.ymin)+Pt*(ft.ymax-ft.ymin)),ut-=Vt,Pt-=Ht,ut*=ie,Pt*=ie,ut+=Rt,Pt+=Rt;let Dt=ut/Ot-.5,te=Pt/pt-.5;return Jt&&Et&&(Dt*=Et*wt,te*=Et),[Mt,Dt,te]}function dt(st){const ft=function he(st){return st?st.rings?st.rings:st.paths?st.paths:void 0!==st.xmin&&void 0!==st.ymin&&void 0!==st.xmax&&void 0!==st.ymax?[[[st.xmin,st.ymin],[st.xmin,st.ymax],[st.xmax,st.ymax],[st.xmax,st.ymin],[st.xmin,st.ymin]]]:null:null}(st.geom),Et=function tt(st){let ft=1/0,Et=-1/0,Q=1/0,Jt=-1/0;for(const Vt of st)for(const Ht of Vt)Ht[0]<ft&&(ft=Ht[0]),Ht[0]>Et&&(Et=Ht[0]),Ht[1]<Q&&(Q=Ht[1]),Ht[1]>Jt&&(Jt=Ht[1]);return new Ft.Z(ft,Q,Et-ft,Jt-Q)}(ft),Vt=Math.floor(31.5),Ht=(128-2*(Vt+1))/Math.max(Et.width,Et.height),oe=Math.round(Et.width*Ht)+2*Vt,ue=Math.round(Et.height*Ht)+2*Vt,ot=[];for(const Gt of ft)if(Gt&&Gt.length>1){const qt=[];for(const Rt of Gt){let[ie,Ot]=Rt;ie-=Et.x,Ot-=Et.y,ie*=Ht,Ot*=Ht,ie+=Vt-.5,Ot+=Vt-.5,qt.push(st.asFill?[ie,Ot]:[Math.round(ie),Math.round(Ot)])}if(st.asFill){const Rt=qt.length-1;qt[0][0]===qt[Rt][0]&&qt[0][1]===qt[Rt][1]||qt.push(qt[0])}ot.push(qt)}const St=function Ct(st,ft,Et,Q){const Jt=ft*Et,Vt=new Array(Jt),Ht=Q*Q+1;for(let oe=0;oe<Jt;++oe)Vt[oe]=Ht;for(const oe of st){const ue=oe.length;for(let ot=1;ot<ue;++ot){const St=oe[ot-1],Gt=oe[ot];let qt,Rt,ie,Ot;St[0]<Gt[0]?(qt=St[0],Rt=Gt[0]):(qt=Gt[0],Rt=St[0]),St[1]<Gt[1]?(ie=St[1],Ot=Gt[1]):(ie=Gt[1],Ot=St[1]);let pt=Math.floor(qt)-Q,Mt=Math.floor(Rt)+Q,ut=Math.floor(ie)-Q,Pt=Math.floor(Ot)+Q;pt<0&&(pt=0),Mt>ft&&(Mt=ft),ut<0&&(ut=0),Pt>Et&&(Pt=Et);const wt=Gt[0]-St[0],Dt=Gt[1]-St[1],te=wt*wt+Dt*Dt;for(let Kt=pt;Kt<Mt;Kt++)for(let ce=ut;ce<Pt;ce++){let fe,It,y=(Kt-St[0])*wt+(ce-St[1])*Dt;y<0?(fe=St[0],It=St[1]):y>te?(fe=Gt[0],It=Gt[1]):(y/=te,fe=St[0]+y*wt,It=St[1]+y*Dt);const k=(Kt-fe)*(Kt-fe)+(ce-It)*(ce-It),W=(Et-ce-1)*ft+Kt;k<Vt[W]&&(Vt[W]=k)}}}for(let oe=0;oe<Jt;++oe)Vt[oe]=Math.sqrt(Vt[oe]);return Vt}(ot,oe,ue,Vt);return st.asFill&&function Ut(st,ft,Et,Q,Jt){for(const Vt of st){const Ht=Vt.length;for(let oe=1;oe<Ht;++oe){const ue=Vt[oe-1],ot=Vt[oe];let St,Gt,qt,Rt;ue[0]<ot[0]?(St=ue[0],Gt=ot[0]):(St=ot[0],Gt=ue[0]),ue[1]<ot[1]?(qt=ue[1],Rt=ot[1]):(qt=ot[1],Rt=ue[1]);let ie=Math.floor(St),Ot=Math.floor(Gt)+1,pt=Math.floor(qt),Mt=Math.floor(Rt)+1;ie<Q&&(ie=Q),Ot>ft-Q&&(Ot=ft-Q),pt<Q&&(pt=Q),Mt>Et-Q&&(Mt=Et-Q);for(let ut=pt;ut<Mt;++ut){if(ue[1]>ut==ot[1]>ut)continue;const Pt=(Et-ut-1)*ft;for(let wt=ie;wt<Ot;++wt)wt<(ot[0]-ue[0])*(ut-ue[1])/(ot[1]-ue[1])+ue[0]&&(Jt[Pt+wt]=-Jt[Pt+wt]);for(let wt=Q;wt<ie;++wt)Jt[Pt+wt]=-Jt[Pt+wt]}}}}(ot,oe,ue,Vt,St),[$t(St,Vt),oe,ue]}function $t(st,ft){const Et=2*ft,Q=st.length,Jt=new Uint8Array(4*Q);for(let Vt=0;Vt<Q;++Vt)(0,Wt.I)(.5-st[Vt]/Et,Jt,4*Vt);return Jt}},68937:(Pe,re,at)=>{at.d(re,{Z:()=>zt});var Wt=at(23841);class zt{constructor(Nt){Nt&&(this._textRasterizationCanvas=Nt)}rasterizeText(Nt,xt){var pt;this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const At=this._textRasterizationCanvas,dt=At.getContext("2d");this._setFontProperties(dt,xt),this._parameters=xt,this._textLines=Nt.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Ct=this._computeTextWidth(dt,xt),{decoration:Ut,weight:$t}=xt.font;this._lineThroughWidthOffset=Ut&&"line-through"===Ut?.1*this._lineHeight:0;const st=this._lineHeight*this._textLines.length;At.width=Ct+2*this._lineThroughWidthOffset,At.height=st,this._renderedLineHeight=Math.round(this._lineHeight*xt.pixelRatio),this._renderedHaloSize=xt.halo.size*xt.pixelRatio,this._renderedWidth=Ct*xt.pixelRatio,this._renderedHeight=st*xt.pixelRatio,this._lineThroughWidthOffset*=xt.pixelRatio;const ft=null!=(pt=xt.color)?pt:[0,0,0,0],Et=xt.halo&&xt.halo.color?xt.halo.color:[0,0,0,0];this._fillStyle=function Ft(tt){return`rgba(${tt.slice(0,3).toString()},${tt[3]})`}(ft),this._haloStyle=function gt(tt){return`rgb(${tt.slice(0,3).toString()})`}(Et);const Q=this._renderedLineHeight,Jt=this._renderedHaloSize;dt.save(),dt.clearRect(0,0,At.width,At.height),this._setFontProperties(dt,xt);const Vt=function he(tt,Nt){return"center"===tt?.5*Nt:"right"===tt?Nt:0}(dt.textAlign,this._renderedWidth)+Jt,Ht=Jt,oe=Jt>0;let ue=this._lineThroughWidthOffset,ot=0;oe&&this._renderHalo(dt,Vt,Ht,ue,ot,xt),ot+=Ht,ue+=Vt;for(const Mt of this._textLines)oe?(dt.globalCompositeOperation="destination-out",dt.fillStyle="rgb(0, 0, 0)",dt.fillText(Mt,ue,ot),dt.globalCompositeOperation="source-over",dt.fillStyle=this._fillStyle,dt.fillText(Mt,ue,ot)):(dt.fillStyle=this._fillStyle,dt.fillText(Mt,ue,ot)),Ut&&"none"!==Ut&&this._renderDecoration(dt,ue,ot,Ut,$t),ot+=Q;dt.restore();const St=this._renderedWidth+2*this._lineThroughWidthOffset,Gt=this._renderedHeight,qt=dt.getImageData(0,0,St,Gt),Rt=new Uint8Array(qt.data);if(xt.premultiplyColors){let Mt;for(let ut=0;ut<Rt.length;ut+=4)Mt=Rt[ut+3]/255,Rt[ut]=Rt[ut]*Mt,Rt[ut+1]=Rt[ut+1]*Mt,Rt[ut+2]=Rt[ut+2]*Mt}let ie,Ot;switch(xt.horizontalAlignment){case"left":ie=-.5;break;case"right":ie=.5;break;default:ie=0}switch(xt.verticalAlignment){case"bottom":Ot=-.5;break;case"top":Ot=.5;break;default:Ot=0}return{size:[St,Gt],image:new Uint32Array(Rt.buffer),sdf:!1,simplePattern:!1,anchorX:ie,anchorY:Ot,canvas:At}}_renderHalo(Nt,xt,At,dt,Ct,Ut){const $t=this._renderedWidth,st=this._renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=$t,this._haloRasterizationCanvas.height=st;const ft=this._haloRasterizationCanvas,Et=ft.getContext("2d");Et.clearRect(0,0,$t,st),this._setFontProperties(Et,Ut);const{decoration:Q,weight:Jt}=Ut.font;Et.fillStyle=this._haloStyle,Et.strokeStyle=this._haloStyle,Et.lineJoin="round",this._renderHaloNative(Et,xt,At,Q,Jt),Nt.globalAlpha=this._parameters.halo.color[3],Nt.drawImage(ft,0,0,$t,st,dt,Ct,$t,st),Nt.globalAlpha=1}_renderHaloNative(Nt,xt,At,dt,Ct){const Ut=this._renderedLineHeight,$t=this._renderedHaloSize;for(const st of this._textLines){const ft=2*$t,Et=5,Q=.1;for(let Jt=0;Jt<Et;Jt++){const Vt=(1-(Et-1)*Q+Jt*Q)*ft;Nt.lineWidth=Vt,Nt.strokeText(st,xt,At),dt&&"none"!==dt&&this._renderDecoration(Nt,xt,At,dt,Ct,Vt)}At+=Ut}}_setFontProperties(Nt,xt){const At=Math.max(xt.size,.5),dt=xt.font,Ct=`${dt.style} ${dt.weight} ${(0,Wt.F2)(At*xt.pixelRatio).toFixed(1)}px ${dt.family}, sans-serif`;let Ut;switch(Nt.font=Ct,Nt.textBaseline="top",xt.horizontalAlignment){case"left":default:Ut="left";break;case"right":Ut="right";break;case"center":Ut="center"}Nt.textAlign=Ut}computeTextSize(Nt,xt){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const At=this._textRasterizationCanvas,dt=At.getContext("2d");this._setFontProperties(dt,xt),this._parameters=xt,this._textLines=Nt.split(/\r?\n/),this._lineHeight=this._computeLineHeight();const Ct=this._computeTextWidth(dt,xt),Ut=this._lineHeight*this._textLines.length;return At.width=Ct,At.height=Ut,[Ct*xt.pixelRatio,Ut*xt.pixelRatio]}_computeTextWidth(Nt,xt){let At=0;for(const Ct of this._textLines)At=Math.max(At,Nt.measureText(Ct).width);const dt=xt.font;return("italic"===dt.style||"oblique"===dt.style||"string"==typeof dt.weight&&("bold"===dt.weight||"bolder"===dt.weight)||"number"==typeof dt.weight&&dt.weight>600)&&(At+=.3*Nt.measureText("w").width),At+=2*this._parameters.halo.size,Math.round(At)}_computeLineHeight(){let Nt=1.275*this._parameters.size;const xt=this._parameters.font.decoration;return xt&&"underline"===xt&&(Nt*=1.3),Math.round(Nt+2*this._parameters.halo.size)}_renderDecoration(Nt,xt,At,dt,Ct,Ut){const $t=.9*this._lineHeight,st="bold"===Ct?.06:"bolder"===Ct?.09:.04;switch(Nt.textAlign){case"center":xt-=this._renderedWidth/2;break;case"right":xt-=this._renderedWidth}const ft=Nt.textBaseline;if("underline"===dt)switch(ft){case"top":At+=$t;break;case"middle":At+=$t/2}else if("line-through"===dt)switch(ft){case"top":At+=$t/1.5;break;case"middle":At+=$t/3}const Et=Ut?1.5*Ut:Math.ceil($t*st);Nt.save(),Nt.beginPath(),Nt.strokeStyle=Nt.fillStyle,Nt.lineWidth=Et,Nt.moveTo(xt-this._lineThroughWidthOffset,At),Nt.lineTo(xt+this._renderedWidth+2*this._lineThroughWidthOffset,At),Nt.stroke(),Nt.restore()}}},93678:(Pe,re,at)=>{at.d(re,{S:()=>it,c:()=>pt});var Wt=at(15861),gt=at(91558),Ft=at(17002),zt=at(58817),he=at(63290),tt=at(62208),Nt=at(23841),xt=at(77275),At=at(46679),dt=at(35909),Ct=at(7547);const st=new Set(["StartTimeOffset","Duration","RepeatDelay"]);function ft(a,A){return st.has(A)?function $t(a){return.05*Math.max(Math.round(a/.05),1)}(a):a}var Et=at(47139),Q=at(80991),Jt=at(73608),Vt=at(39236),Ht=at(39351);const ot=53290320,St=10,Gt=he.Z.getLogger("esri.symbols.cim.cimAnalyzer");function qt(a){switch(a){case"Butt":return Ct.RL.BUTT;case"Square":return Ct.RL.SQUARE;default:return Ct.RL.ROUND}}function Rt(a){switch(a){case"Bevel":return Ct.AH.BEVEL;case"Miter":return Ct.AH.MITER;default:return Ct.AH.ROUND}}function ie(a,A,F,$){let R;a[A]?R=a[A]:(R={},a[A]=R),R[F]=$}function Ot(a){const A=a.markerPlacement;return A&&A.angleToLine?Ct.v2.MAP:Ct.v2.SCREEN}function pt(a,A,F,$,R){return Mt.apply(this,arguments)}function Mt(){return(Mt=(0,Wt.Z)(function*(a,A,F,$,R){const mt=null!=$?$:[];if(!a)return mt;let nt,rt;const et={};if("CIMSymbolReference"!==a.type)return Gt.error("Expect cim type to be 'CIMSymbolReference'"),mt;if(nt=a.symbol,rt=a.primitiveOverrides,rt){const Lt=[];for(const Xt of rt){const jt=Xt.valueExpressionInfo;if(jt&&A){const ae=(0,At.Yi)(jt.expression,A.spatialReference,A.fields).then(Zt=>{(0,tt.Wi)(Zt)||ie(et,Xt.primitiveName,Xt.propertyName,Zt)});Lt.push(ae)}else null!=Xt.value&&ie(et,Xt.primitiveName,Xt.propertyName,Xt.value)}Lt.length>0&&(yield Promise.all(Lt))}const bt=[];switch(dt.B$.fetchResources(nt,F,bt),bt.length>0&&(yield Promise.all(bt)),null==nt?void 0:nt.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":ut(nt,rt,et,A,mt,F,!!R)}return mt})).apply(this,arguments)}function ut(a,A,F,$,R,mt,nt){var jt;if(!a)return;const rt=a.symbolLayers;if(!rt)return;const et=a.effects;let bt=Ct.v2.SCREEN;const Lt=null!=(jt=dt.B$.getSize(a))?jt:0;"CIMPointSymbol"===a.type&&"Map"===a.angleAlignment&&(bt=Ct.v2.MAP);let Xt=rt.length;for(;Xt--;){const vt=rt[Xt];if(!vt||!1===vt.enable)continue;let ae;et&&et.length&&(ae=[...et]);const Zt=vt.effects;Zt&&Zt.length&&(et?ae.push(...Zt):ae=[...Zt]);const le=[];let ee;dt.E0.findEffectOverrides(ae,A,le),ee=le.length>0?L(ae,le,F,$):ae;const Qt=[];switch(dt.E0.findApplicableOverrides(vt,A,Qt),vt.type){case"CIMSolidFill":Pt(vt,ee,F,Qt,$,R);break;case"CIMPictureFill":wt(vt,ee,F,Qt,$,mt,R);break;case"CIMHatchFill":Dt(vt,ee,F,Qt,$,R);break;case"CIMGradientFill":te(vt,ee,F,Qt,$,R);break;case"CIMSolidStroke":Kt(vt,ee,F,Qt,$,R,"CIMPolygonSymbol"===a.type,Lt);break;case"CIMPictureStroke":ce(vt,ee,F,Qt,$,R,"CIMPolygonSymbol"===a.type,Lt);break;case"CIMGradientStroke":fe(vt,ee,F,Qt,$,R,"CIMPolygonSymbol"===a.type,Lt);break;case"CIMCharacterMarker":if(It(vt,ee,F,Qt,$,R))break;break;case"CIMPictureMarker":if(It(vt,ee,F,Qt,$,R))break;"CIMLineSymbol"===a.type&&(bt=Ot(vt)),y(vt,ee,F,Qt,$,mt,R,bt,Lt);break;case"CIMVectorMarker":if(It(vt,ee,F,Qt,$,R))break;"CIMLineSymbol"===a.type&&(bt=Ot(vt)),k(vt,ee,F,Qt,$,R,mt,bt,Lt,nt);break;default:Gt.error("Cannot analyze CIM layer",vt.type)}}}function Pt(a,A,F,$,R,mt){const nt=a.primitiveName,rt=(0,Q.NO)(a.color),[et,bt]=ht($,nt,A,null,null),Lt=(0,xt.hP)(JSON.stringify(a)+bt).toString();mt.push({type:"fill",templateHash:Lt,materialHash:et?()=>Lt:Lt,cim:a,materialOverrides:null,colorLocked:!!a.colorLocked,color:T(nt,F,"Color",R,rt,Tt),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:A,applyRandomOffset:!1,sampleAlphaOnly:!0})}function wt(a,A,F,$,R,mt,nt){const rt=a.primitiveName,et=(0,Q.cO)(a),[bt,Lt]=ht($,rt,A,null,null),Xt=(0,xt.hP)(JSON.stringify(a)+Lt).toString(),jt=(0,xt.hP)(`${a.url}${JSON.stringify(a.colorSubstitutions)}`).toString();let vt=(0,Q.NA)(a.scaleX);if("width"in a&&"number"==typeof a.width){const ae=a.width;let Zt=1;const le=mt.getResource(a.url);(0,tt.pC)(le)&&(Zt=le.width/le.height),vt/=Zt*(a.height/ae)}nt.push({type:"fill",templateHash:Xt,materialHash:bt?()=>jt:jt,cim:a,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,color:T(rt,F,"TintColor",R,et,Tt),height:T(rt,F,"Height",R,a.height),scaleX:T(rt,F,"ScaleX",R,vt),angle:T(rt,F,"Rotation",R,(0,Q.NA)(a.rotation)),offsetX:T(rt,F,"OffsetX",R,(0,Q.NA)(a.offsetX)),offsetY:T(rt,F,"OffsetY",R,(0,Q.NA)(a.offsetY)),url:a.url,applyRandomOffset:!1,sampleAlphaOnly:!1})}function Dt(a,A,F,$,R,mt){var le,ee;const nt=["Rotation","OffsetX","OffsetY"],rt=$.filter(Qt=>Qt.primitiveName!==a.primitiveName||!nt.includes(Qt.propertyName)),et=a.primitiveName;let[bt,Lt]=ht($,et,A,null,null);const Xt=(0,xt.hP)(JSON.stringify(a)+Lt).toString(),jt=(0,xt.hP)(`${a.separation}${JSON.stringify(a.lineSymbol)}`).toString();let vt={r:255,g:255,b:255,a:1},ae=!1;const Zt=null==(ee=null==(le=a.lineSymbol)?void 0:le.symbolLayers)?void 0:ee.find(Qt=>{var Me;return"CIMSolidStroke"===Qt.type&&null!=(null==(Me=F[Qt.primitiveName])?void 0:Me.Color)});if(Zt){vt=(0,Q.NO)(Zt.color),vt=T(Zt.primitiveName,F,"Color",R,vt,Tt);const Qt="function"==typeof vt;bt=bt||Qt,ae=null!=Zt.color||Qt}mt.push({type:"fill",templateHash:Xt,materialHash:bt?U(jt,F,rt,R):jt,cim:a,materialOverrides:rt,colorLocked:!!a.colorLocked,effects:A,color:vt,height:T(et,F,"Separation",R,a.separation),scaleX:1,angle:T(et,F,"Rotation",R,(0,Q.NA)(a.rotation)),offsetX:T(et,F,"OffsetX",R,(0,Q.NA)(a.offsetX)),offsetY:T(et,F,"OffsetY",R,(0,Q.NA)(a.offsetY)),applyRandomOffset:!1,sampleAlphaOnly:!0,hasUnresolvedReplacementColor:!ae})}function te(a,A,F,$,R,mt){const nt=a.primitiveName,[rt,et]=ht($,nt,A,null,null),bt=(0,xt.hP)(JSON.stringify(a)+et).toString();mt.push({type:"fill",templateHash:bt,materialHash:rt?U(bt,F,$,R):bt,cim:a,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,applyRandomOffset:!1,sampleAlphaOnly:!1})}function Kt(a,A,F,$,R,mt,nt,rt){const et=a.primitiveName,bt=(0,Q.NO)(a.color),Lt=null!=a.width?a.width:4,Xt=qt(a.capStyle),jt=Rt(a.joinStyle),vt=a.miterLimit,[ae,Zt]=ht($,et,A,null,null),le=(0,xt.hP)(JSON.stringify(a)+Zt).toString();let ee,Qt;if(A&&A instanceof Array&&A.length>0){const Me=A[A.length-1];if("CIMGeometricEffectDashes"===Me.type&&"NoConstraint"===Me.lineDashEnding&&null===Me.offsetAlongLine){const pe=(A=[...A]).pop();ee=pe.dashTemplate,Qt=pe.scaleDash}}mt.push({type:"line",templateHash:le,materialHash:ae?()=>le:le,cim:a,materialOverrides:null,isOutline:nt,colorLocked:!!a.colorLocked,effects:A,color:T(et,F,"Color",R,bt,Tt),width:T(et,F,"Width",R,Lt),cap:T(et,F,"CapStyle",R,Xt),join:T(et,F,"JoinStyle",R,jt),miterLimit:vt&&T(et,F,"MiterLimit",R,vt),referenceWidth:rt,zOrder:yt(a.name),dashTemplate:ee,scaleDash:Qt,sampleAlphaOnly:!0})}function ce(a,A,F,$,R,mt,nt,rt){const et=(0,xt.hP)(`${a.url}${JSON.stringify(a.colorSubstitutions)}`).toString(),bt=a.primitiveName,Lt=(0,Q.cO)(a),Xt=null!=a.width?a.width:4,jt=qt(a.capStyle),vt=Rt(a.joinStyle),ae=a.miterLimit,[Zt,le]=ht($,bt,A,null,null),ee=(0,xt.hP)(JSON.stringify(a)+le).toString();mt.push({type:"line",templateHash:ee,materialHash:Zt?()=>et:et,cim:a,materialOverrides:null,isOutline:nt,colorLocked:!!a.colorLocked,effects:A,color:T(bt,F,"TintColor",R,Lt,Tt),width:T(bt,F,"Width",R,Xt),cap:T(bt,F,"CapStyle",R,jt),join:T(bt,F,"JoinStyle",R,vt),miterLimit:ae&&T(bt,F,"MiterLimit",R,ae),referenceWidth:rt,zOrder:yt(a.name),dashTemplate:null,scaleDash:!1,url:a.url,sampleAlphaOnly:!1})}function fe(a,A,F,$,R,mt,nt,rt){const et=a.primitiveName,bt=null!=a.width?a.width:4,Lt=qt(a.capStyle),Xt=Rt(a.joinStyle),jt=a.miterLimit,[vt,ae]=ht($,et,A,null,null),Zt=(0,xt.hP)(JSON.stringify(a)+ae).toString();mt.push({type:"line",templateHash:Zt,materialHash:vt?U(Zt,F,$,R):Zt,cim:a,materialOverrides:null,isOutline:nt,colorLocked:!!a.colorLocked,effects:A,color:{r:128,g:128,b:128,a:1},width:T(et,F,"Width",R,bt),cap:T(et,F,"CapStyle",R,Lt),join:T(et,F,"JoinStyle",R,Xt),miterLimit:jt&&T(et,F,"MiterLimit",R,jt),referenceWidth:rt,zOrder:yt(a.name),dashTemplate:null,scaleDash:!1,sampleAlphaOnly:!1})}function It(a,A,F,$,R,mt){const{markerPlacement:nt,type:rt}=a;if(!nt||"CIMMarkerPlacementInsidePolygon"!==nt.type)return!1;if("CIMVectorMarker"===rt||"CIMPictureMarker"===rt){const me=a.primitiveName;if(me){const[de,ve]=ht($,me,A,null,null);if(de)return!1}const we=nt.primitiveName;if(we){const[de,ve]=ht($,we,A,null,null);if(de)return!1}if("CIMVectorMarker"===rt){const{markerGraphics:de}=a;if(de)for(const ve of de){const{symbol:Se}=ve;if("CIMPolygonSymbol"===(null==Se?void 0:Se.type)&&Se.symbolLayers){const{symbolLayers:_e}=Se;for(const ge of _e)if("CIMSolidStroke"===ge.type)return!1}}}else{const{animatedSymbolProperties:de}=a;if(de)return!1}}const et=nt,bt=Math.abs(et.stepX),Lt=Math.abs(et.stepY);if(0===bt||0===Lt)return!0;const Xt=["Rotation","OffsetX","OffsetY"],jt=$.filter(me=>me.primitiveName!==a.primitiveName||!Xt.includes(me.propertyName)),vt="url"in a&&"string"==typeof a.url?a.url:void 0,[ae,Zt]=ht($,et.primitiveName,A,null,null),le=(0,xt.hP)(JSON.stringify(a)+Zt).toString();let ee,Qt,Me=null;if("Random"===nt.gridType){const me=(0,Nt.Wz)(Ht.C1),we=Math.max(Math.floor(me/bt),1),de=Math.max(Math.floor(me/Lt),1);ee=Lt*de,Me=ve=>ve?ve*de:0,Qt=we*bt/ee}else nt.shiftOddRows?(ee=2*Lt,Me=me=>me?2*me:0,Qt=bt/Lt*.5):(ee=Lt,Me=null,Qt=bt/Lt);const pe=(0,Q.cO)(a);return mt.push({type:"fill",templateHash:le,materialHash:ae?U(le,F,jt,R):le,cim:a,materialOverrides:jt,colorLocked:!!a.colorLocked,effects:A,color:T(et.primitiveName,F,"TintColor",R,pe,Tt),height:T(et.primitiveName,F,"StepY",R,ee,Me),scaleX:Qt,angle:T(et.primitiveName,F,"GridAngle",R,et.gridAngle),offsetX:T(et.primitiveName,F,"OffsetX",R,(0,Q.NA)(et.offsetX)),offsetY:T(et.primitiveName,F,"OffsetY",R,(0,Q.NA)(et.offsetY)),url:vt,applyRandomOffset:"Random"===nt.gridType,sampleAlphaOnly:!vt,hasUnresolvedReplacementColor:!0}),!0}function y(a,A,F,$,R,mt,nt,rt,et){var Se;const bt=a.primitiveName,Lt=(0,Q.NA)(a.size);let Xt=(0,Q.NA)(a.scaleX,1);const jt=(0,Q.NA)(a.rotation),vt=(0,Q.NA)(a.offsetX),ae=(0,Q.NA)(a.offsetY),Zt=(0,Q.cO)(a),le=(0,xt.hP)(`${a.url}${JSON.stringify(a.colorSubstitutions)}${JSON.stringify(a.animatedSymbolProperties)}`).toString(),ee=O(a.markerPlacement,$,F,R),Qt=function J(a,A,F,$){const R=[];if(dt.E0.findApplicableOverrides(a,A,R),null==a||0===R.length)return a;for(const mt of R)if(mt.valueExpressionInfo&&(null==$?void 0:$.geometryType)){const nt=F[mt.primitiveName]&&F[mt.primitiveName][mt.propertyName];nt instanceof At.mz&&(mt.fn=(rt,et,bt)=>(0,Vt.Z)(nt,rt,{$view:bt},$.geometryType,et))}return(mt,nt,rt)=>{for(const Lt of R)Lt.fn&&(Lt.value=Lt.fn(mt,nt,rt));const et=(0,zt.d9)(a),bt=a.primitiveName;for(const Lt of R)if(Lt.primitiveName===bt){const Xt=S(Lt.propertyName);if(null!=Lt.value){const jt=ft(Lt.value,Lt.propertyName);jt!==et[Xt]&&(et[Xt]=jt)}}return et}}(a.animatedSymbolProperties,$,F,R),[Me,pe]=ht($,bt,A,ee,Qt),me=(0,xt.hP)(JSON.stringify(a)+pe).toString(),we=null!=(Se=a.anchorPoint)?Se:{x:0,y:0};if("width"in a&&"number"==typeof a.width){const _e=a.width;let ge=1;const ke=mt.getResource(a.url);(0,tt.pC)(ke)&&(ge=ke.width/ke.height),Xt/=ge*(Lt/_e)}function de(_e,ge){return(0,tt.pC)(Qt)?(0,Q.hf)(Qt,_e,ge):null}nt.push({type:"marker",templateHash:me,materialHash:a.animatedSymbolProperties&&!0===a.animatedSymbolProperties.randomizeStartTime?(_e,ge,ke,Le)=>{const Oe=function ue(a){return Math.floor(function oe(a,A){let F;if("string"==typeof a)F=(0,xt.hP)(a+`-seed(${A})`);else{let $=12;F=a^A;do{F=107*(F>>8^F)+$|0}while(0!=--$)}return(1+F/(1<<31))/2}(a,ot)*St)}(null!=Le?Le:0),De=de(_e,ge);return le+`-MATERIALGROUP(${Oe})-ASP(${JSON.stringify(De)})`}:Me?(_e,ge)=>{const ke=de(_e,ge);return le+`-ASP(${JSON.stringify(ke)})`}:le,cim:a,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,scaleSymbolsProportionally:!1,alignment:rt,size:T(bt,F,"Size",R,Lt),scaleX:T(bt,F,"ScaleX",R,Xt),rotation:T(bt,F,"Rotation",R,jt),offsetX:T(bt,F,"OffsetX",R,vt),offsetY:T(bt,F,"OffsetY",R,ae),color:T(bt,F,"TintColor",R,Zt,Tt),anchorPoint:{x:we.x,y:-we.y},isAbsoluteAnchorPoint:"Relative"!==a.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:!!a.rotateClockwise,referenceSize:et,sizeRatio:1,markerPlacement:ee,url:a.url,animatedSymbolProperties:Qt})}function k(a,A,F,$,R,mt,nt,rt,et,bt){const Lt=a.markerGraphics;if(!Lt)return;let Xt=0;if(a.scaleSymbolsProportionally){const vt=a.frame;vt&&(Xt=vt.ymax-vt.ymin)}const jt=O(a.markerPlacement,$,F,R);for(const vt of Lt)if(vt){const ae=vt.symbol;if(!ae)continue;switch(ae.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":N(a,A,jt,null,vt,$,F,R,mt,nt,rt,et,Xt,!!bt);break;case"CIMTextSymbol":W(a,A,jt,vt,F,$,R,mt,rt,et,Xt)}}}function W(a,A,F,$,R,mt,nt,rt,et,bt,Lt){var We,Ye;dt.E0.findApplicableOverrides($,mt,[]);const jt=$.geometry;if(!("x"in jt)||!("y"in jt))return;const vt=$.symbol,ae=(0,Q.BX)(vt),Zt=(0,Q.wi)(vt.fontStyleName),le=(0,Ft.BN)(vt.fontFamilyName);vt.font=Ve({family:le,decoration:ae},Zt);const ee=a.frame,Qt=jt.x-.5*(ee.xmin+ee.xmax),Me=jt.y-.5*(ee.ymin+ee.ymax),pe=a.size/Lt,me=a.primitiveName,we=(0,Q.NA)(vt.height)*pe,de=(0,Q.NA)(vt.angle),ve=(0,Q.NA)(a.offsetX)+((0,Q.NA)(vt.offsetX)+Qt)*pe,Se=(0,Q.NA)(a.offsetY)+((0,Q.NA)(vt.offsetY)+Me)*pe,_e=(0,Q.NO)((0,Q.W7)(vt));let ge=(0,Q.NO)((0,Q.$Z)(vt)),ke=null!=(We=(0,Q.F)(vt))?We:0;ke||(ge=(0,Q.NO)((0,Q.W7)(vt.haloSymbol)),vt.haloSize&&(ke=vt.haloSize*pe));let Le=null,Oe=null,De=0;if(vt.callout&&"CIMBackgroundCallout"===vt.callout.type){const Ue=vt.callout;if(Ue.backgroundSymbol){const Be=Ue.backgroundSymbol.symbolLayers;if(Be)for(const Ae of Be)"CIMSolidFill"===Ae.type?Le=(0,Q.NO)(Ae.color):"CIMSolidStroke"===Ae.type&&(Oe=(0,Q.NO)(Ae.color),De=(0,Q.NA)(Ae.width))}}const[Xe,Ge]=ht(mt,me,A,F,null),Ie=JSON.stringify(a.effects)+Number(a.colorLocked).toString()+JSON.stringify(a.anchorPoint)+a.anchorPointUnits+JSON.stringify(a.markerPlacement)+a.size.toString(),Re=(0,xt.hP)(JSON.stringify($)+Ie+Ge).toString();let be=T($.primitiveName,R,"TextString",nt,null!=(Ye=$.textString)?Ye:"",Q.QI,vt.textCase);if(null==be)return;const{fontStyleName:He}=vt,ze=le+(He?"-"+He.toLowerCase():"-regular"),Ee=ze;"string"==typeof be&&be.includes("[")&&vt.fieldMap&&(be=(0,Q.Qs)(vt.fieldMap,be,vt.textCase)),rt.push({type:"text",templateHash:Re,materialHash:Xe||"function"==typeof be||be.match(/\[(.*?)\]/)?(Ue,Be,Ae)=>Ee+"-"+(0,Q.hf)(be,Ue,Be,Ae):Ee+"-"+(0,xt.hP)(be),cim:vt,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,alignment:et,anchorPoint:{x:a.anchorPoint?a.anchorPoint.x:0,y:a.anchorPoint?a.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==a.anchorPointUnits,fontName:ze,decoration:ae,weight:T(me,R,"Weight",nt,Zt.weight),style:T(me,R,"Size",nt,Zt.style),size:T(me,R,"Size",nt,we),angle:T(me,R,"Rotation",nt,de),offsetX:T(me,R,"OffsetX",nt,ve),offsetY:T(me,R,"OffsetY",nt,Se),horizontalAlignment:(0,Q.X_)(vt.horizontalAlignment),verticalAlignment:(0,Q.FG)(vt.verticalAlignment),text:be,color:_e,outlineColor:ge,outlineSize:ke,backgroundColor:Le,borderLineColor:Oe,borderLineWidth:De,referenceSize:bt,sizeRatio:1,markerPlacement:F})}function N(a,A,F,$,R,mt,nt,rt,et,bt,Lt,Xt,jt,vt){var Qt,Me;const ae=R.symbol,Zt=ae.symbolLayers;if(!Zt)return;if(vt)return void ct(a,A,F,$,R,nt,mt,rt,et,bt,Lt,Xt,jt);let le=Zt.length;if(Y(Zt))return void function j(a,A,F,$,R,mt,nt,rt,et,bt,Lt,Xt,jt){var ze;const vt=R.geometry,ae=mt[0],Zt=mt[1],le=(0,Et.bk)(vt);if(!le)return;const ee="Relative"!==a.anchorPointUnits,[Qt,Me,pe]=(0,Et.UV)(le,a.frame,a.size,a.anchorPoint,ee),me={type:"sdf",geom:vt,asFill:!0},we=a.primitiveName,de=(0,Q.NA)(a.size),ve=(0,Q.NA)(a.rotation),Se=(0,Q.NA)(a.offsetX),_e=(0,Q.NA)(a.offsetY),ge=Zt.path,ke=Zt.primitiveName,Le=ae.primitiveName,Oe=(0,Q.NO)((0,Q.W7)(Zt)),De=(0,Q.NO)((0,Q.$Z)(ae)),Xe=null!=(ze=(0,Q.F)(ae))?ze:0;let Ge=!1,Ie="";for(const Ee of nt)Ee.primitiveName!==ke&&Ee.primitiveName!==Le&&Ee.primitiveName!==we||(void 0!==Ee.value?Ie+=`-${Ee.primitiveName}-${Ee.propertyName}-${JSON.stringify(Ee.value)}`:Ee.valueExpressionInfo&&(Ge=!0));(0,tt.pC)(F)&&"function"==typeof F&&(Ge=!0);const Re=JSON.stringify(Je(Ve({},a),{markerGraphics:null})),be=(0,xt.hP)(JSON.stringify(me)+ge).toString(),He={type:"marker",templateHash:(0,xt.hP)(JSON.stringify(R)+JSON.stringify(Zt)+JSON.stringify(ae)+Re+Ie).toString(),materialHash:Ge?()=>be:be,cim:me,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,scaleSymbolsProportionally:!!a.scaleSymbolsProportionally,alignment:Lt,anchorPoint:{x:Me,y:pe},isAbsoluteAnchorPoint:ee,size:T(a.primitiveName,rt,"Size",et,de),rotation:T(a.primitiveName,rt,"Rotation",et,ve),offsetX:T(a.primitiveName,rt,"OffsetX",et,Se),offsetY:T(a.primitiveName,rt,"OffsetY",et,_e),scaleX:1,frameHeight:jt,rotateClockwise:!!a.rotateClockwise,referenceSize:Xt,sizeRatio:Qt,color:T(ke,rt,"Color",et,Oe,Tt),outlineColor:T(Le,rt,"Color",et,De,Tt),outlineWidth:T(Le,rt,"Width",et,Xe),markerPlacement:F,path:ge,animatedSymbolProperties:$};bt.push(He)}(a,A,F,$,R,Zt,mt,nt,rt,et,Lt,Xt,jt);const ee=Jt.j.applyEffects(ae.effects,R.geometry,bt.geometryEngine);if(ee)for(;le--;){const pe=Zt[le];if(pe&&!1!==pe.enable)switch(pe.type){case"CIMSolidFill":case"CIMSolidStroke":{const me=Jt.j.applyEffects(pe.effects,ee,bt.geometryEngine),we=(0,Et.bk)(me);if(!we)continue;const de="Relative"!==a.anchorPointUnits,[ve,Se,_e]=(0,Et.UV)(we,a.frame,a.size,a.anchorPoint,de),ge="CIMSolidFill"===pe.type,ke={type:"sdf",geom:me,asFill:ge},Le=a.primitiveName,Oe=null!=(Qt=(0,Q.NA)(a.size))?Qt:10,De=(0,Q.NA)(a.rotation),Xe=(0,Q.NA)(a.offsetX),Ge=(0,Q.NA)(a.offsetY),Ie=pe.path,Re=pe.primitiveName,be=(0,Q.NO)(ge?(0,Q.W7)(pe):(0,Q.$Z)(pe)),He=ge?{r:0,g:0,b:0,a:0}:(0,Q.NO)((0,Q.$Z)(pe)),ze=null!=(Me=(0,Q.F)(pe))?Me:0;if(!ge&&!ze)break;let Ee=!1,We="";for(const Ae of mt)Ae.primitiveName!==Re&&Ae.primitiveName!==Le||(void 0!==Ae.value?We+=`-${Ae.primitiveName}-${Ae.propertyName}-${JSON.stringify(Ae.value)}`:Ae.valueExpressionInfo&&(Ee=!0));((0,tt.pC)(A)&&"function"==typeof A||(0,tt.pC)(F)&&"function"==typeof F)&&(Ee=!0);const Ye=JSON.stringify(Je(Ve({},a),{markerGraphics:null})),Ue=(0,xt.hP)(JSON.stringify(ke)+Ie).toString(),Be={type:"marker",templateHash:(0,xt.hP)(JSON.stringify(R)+JSON.stringify(pe)+Ye+We).toString(),materialHash:Ee?()=>Ue:Ue,cim:ke,materialOverrides:null,colorLocked:!!a.colorLocked,effects:A,scaleSymbolsProportionally:!!a.scaleSymbolsProportionally,alignment:Lt,anchorPoint:{x:Se,y:_e},isAbsoluteAnchorPoint:de,size:T(a.primitiveName,nt,"Size",rt,Oe),rotation:T(a.primitiveName,nt,"Rotation",rt,De),offsetX:T(a.primitiveName,nt,"OffsetX",rt,Xe),offsetY:T(a.primitiveName,nt,"OffsetY",rt,Ge),scaleX:1,frameHeight:jt,rotateClockwise:!!a.rotateClockwise,referenceSize:Xt,sizeRatio:ve,color:T(Re,nt,"Color",rt,be,Tt),outlineColor:T(Re,nt,"Color",rt,He,Tt),outlineWidth:T(Re,nt,"Width",rt,ze),markerPlacement:F,animatedSymbolProperties:$,path:Ie};et.push(Be);break}default:ct(a,A,F,$,R,nt,mt,rt,et,bt,Lt,Xt,jt)}}}function ct(a,A,F,$,R,mt,nt,rt,et,bt,Lt,Xt,jt){const vt=function Z(a,A){return{type:a.type,enable:!0,name:a.name,colorLocked:a.colorLocked,primitiveName:a.primitiveName,anchorPoint:a.anchorPoint,anchorPointUnits:a.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:a.rotateClockwise,rotation:0,size:a.size,billboardMode3D:a.billboardMode3D,depth3D:a.depth3D,frame:a.frame,markerGraphics:[A],scaleSymbolsProportionally:a.scaleSymbolsProportionally,respectFrame:a.respectFrame,clippingPath:a.clippingPath}}(a,R),ae=["Rotation","OffsetX","OffsetY"],Zt=nt.filter(_e=>_e.primitiveName!==a.primitiveName||!ae.includes(_e.propertyName));let le="";for(const _e of nt)void 0!==_e.value&&(le+=`-${_e.primitiveName}-${_e.propertyName}-${JSON.stringify(_e.value)}`);const[ee,Qt,Me]=dt.B$.getTextureAnchor(vt,bt),pe=a.primitiveName,me=(0,Q.NA)(a.rotation),we=(0,Q.NA)(a.offsetX),de=(0,Q.NA)(a.offsetY),ve=(0,xt.hP)(JSON.stringify(vt)+le).toString(),Se={type:"marker",templateHash:ve,materialHash:Zt.length>0||(0,tt.pC)(A)&&"function"==typeof A?U(ve,mt,Zt,rt):ve,cim:vt,materialOverrides:Zt,colorLocked:!!a.colorLocked,effects:A,scaleSymbolsProportionally:!!a.scaleSymbolsProportionally,alignment:Lt,anchorPoint:{x:ee,y:Qt},isAbsoluteAnchorPoint:!1,size:(0,Q.NA)(a.size),rotation:T(pe,mt,"Rotation",rt,me),offsetX:T(pe,mt,"OffsetX",rt,we),offsetY:T(pe,mt,"OffsetY",rt,de),color:{r:255,g:255,b:255,a:1},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:jt,rotateClockwise:!!a.rotateClockwise,referenceSize:Xt,sizeRatio:Me/(0,Nt.F2)(a.size),markerPlacement:F,animatedSymbolProperties:$,avoidSDFRasterization:!0};et.push(Se)}function yt(a){if(a&&0===a.indexOf("Level_")){const A=parseInt(a.substr(6),10);if(!isNaN(A))return A}return 0}function Tt(a){if(!a||0===a.length)return null;const A=new gt.Z(a).toRgba();return{r:A[0],g:A[1],b:A[2],a:A[3]}}function T(a,A,F,$,R,mt,nt){if(null==a)return R;const rt=A[a];if(rt){const et=rt[F];if("string"==typeof et||"number"==typeof et||et instanceof Array)return mt?mt.call(null,et,nt):et;if(null!=et&&et instanceof At.mz&&(null==$?void 0:$.geometryType))return(bt,Lt,Xt)=>{let jt=(0,Vt.Z)(et,bt,{$view:Xt},$.geometryType,Lt);return null!==jt&&mt&&(jt=mt.call(null,jt,nt)),null!==jt?jt:R}}return R}function S(a){return a&&a.charAt(0).toLowerCase()+a.substr(1)}function L(a,A,F,$){for(const R of A)if(R.valueExpressionInfo&&(null==$?void 0:$.geometryType)){const mt=F[R.primitiveName]&&F[R.primitiveName][R.propertyName];mt instanceof At.mz&&(R.fn=(nt,rt,et)=>(0,Vt.Z)(mt,nt,{$view:et},$.geometryType,rt))}return(R,mt,nt)=>{for(const et of A)et.fn&&(et.value=et.fn(R,mt,nt));const rt=[];for(let et of a){const bt=null==et?void 0:et.primitiveName;if(bt){let Lt=!1;for(const Xt of A)if(Xt.primitiveName===bt){const jt=S(Xt.propertyName);null!=Xt.value&&Xt.value!==et[jt]&&(Lt||(et=(0,zt.d9)(et),Lt=!0),et[jt]=Xt.value)}}rt.push(et)}return rt}}function O(a,A,F,$){const R=[];if(dt.E0.findApplicableOverrides(a,A,R),null==a||0===R.length)return a;for(const mt of R)if(mt.valueExpressionInfo&&(null==$?void 0:$.geometryType)){const nt=F[mt.primitiveName]&&F[mt.primitiveName][mt.propertyName];nt instanceof At.mz&&(mt.fn=(rt,et,bt)=>(0,Vt.Z)(nt,rt,{$view:bt},$.geometryType,et))}return(mt,nt,rt)=>{for(const Lt of R)Lt.fn&&(Lt.value=Lt.fn(mt,nt,rt));const et=(0,zt.d9)(a),bt=a.primitiveName;for(const Lt of R)if(Lt.primitiveName===bt){const Xt=S(Lt.propertyName);null!=Lt.value&&Lt.value!==et[Xt]&&(et[Xt]=Lt.value)}return et}}function U(a,A,F,$){for(const R of F)if(R.valueExpressionInfo&&(null==$?void 0:$.geometryType)){const mt=A[R.primitiveName]&&A[R.primitiveName][R.propertyName];mt instanceof At.mz&&(R.fn=(nt,rt,et)=>(0,Vt.Z)(mt,nt,{$view:et},$.geometryType,rt))}return(R,mt,nt)=>{for(const rt of F)rt.fn&&(rt.value=rt.fn(R,mt,nt));return(0,xt.hP)(a+dt.E0.buildOverrideKey(F)).toString()}}function it(a,A){if(!A||0===A.length)return a;const F=(0,zt.d9)(a);return dt.E0.applyOverrides(F,A),F}function ht(a,A,F,$,R){let mt=!1,nt="";for(const rt of a)rt.primitiveName===A&&(void 0!==rt.value?nt+=`-${rt.primitiveName}-${rt.propertyName}-${JSON.stringify(rt.value)}`:rt.valueExpressionInfo&&(mt=!0));return(0,tt.pC)(F)&&"function"==typeof F&&(mt=!0),(0,tt.pC)($)&&"function"==typeof $&&(mt=!0),(0,tt.pC)(R)&&"function"==typeof R&&(mt=!0),[mt,nt]}const Y=a=>a&&2===a.length&&a[0].enable&&a[1].enable&&"CIMSolidStroke"===a[0].type&&"CIMSolidFill"===a[1].type&&!a[0].effects&&!a[1].effects},73608:(Pe,re,at)=>{at.d(re,{j:()=>tt});var Wt=at(91179),gt=at(72283),Ft=at(29214),zt=at(95727);class tt{static executeEffects(xt,At,dt,Ct){const Ut=(0,gt.GP)(At);let st=new Ft.MU(Ut);for(const ft of xt){const Et=(0,zt.h)(ft);Et&&(st=Et.execute(st,ft,1.3333333333333333,dt,Ct))}return st}static next(xt){const At=xt.next();return(0,gt.wp)(At),At}static applyEffects(xt,At,dt){if(!xt)return At;let Ct=new Ft.MU(At);for(const st of xt){const ft=(0,zt.h)(st);ft&&(Ct=ft.execute(Ct,st,1,null,dt))}let Ut,$t=null;for(;Ut=Ct.next();)$t?(0,Wt.l9)($t)?(0,Wt.l9)(Ut)&&$t.paths.push(...Ut.paths):(0,Wt.oU)($t)&&(0,Wt.oU)(Ut)&&$t.rings.push(...Ut.rings):$t=Ut;return $t}}},40028:(Pe,re,at)=>{var Wt,gt,dt;function Ft(dt){switch(dt){case"left":return Wt.Left;case"right":return Wt.Right;case"center":return Wt.Center}}function zt(dt){switch(dt){case"top":return gt.Top;case"middle":return gt.Center;case"baseline":return gt.Baseline;case"bottom":return gt.Bottom}}function he(dt){switch(dt){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return[Wt.Right,gt.Bottom];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return[Wt.Center,gt.Bottom];case"above-right":case"esriServerPointLabelPlacementAboveRight":return[Wt.Left,gt.Bottom];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return[Wt.Right,gt.Center];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return[Wt.Center,gt.Center];case"center-right":case"esriServerPointLabelPlacementCenterRight":return[Wt.Left,gt.Center];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return[Wt.Right,gt.Top];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return[Wt.Center,gt.Top];case"below-right":case"esriServerPointLabelPlacementBelowRight":return[Wt.Left,gt.Top];default:return console.debug(`Found invalid placement type ${dt}`),[Wt.Center,gt.Center]}}function tt(dt){switch(dt){case Wt.Right:return-1;case Wt.Center:return 0;case Wt.Left:return 1;default:return console.debug(`Found invalid horizontal alignment ${dt}`),0}}function Nt(dt){switch(dt){case gt.Top:return 1;case gt.Center:return 0;case gt.Bottom:case gt.Baseline:return-1;default:return console.debug(`Found invalid vertical alignment ${dt}`),0}}function xt(dt){switch(dt){case"left":return Wt.Left;case"right":return Wt.Right;case"center":return Wt.Center}}function At(dt){switch(dt){case"above-along":case"below-along":case"center-along":case"esriServerLinePlacementAboveAlong":case"esriServerLinePlacementBelowAlong":case"esriServerLinePlacementCenterAlong":return!0;default:return!1}}at.d(re,{Hd:()=>xt,NS:()=>At,TR:()=>gt,b7:()=>zt,g:()=>tt,kH:()=>Ft,qv:()=>he,tf:()=>Nt}),(dt=Wt||(Wt={}))[dt.Left=-1]="Left",dt[dt.Center=0]="Center",dt[dt.Right=1]="Right",function(dt){dt[dt.Top=1]="Top",dt[dt.Center=0]="Center",dt[dt.Bottom=-1]="Bottom",dt[dt.Baseline=2]="Baseline"}(gt||(gt={}))},25797:(Pe,re,at)=>{at.d(re,{Nr:()=>ie});var Wt=at(23841),gt=at(31478),Ft=at(12225),zt=at(67831),he=at(9545),tt=at(40028),Nt=at(5254),xt=at(84439);class At{constructor(pt,Mt,ut,Pt){this.center=(0,he.f)(pt,Mt),this.centerT=(0,he.c)(),this.halfWidth=ut/2,this.halfHeight=Pt/2,this.width=ut,this.height=Pt}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(pt){this.center[0]=pt}set y(pt){this.center[1]=pt}clone(){return new At(this.x,this.y,this.width,this.height)}serialize(pt){return pt.writeF32(this.center[0]),pt.writeF32(this.center[1]),pt.push(this.width),pt.push(this.height),pt}findCollisionDelta(pt,Mt=4){const ut=Math.abs(pt.centerT[0]-this.centerT[0]),Pt=Math.abs(pt.centerT[1]-this.centerT[1]),te=Math.min((pt.halfWidth+this.halfWidth+Mt)/ut,(pt.halfHeight+this.halfHeight+Mt)/Pt);return Math.log2(te)}extend(pt){const Mt=Math.min(this.xmin,pt.xmin),ut=Math.min(this.ymin,pt.ymin),Pt=Math.max(this.xmax,pt.xmax)-Mt,wt=Math.max(this.ymax,pt.ymax)-ut,Dt=Mt+Pt/2,te=ut+wt/2;this.width=Pt,this.height=wt,this.halfWidth=Pt/2,this.halfHeight=wt/2,this.x=Dt,this.y=te}static deserialize(pt){const Mt=pt.readF32(),ut=pt.readF32(),Pt=pt.readInt32(),wt=pt.readInt32();return new At(Mt,ut,Pt,wt)}}const Et=Math.PI/180;class Vt{constructor(pt,Mt,ut,Pt){this._rotationT=(0,Ft.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const wt=ut.rect,Dt=new Float32Array(8);pt*=Pt,Mt*=Pt;const te=ut.code?wt.width*Pt:ut.metrics.width,Kt=ut.code?wt.height*Pt:ut.metrics.height;this.width=te,this.height=Kt,Dt[0]=pt,Dt[1]=Mt,Dt[2]=pt+te,Dt[3]=Mt,Dt[4]=pt,Dt[5]=Mt+Kt,Dt[6]=pt+te,Dt[7]=Mt+Kt,this._data=Dt,this._setTextureCoords(wt),this._scale=Pt,this._mosaic=ut,this.x=pt,this.y=Mt,this.maxOffset=Math.max(pt+te,Mt+Kt)}get mosaic(){return this._mosaic}set angle(pt){this._angle=pt,(0,gt.b)(this._rotationT,-pt),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:pt,width:Mt}=this._mosaic.metrics,ut=Mt*this._scale,Pt=Math.abs(pt)*this._scale,wt=new Float32Array(8);wt[0]=this.x,wt[1]=this.y,wt[2]=this.x+ut,wt[3]=this.y,wt[4]=this.x,wt[5]=this.y+Pt,wt[6]=this.x+ut,wt[7]=this.y+Pt;const Dt=(0,gt.m)((0,Ft.c)(),this._rotationT,this._transform);(0,Ft.t)(wt,wt,Dt);let te=1/0,Kt=1/0,ce=0,fe=0;for(let N=0;N<4;N++){const j=wt[2*N],ct=wt[2*N+1];te=Math.min(te,j),Kt=Math.min(Kt,ct),ce=Math.max(ce,j),fe=Math.max(fe,ct)}const It=ce-te,y=fe-Kt;this._bounds=new At(te+It/2,Kt+y/2,It,y)}return this._bounds}setTransform(pt){this._transform=pt,this._offsets=null}_setOffsets(pt){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const Mt=this._offsets,ut=new Float32Array(8),Pt=(0,gt.m)((0,Ft.c)(),this._rotationT,this._transform);(0,Ft.t)(ut,pt,Pt),Mt.upperLeft=(0,Nt.UJ)(8*ut[0],8*ut[1]),Mt.upperRight=(0,Nt.UJ)(8*ut[2],8*ut[3]),Mt.lowerLeft=(0,Nt.UJ)(8*ut[4],8*ut[5]),Mt.lowerRight=(0,Nt.UJ)(8*ut[6],8*ut[7])}_setTextureCoords({x:pt,y:Mt,width:ut,height:Pt}){this._texcoords={upperLeft:(0,Nt.UJ)(pt,Mt),upperRight:(0,Nt.UJ)(pt+ut,Mt),lowerLeft:(0,Nt.UJ)(pt,Mt+Pt),lowerRight:(0,Nt.UJ)(pt+ut,Mt+Pt)}}}const Ht=(Ot,pt)=>({code:0,page:0,sdf:!0,rect:new xt.Z(0,0,11,8),textureBinding:pt,metrics:{advance:0,height:4,width:Ot,left:0,top:0}});function oe(Ot,pt){return Ot.forEach(Mt=>(0,zt.t)(Mt,Mt,pt)),{upperLeft:(0,Nt.UJ)(8*Ot[0][0],8*Ot[0][1]),upperRight:(0,Nt.UJ)(8*Ot[1][0],8*Ot[1][1]),lowerLeft:(0,Nt.UJ)(8*Ot[2][0],8*Ot[2][1]),lowerRight:(0,Nt.UJ)(8*Ot[3][0],8*Ot[3][1])}}class ue{constructor(pt,Mt,ut){this._rotation=0,this._decorate(pt,Mt,ut),this.glyphs=pt,this.bounds=this._createBounds(pt),this.isMultiline=Mt.length>1,this._hasRotation=0!==ut.angle,this._transform=this._createGlyphTransform(this.bounds,ut),this._borderLineSize=ut.borderLineSize,(ut.borderLineSize||ut.hasBackground)&&([this.bounds,this.background]=this.shapeBackground(this._transform));for(const Pt of pt)Pt.setTransform(this._transform)}setRotation(pt){if(0===pt&&0===this._rotation)return;this._rotation=pt;const Mt=this._transform,ut=(0,gt.b)((0,Ft.c)(),pt);(0,gt.m)(Mt,ut,Mt);for(const Pt of this.glyphs)Pt.setTransform(this._transform)}_decorate(pt,Mt,ut){if(!ut.decoration||"none"===ut.decoration||!pt.length)return;const Pt=ut.scale,wt="underline"===ut.decoration?30:20,Dt=pt[0].textureBinding;for(const te of Mt)pt.push(new Vt(te.startX*Pt,te.startY*Pt+wt*Pt,Ht((te.width+te.glyphWidthEnd)*Pt,Dt),1))}shapeBackground(pt){const ut=(1.5+(0,Wt.F2)(this._borderLineSize||0))/2,Pt=this._borderLineSize?ut:0,{xmin:wt,ymin:Dt,xmax:te,ymax:Kt,x:ce,y:fe,width:It,height:y}=this.bounds,k=[wt-8,Dt-8],W=[te+8,Dt-8],N=[wt-8,Kt+8],j=[te+8,Kt+8],ct=oe([[k[0]-ut,k[1]-ut],[W[0]+ut,W[1]-ut],[k[0]+Pt,k[1]+Pt],[W[0]-Pt,W[1]+Pt]],pt),Z=oe([[N[0]+Pt,N[1]-Pt],[j[0]-Pt,j[1]-Pt],[N[0]-ut,N[1]+ut],[j[0]+ut,j[1]+ut]],pt),yt=oe([[k[0]-ut,k[1]-ut],[k[0]+Pt,k[1]+Pt],[N[0]-ut,N[1]+ut],[N[0]+Pt,N[1]-Pt]],pt),Tt=oe([[W[0]-Pt,W[1]+Pt],[W[0]+ut,W[1]-ut],[j[0]-Pt,j[1]-Pt],[j[0]+ut,j[1]+ut]],pt),T={main:oe([k,W,N,j],pt),top:ct,bot:Z,left:yt,right:Tt};return[new At(ce,fe,It+2*ut,y+2*ut),T]}get boundsT(){const pt=this.bounds,Mt=(0,zt.s)((0,he.c)(),pt.x,pt.y);if((0,zt.t)(Mt,Mt,this._transform),this._hasRotation){const ut=Math.max(pt.width,pt.height);return new At(Mt[0],Mt[1],ut,ut)}return new At(Mt[0],Mt[1],pt.width,pt.height)}_createBounds(pt){let Mt=1/0,ut=1/0,Pt=0,wt=0;for(const Kt of pt)Mt=Math.min(Mt,Kt.xTopLeft),ut=Math.min(ut,Kt.yTopLeft),Pt=Math.max(Pt,Kt.xBottomRight),wt=Math.max(wt,Kt.yBottomRight);const Dt=Pt-Mt,te=wt-ut;return new At(Mt+Dt/2,ut+te/2,Dt,te)}_createGlyphTransform(pt,Mt){const ut=Et*Mt.angle,Pt=(0,Ft.c)(),wt=(0,he.c)();return(0,gt.t)(Pt,Pt,(0,zt.s)(wt,Mt.xOffset,-Mt.yOffset)),Mt.isCIM?(0,gt.r)(Pt,Pt,ut):((0,gt.t)(Pt,Pt,(0,zt.s)(wt,pt.x,pt.y)),(0,gt.r)(Pt,Pt,ut),(0,gt.t)(Pt,Pt,(0,zt.s)(wt,-pt.x,-pt.y))),Pt}}class ot{constructor(pt,Mt,ut,Pt,wt,Dt){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(Mt,ut)),this.end=Math.max(0,Math.max(Mt,ut)),this.end<pt.length&&(this.glyphWidthEnd=pt[this.end].metrics.width),this.width=Pt,this.yMin=wt,this.yMax=Dt}}const St=Ot=>10===Ot,Gt=Ot=>32===Ot;function ie(Ot,pt,Mt){const ut=Mt.scale,Pt=new Array,wt=function qt(Ot,pt,Mt){const ut=new Array,wt=Mt.maxLineWidth*(1/Mt.scale),Dt=pt?Ot.length-1:0,te=pt?-1:Ot.length,Kt=pt?-1:1;let ce=Dt,fe=0,It=0,y=ce,k=y,W=0,N=1/0,j=0;for(;ce!==te;){const{code:Z,metrics:yt}=Ot[ce],Tt=Math.abs(yt.top);St(Z)||Gt(Z)||(N=Math.min(N,Tt),j=Math.max(j,Tt+yt.height)),St(Z)?(ce!==Dt&&(ut.push(new ot(Ot,y,ce-Kt,fe,N,j)),N=1/0,j=0),fe=0,y=ce+Kt,k=ce+Kt,It=0):Gt(Z)?(k=ce+Kt,It=0,W=yt.advance,fe+=yt.advance):fe>wt?(k!==y?(fe-=W,ut.push(new ot(Ot,y,k-2*Kt,fe-It,N,j)),N=1/0,j=0,y=k,fe=It):(ut.push(new ot(Ot,y,ce-Kt,fe,N,j)),N=1/0,j=0,y=ce,k=ce,fe=0),fe+=yt.advance,It+=yt.advance):(fe+=yt.advance,It+=yt.advance),ce+=Kt}const ct=new ot(Ot,y,ce-Kt,fe,N,j);return ct.start>=0&&ct.end<Ot.length&&ut.push(ct),ut}(Ot,pt,Mt),Dt=function Rt(Ot,pt){let Mt=0;for(let wt=0;wt<Ot.length;wt++){const{width:Dt}=Ot[wt];Mt=Math.max(Dt,Mt)}const Pt=Ot[0].yMin;return{x:0,y:Pt,height:Ot[Ot.length-1].yMax+pt.lineHeight*(Ot.length-1)+("underline"===pt.decoration?4:0)-Pt,width:Mt}}(wt,Mt),{vAlign:te,hAlign:Kt}=Mt,ce=te===tt.TR.Baseline?1:0,It=(1-ce)*-Dt.y+Dt.height/2*(ce?0:te-1)+-26*(ce?1:0);for(let y=0;y<wt.length;y++){const{start:k,end:W,width:N}=wt[y];let j=-1*(Kt+1)*(N/2)-3;const ct=y*Mt.lineHeight+It-3;wt[y].startX=j,wt[y].startY=ct;for(let Z=k;Z<=W;Z++){const yt=Ot[Z];if(St(yt.code))continue;const Tt=new Vt(j+yt.metrics.left,ct-yt.metrics.top,yt,ut);j+=yt.metrics.advance,Pt.push(Tt)}}return new ue(Pt,wt,Mt)}}}]);