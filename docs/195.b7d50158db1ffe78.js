"use strict";(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[195],{90195:(yt,Be,C)=>{C.r(Be),C.d(Be,{default:()=>dt});var le=C(15861),me=C(10699),J=C(919),be=C(62208),V=C(13160),v=C(86575);function Ze(c){return!(c<11904)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=65280&&c<=65519||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543||c>=65040&&c<=65055||c>=42128&&c<=42191||c>=40960&&c<=42127)}function Ke(c){switch(c){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function we(c){switch(c){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}var De=C(84439);const j=24;class Ae{constructor(e,t,n,i,r,a,o){this._glyphItems=e,this._maxWidth=t,this._lineHeight=n,this._letterSpacing=i,this._hAnchor=r,this._vAnchor=a,this._justify=o}getShaping(e,t,n){const i=this._letterSpacing,r=this._lineHeight,a=this._justify,o=this._maxWidth,l=[];let u=0,f=0;const d=e.length;for(let p=0;p<d;p++){const M=e.charCodeAt(p),B=n&&(746===(c=M)||747===c||!(c<4352)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103&&!(c>=65097&&c<=65103)||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351&&!(c>=12296&&c<=12305||c>=12308&&c<=12319||12336===c)||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=12592&&c<=12687||c>=43360&&c<=43391||c>=55216&&c<=55295||c>=4352&&c<=4607||c>=44032&&c<=55215||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12688&&c<=12703||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543&&12540!==c||c>=65280&&c<=65519&&!(65288===c||65289===c||65293===c||c>=65306&&c<=65310||65339===c||65341===c||65343===c||c>=65371&&c<=65503||65507===c||c>=65512&&c<=65519)||c>=65104&&c<=65135&&!(c>=65112&&c<=65118||c>=65123&&c<=65126)||c>=5120&&c<=5759||c>=6320&&c<=6399||c>=65040&&c<=65055||c>=19904&&c<=19967||c>=40960&&c<=42127||c>=42128&&c<=42191));let I;for(const P of this._glyphItems)if(I=P[M],I)break;l.push({codePoint:M,x:u,y:f,vertical:B,glyphMosaicItem:I}),I&&(u+=I.metrics.advance+i)}var c;let h=u;o>0&&(h=u/Math.max(1,Math.ceil(u/o)));const y=e.includes("\u200b"),g=[];for(let p=0;p<d-1;p++){const M=l[p].codePoint,B=Ze(M);if(Ke(M)||B){let I=0;if(10===M)I-=1e4;else if(B&&y)I+=150;else{40!==M&&65288!==M||(I+=50);const P=l[p+1].codePoint;41!==P&&65289!==P||(I+=50)}g.push(this._buildBreak(p+1,l[p].x,h,g,I,!1))}}const m=this._optimalBreaks(this._buildBreak(d,u,h,g,0,!0));let T=0;const x=t?-r:r;let _=0;for(let p=0;p<m.length;p++){const M=m[p];let B=_;for(;B<M&&we(l[B].codePoint);)l[B].glyphMosaicItem=null,++B;let I=M-1;for(;I>B&&we(l[I].codePoint);)l[I].glyphMosaicItem=null,--I;if(B<=I){const P=l[B].x;for(let b=B;b<=I;b++)l[b].x-=P,l[b].y=f;let D=l[I].x;l[I].glyphMosaicItem&&(D+=l[I].glyphMosaicItem.metrics.advance),T=Math.max(D,T),a&&this._applyJustification(l,B,I)}_=M,f+=x}if(l.length>0){const p=m.length-1,M=(a-this._hAnchor)*T;let B=(-this._vAnchor*(p+1)+.5)*r;t&&p&&(B+=p*r);for(const I of l)I.x+=M,I.y+=B}return l.filter(p=>p.glyphMosaicItem)}static getTextBox(e,t){if(!e.length)return null;let n=1/0,i=1/0,r=0,a=0;for(const o of e){const u=o.x,f=o.y-17,d=u+o.glyphMosaicItem.metrics.advance,h=f+t;n=Math.min(n,u),r=Math.max(r,d),i=Math.min(i,f),a=Math.max(a,h)}return{x:n,y:i,width:r-n,height:a-i}}static getBox(e){if(!e.length)return null;let t=1/0,n=1/0,i=0,r=0;for(const a of e){const{height:o,left:l,top:u,width:f}=a.glyphMosaicItem.metrics,d=a.x,h=a.y-(o-Math.abs(u)),y=d+f+l,g=h+o;t=Math.min(t,d),i=Math.max(i,y),n=Math.min(n,h),r=Math.max(r,g)}return{x:t,y:n,width:i-t,height:r-n}}static addDecoration(e,t){const n=e.length;if(0===n)return;let r=e[0].x+e[0].glyphMosaicItem.metrics.left,a=e[0].y;for(let l=1;l<n;l++){const u=e[l];if(u.y!==a){const f=e[l-1].x+e[l-1].glyphMosaicItem.metrics.left+e[l-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:r,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new De.Z(4,0,4,8),metrics:{width:f-r,height:8,left:0,top:0,advance:0},page:0,code:0}}),a=u.y,r=u.x+u.glyphMosaicItem.metrics.left}}const o=e[n-1].x+e[n-1].glyphMosaicItem.metrics.left+e[n-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:r,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new De.Z(4,0,4,8),metrics:{width:o-r,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(e,t,n,i){const r=(e-t)*(e-t);return i?e<t?r/2:2*r:r+Math.abs(n)*n}_buildBreak(e,t,n,i,r,a){let o=null,l=this._breakScore(t,n,r,a);for(const u of i){const d=this._breakScore(t-u.x,n,r,a)+u.score;d<=l&&(o=u,l=d)}return{index:e,x:t,score:l,previousBreak:o}}_optimalBreaks(e){return e?this._optimalBreaks(e.previousBreak).concat(e.index):[]}_applyJustification(e,t,n){const i=e[n],a=(i.x+(i.vertical?j:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0))*this._justify;for(let o=t;o<=n;o++)e[o].x-=a}}var Ve=C(47132),A=C(1268);const q=.5;class he{constructor(e,t,n=0,i=-1,r=q){this.x=e,this.y=t,this.angle=n,this.segment=i,this.minzoom=r}}class ce{constructor(e,t,n,i,r,a=q,o=v.B1){this.anchor=e,this.labelAngle=t,this.glyphAngle=n,this.page=i,this.alternateVerticalGlyph=r,this.minzoom=a,this.maxzoom=o}}class ve{constructor(e,t,n,i,r,a,o,l,u,f,d,h){this.tl=e,this.tr=t,this.bl=n,this.br=i,this.mosaicRect=r,this.labelAngle=a,this.minAngle=o,this.maxAngle=l,this.anchor=u,this.minzoom=f,this.maxzoom=d,this.page=h}}class ke{constructor(e){this.shapes=e}}class We{getIconPlacement(e,t,n){const i=new V.E9(e.x,e.y),r=n.rotationAlignment===A.aF.MAP,a=n.keepUpright;let o=n.rotate*v.DT;r&&(o+=e.angle);const l=new ke([]);return n.allowOverlap&&n.ignorePlacement||!Ve.Bf||(l.iconColliders=[]),this._addIconPlacement(l,i,t,n,o),r&&a&&this._addIconPlacement(l,i,t,n,o+v.JJ),l}_addIconPlacement(e,t,n,i,r){const a=n.pixelRatio,o=n.width/a,l=n.height/a,u=i.offset;let f=u[0],d=u[1];switch(i.anchor){case A.nR.CENTER:f-=o/2,d-=l/2;break;case A.nR.LEFT:d-=l/2;break;case A.nR.RIGHT:f-=o,d-=l/2;break;case A.nR.TOP:f-=o/2;break;case A.nR.BOTTOM:f-=o/2,d-=l;break;case A.nR.TOP_LEFT:break;case A.nR.BOTTOM_LEFT:d-=l;break;case A.nR.TOP_RIGHT:f-=o;break;case A.nR.BOTTOM_RIGHT:f-=o,d-=l}const h=n.rect,y=2/a,g=f-y,m=d-y,T=g+h.width/a,x=m+h.height/a,_=new V.E9(g,m),p=new V.E9(T,x),M=new V.E9(g,x),B=new V.E9(T,m);if(0!==r){const P=Math.cos(r),D=Math.sin(r);_.rotate(P,D),p.rotate(P,D),M.rotate(P,D),B.rotate(P,D)}const I=new ve(_,B,M,p,h,r,0,256,t,q,v.B1,0);if(e.shapes.push(I),(!i.allowOverlap||!i.ignorePlacement)&&Ve.Bf){const P=i.size,D=i.padding;e.iconColliders.push({xTile:t.x,yTile:t.y,dxPixels:f*P-D,dyPixels:d*P-D,hard:!i.optional,partIndex:0,width:o*P+2*D,height:l*P+2*D,angle:r,minLod:q,maxLod:v.B1})}}getTextPlacement(e,t,n,i){const r=new V.E9(e.x,e.y),a=i.rotate*v.DT,o=i.rotationAlignment===A.aF.MAP,l=i.keepUpright,u=i.padding;let f=q;const d=o?e.angle:0,h=e.segment>=0&&o,y=i.allowOverlap&&i.ignorePlacement?null:[],g=[],T=!h;let x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_;const B=(h||o)&&l,I=i.size/j;let P=!1;for(const w of t)if(w.vertical){P=!0;break}let D,b=0,L=0;if(!h&&P){const w=Ae.getTextBox(t,i.lineHeight*j);switch(i.anchor){case A.nR.LEFT:b=w.height/2,L=-w.width/2;break;case A.nR.RIGHT:b=-w.height/2,L=w.width/2;break;case A.nR.TOP:b=w.height/2,L=w.width/2;break;case A.nR.BOTTOM:b=-w.height/2,L=-w.width/2;break;case A.nR.TOP_LEFT:b=w.height;break;case A.nR.BOTTOM_LEFT:L=-w.width;break;case A.nR.TOP_RIGHT:L=w.width;break;case A.nR.BOTTOM_RIGHT:b=-w.height}}b+=i.offset[0]*j,L+=i.offset[1]*j;for(const w of t){const S=w.glyphMosaicItem;if(!S||S.rect.isEmpty)continue;const k=S.rect,R=S.metrics,U=S.page;if(y&&T){if(void 0!==D&&D!==w.y){let F,N,G,H;P?(F=-M+b,N=x+L,G=M-p,H=_-x):(F=x+b,N=p+L,G=_-x,H=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:F*I-u,dyPixels:N*I-u,hard:!i.optional,partIndex:1,width:G*I+2*u,height:H*I+2*u,angle:a,minLod:q,maxLod:v.B1}),x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_}D=w.y}const ee=[];if(h){const N=(w.x+R.left-4+.5*S.metrics.width)*I*8;if(f=this._placeGlyph(e,f,N,n,e.segment,1,w.vertical,U,ee),l&&(f=this._placeGlyph(e,f,N,n,e.segment,-1,w.vertical,U,ee)),f>=2)break}else ee.push(new ce(r,d,d,U,!1)),o&&l&&ee.push(new ce(r,d+v.JJ,d+v.JJ,U,!1));const W=w.x+R.left,Q=w.y-17-R.top,te=W+R.width,Te=Q+R.height;let z,Y,fe,de,se,ye,Ne,Ge;!h&&P?w.vertical?(z=new V.E9(-((Q+Te)/2+R.width/2)-4+b,(W+te)/2-R.height/2-4+L),Y=new V.E9(z.x+k.width,z.y+k.height),fe=new V.E9(z.x,Y.y),de=new V.E9(Y.x,z.y)):(z=new V.E9(4-Q+b,W-4+L),Y=new V.E9(z.x-k.height,z.y+k.width),fe=new V.E9(Y.x,z.y),de=new V.E9(z.x,Y.y)):(z=new V.E9(W-4+b,Q-4+L),Y=new V.E9(z.x+k.width,z.y+k.height),fe=new V.E9(z.x,Y.y),de=new V.E9(Y.x,z.y));for(const F of ee){let N,G,H,K;F.alternateVerticalGlyph?(se||(se=new V.E9((W+te)/2+b-R.height/2-4,(Q+Te)/2+L+R.width/2+4),ye=new V.E9(se.x+k.height,se.y-k.width),Ne=new V.E9(ye.x,se.y),Ge=new V.E9(se.x,ye.y)),N=se,G=Ne,H=Ge,K=ye):(N=z,G=fe,H=de,K=Y);const xe=Q,Pe=Te,ge=F.glyphAngle+a;if(0!==ge){const $=Math.cos(ge),pe=Math.sin(ge);N=N.clone(),G=null==G?void 0:G.clone(),H=null==H?void 0:H.clone(),K=null==K?void 0:K.clone(),N.rotate($,pe),null==K||K.rotate($,pe),null==G||G.rotate($,pe),null==H||H.rotate($,pe)}let ae=0,oe=256;h&&P?w.vertical?F.alternateVerticalGlyph?(ae=32,oe=96):(ae=224,oe=32):(ae=224,oe=96):(ae=192,oe=64),g.push(new ve(N,H,G,K,k,F.labelAngle,ae,oe,F.anchor,F.minzoom,F.maxzoom,F.page)),!y||B&&!this._legible(F.labelAngle)||(T?(W<x&&(x=W),xe<p&&(p=xe),te>_&&(_=te),Pe>M&&(M=Pe)):F.minzoom<2&&y.push({xTile:e.x,yTile:e.y,dxPixels:(W+b)*I-u,dyPixels:(xe+b)*I-u,hard:!i.optional,partIndex:1,width:(te-W)*I+2*u,height:(Pe-xe)*I+2*u,angle:ge,minLod:F.minzoom,maxLod:F.maxzoom}))}}if(f>=2)return null;if(y&&T){let w,S,k,R;P?(w=-M+b,S=x+L,k=M-p,R=_-x):(w=x+b,S=p+L,k=_-x,R=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:w*I-u,dyPixels:S*I-u,hard:!i.optional,partIndex:1,width:k*I+2*u,height:R*I+2*u,angle:a,minLod:q,maxLod:v.B1})}const E=new ke(g);return y&&y.length>0&&(E.textColliders=y),E}_legible(e){const t=(0,v.Or)(e);return t<65||t>=193}_placeGlyph(e,t,n,i,r,a,o,l,u){let f=a;const d=f<0?(0,v.DQ)(e.angle+v.JJ,v._U):e.angle;let h=0;n<0&&(f*=-1,n*=-1,h=v.JJ),f>0&&++r;let y=new V.E9(e.x,e.y),g=i[r],m=v.B1;if(i.length<=r)return m;for(;;){const T=g.x-y.x,x=g.y-y.y,_=Math.sqrt(T*T+x*x),p=Math.max(n/_,t),I=(0,v.DQ)(Math.atan2(x/_,T/_)+h,v._U);if(u.push(new ce(y,d,I,l,!1,p,m)),o&&u.push(new ce(y,d,I,l,!0,p,m)),p<=t)return p;y=g.clone();do{if(i.length<=(r+=f)||r<0)return p;g=i[r]}while(y.isEqual(g));let P=g.x-y.x,D=g.y-y.y;const b=Math.sqrt(P*P+D*D);P*=_/b,D*=_/b,y.x-=P,y.y-=D,m=p}}}var ie,c,je=C(24192),Re=C(58774);(c=ie||(ie={}))[c.moveTo=1]="moveTo",c[c.lineTo=2]="lineTo",c[c.close=7]="close";class Ye{constructor(e,t){this.values={},this._geometry=void 0,this._pbfGeometry=null;const n=t.keys,i=t.values,r=e.asUnsafe();for(;r.next();)switch(r.tag()){case 1:this.id=r.getUInt64();break;case 2:{const a=r.getMessage().asUnsafe(),o=this.values;for(;!a.empty();){const l=a.getUInt32(),u=a.getUInt32();o[n[l]]=i[u]}a.release();break}case 3:this.type=r.getUInt32();break;case 4:this._pbfGeometry=r.getMessage();break;default:r.skip()}}getGeometry(e){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const t=this._pbfGeometry.asUnsafe();let n,i;this._pbfGeometry=null,e?e.reset(this.type):n=[];let r,a=ie.moveTo,o=0,l=0,u=0;for(;!t.empty();){if(0===o){const f=t.getUInt32();a=7&f,o=f>>3}switch(o--,a){case ie.moveTo:l+=t.getSInt32(),u+=t.getSInt32(),e?e.moveTo(l,u):n&&(i&&n.push(i),i=[],i.push(new V.E9(l,u)));break;case ie.lineTo:l+=t.getSInt32(),u+=t.getSInt32(),e?e.lineTo(l,u):i&&i.push(new V.E9(l,u));break;case ie.close:e?e.close():i&&!i[0].equals(l,u)&&i.push(i[0].clone());break;default:throw t.release(),new Error("Invalid path operation")}}return e?r=e.result():n&&(i&&n.push(i),r=n),t.release(),this._geometry=r,r}}var O=C(36243);class ne extends O.Z{constructor(){super(12)}add(e,t,n){const i=this.array;i.push(e),i.push(t),i.push(n)}}class Ie{constructor(e){this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=e.clone();const t=e.asUnsafe();for(;t.next();)switch(t.tag()){case 1:this.name=t.getString();break;case 3:this.keys.push(t.getString());break;case 4:this.values.push(t.processMessage(Ie._parseValue));break;case 5:this.extent=t.getUInt32();break;default:t.skip()}}getData(){return this._pbfLayer}static _parseValue(e){for(;e.next();)switch(e.tag()){case 1:return e.getString();case 2:return e.getFloat();case 3:return e.getDouble();case 4:return e.getInt64();case 5:return e.getUInt64();case 6:return e.getSInt64();case 7:return e.getBool();default:e.skip()}return null}}class Je extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o,l,u,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g);const m=31;g=O.Z.i8888to32(Math.round(m*n),Math.round(m*i),Math.round(m*r),Math.round(m*a)),y.push(g),g=O.Z.i8888to32(Math.round(m*o),Math.round(m*l),Math.round(m*u),Math.round(m*f)),y.push(g),g=O.Z.i1616to32(d,0),y.push(g),h&&y.push(...h)}}class Xe extends O.Z{constructor(e){super(e)}add(e,t,n){const i=this.array;i.push(O.Z.i1616to32(e,t)),n&&i.push(...n)}}class Qe extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o){const l=this.array,u=this.index;let f=O.Z.i1616to32(e,t);return l.push(f),f=O.Z.i8888to32(Math.round(15*n),Math.round(15*i),r,a),l.push(f),o&&l.push(...o),u}}class Se extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o,l,u,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g),g=O.Z.i1616to32(Math.round(8*n),Math.round(8*i)),y.push(g),g=O.Z.i8888to32(r/4,a/4,l,u),y.push(g),g=O.Z.i8888to32(0,(0,v.Or)(o),10*f,Math.min(10*d,255)),y.push(g),h&&y.push(...h)}}class $e extends O.Z{constructor(e){super(e)}add(e,t,n,i,r){const a=this.array,o=O.Z.i1616to32(2*e+n,2*t+i);a.push(o),r&&a.push(...r)}}class ue{constructor(e,t,n){this.layerExtent=4096,this._features=[],this.layer=e,this.zoom=t,this._spriteInfo=n,this._filter=e.getFeatureFilter()}pushFeature(e){this._filter&&!this._filter.filter(e,this.zoom)||this._features.push(e)}hasFeatures(){return this._features.length>0}getResources(e,t,n){}}class qe extends ue{constructor(e,t,n,i,r){super(e,t,n),this.type=J.al.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=r}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(e){const t=this._circleVertexBuffer,n=this._circleIndexBuffer;this._circleIndexStart=3*n.index,this._circleIndexCount=0;const i=this.layer,r=this.zoom;e&&e.setExtent(this.layerExtent);for(const a of this._features){const o=a.getGeometry(e);if(!o)continue;const l=i.circleMaterial.encodeAttributes(a,r,i);for(const u of o)if(u)for(const f of u){const d=t.index;t.add(f.x,f.y,0,0,l),t.add(f.x,f.y,0,1,l),t.add(f.x,f.y,1,0,l),t.add(f.x,f.y,1,1,l),n.add(d+0,d+1,d+2),n.add(d+1,d+2,d+3),this._circleIndexCount+=6}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this._circleVertexBuffer.array.length,e+=this._circleIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)t[i++]=this.layerUIDs[r];t[i++]=this._circleIndexStart,t[i++]=this._circleIndexCount,t[i++]=this._circleVertexBuffer.array.length;for(let r=0;r<this._circleVertexBuffer.array.length;r++)n[i++]=this._circleVertexBuffer.array[r];t[i++]=this._circleIndexBuffer.array.length;for(let r=0;r<this._circleIndexBuffer.array.length;r++)t[i++]=this._circleIndexBuffer.array[r];return t.buffer}}var Ce=C(35575),Fe=C(11915);class Me extends ue{constructor(e,t,n,i,r,a,o){super(e,t,n),this.type=J.al.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=r,this._outlineVertexBuffer=a,this._outlineIndexBuffer=o}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(e,t,n){const r=this.zoom,a=this.layer.getPaintProperty("fill-pattern");if(a)if(a.isDataDriven)for(const o of this._features)t(a.getValue(r,o),!0);else t(a.getValue(r),!0)}processFeatures(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,n=this.zoom,{fillMaterial:i,outlineMaterial:r,hasDataDrivenFill:a,hasDataDrivenOutline:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("fill-pattern"),u=null==l?void 0:l.isDataDriven;let f=!l&&t.getPaintValue("fill-antialias",n);if(t.outlineUsesFillColor){if(f&&!t.hasDataDrivenOpacity){const y=t.getPaintValue("fill-opacity",n),g=t.getPaintValue("fill-opacity",n+1);y<1&&g<1&&(f=!1)}if(f&&!t.hasDataDrivenColor){const y=t.getPaintValue("fill-color",n),g=t.getPaintValue("fill-color",n+1);y[3]<1&&g[3]<1&&(f=!1)}}const d=this._features,h=null==e?void 0:e.validateTessellation;if(u){const y=[];for(const g of d){const m=l.getValue(n,g),T=this._spriteInfo[m];if(!T||!T.rect)continue;const x=i.encodeAttributes(g,n,t,T),_=f&&o?r.encodeAttributes(g,n,t):[],p=g.getGeometry(e);y.push({ddFillAttributes:x,ddOutlineAttributes:_,page:T.page,geometry:p}),y.sort((M,B)=>M.page-B.page);for(const{ddFillAttributes:M,ddOutlineAttributes:B,page:I,geometry:P}of y)this._processFeature(P,f,t.outlineUsesFillColor,M,B,h,I)}}else for(const y of d){const g=a?i.encodeAttributes(y,n,t):null,m=f&&o?r.encodeAttributes(y,n,t):null,T=y.getGeometry(e);this._processFeature(T,f,t.outlineUsesFillColor,g,m,h)}}serialize(){let e=10;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._fillIndexStart,t[i++]=this._fillIndexCount,t[i++]=this._outlineIndexStart,t[i++]=this._outlineIndexCount;const r=this._patternMap,a=r.size;if(t[i++]=a,a>0)for(const[o,[l,u]]of r)t[i++]=o,t[i++]=l,t[i++]=u;t[i++]=this._fillVertexBuffer.array.length;for(let o=0;o<this._fillVertexBuffer.array.length;o++)n[i++]=this._fillVertexBuffer.array[o];t[i++]=this._fillIndexBuffer.array.length;for(let o=0;o<this._fillIndexBuffer.array.length;o++)t[i++]=this._fillIndexBuffer.array[o];t[i++]=this._outlineVertexBuffer.array.length;for(let o=0;o<this._outlineVertexBuffer.array.length;o++)n[i++]=this._outlineVertexBuffer.array[o];t[i++]=this._outlineIndexBuffer.array.length;for(let o=0;o<this._outlineIndexBuffer.array.length;o++)t[i++]=this._outlineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,n,i,r,a,o){if(!e)return;const l=e.length;if(t&&(!n||!r||0===r.length))for(let h=0;h<l;h++)this._processOutline(e[h],r);let d;for(let h=0;h<l;h++){const y=Me._area(e[h]);y>32?(void 0!==d&&this._processFill(e,d,i,a,o),d=[h]):y<-32&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(e,d,i,a,o)}_processOutline(e,t){const n=this._outlineVertexBuffer,i=this._outlineIndexBuffer,r=i.index;let a,o,l;const u=new V.E9(0,0),f=new V.E9(0,0),d=new V.E9(0,0);let h=-1,y=-1,g=-1,m=-1,T=-1,x=!1,p=e.length;if(p<2)return;const M=e[0];let B=e[p-1];for(;p&&B.isEqual(M);)--p,B=e[p-1];if(!(p-0<2)){for(let I=0;I<p;++I){0===I?(a=e[p-1],o=e[0],l=e[1],u.assignSub(o,a),u.normalize(),u.rightPerpendicular()):(a=o,o=l,l=I!==p-1?e[I+1]:e[0],u.assign(f));const P=this._isClipEdge(a,o);-1===m&&(x=P),f.assignSub(l,o),f.normalize(),f.rightPerpendicular();const D=u.x*f.y-u.y*f.x;d.assignAdd(u,f),d.normalize();const b=-d.x*-u.x+-d.y*-u.y;let L=Math.abs(0!==b?1/b:1);L>8&&(L=8),D>=0?(g=n.add(o.x,o.y,u.x,u.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,L*-d.x,L*-d.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=n.add(o.x,o.y,d.x,d.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,f.x,f.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g)):(g=n.add(o.x,o.y,L*d.x,L*d.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,-u.x,-u.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=n.add(o.x,o.y,-d.x,-d.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=n.add(o.x,o.y,-f.x,-f.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g))}h>=0&&y>=0&&m>=0&&!x&&i.add(h,y,m),h>=0&&m>=0&&T>=0&&!x&&i.add(h,T,m),this._outlineIndexCount+=3*(i.index-r)}}_processFill(e,t,n,i,r){let a;t.length>1&&(a=[]);let o=0;for(const d of t)0!==o&&a.push(o),o+=e[d].length;const l=2*o,u=Ce.Z.acquire();for(const d of t){const h=e[d],y=h.length;for(let g=0;g<y;++g)u.push(h[g].x,h[g].y)}const f=(0,Fe.e)(u,a,2);if(Fe.e.deviation(u,a,2,f)>0){const d=t.map(g=>e[g].length),{buffer:h,vertexCount:y}=(0,Re.b)(u,d);if(y>0){const g=this._fillVertexBuffer.index;for(let m=0;m<y;m++)this._fillVertexBuffer.add(h[2*m],h[2*m+1],n);for(let m=0;m<y;m+=3){const T=g+m;this._fillIndexBuffer.add(T,T+1,T+2)}if(void 0!==r){const m=this._patternMap,T=m.get(r);T?T[1]+=y:m.set(r,[this._fillIndexStart+this._fillIndexCount,y])}this._fillIndexCount+=y}}else{const d=f.length;if(d>0){const h=this._fillVertexBuffer.index;let y=0;for(;y<l;)this._fillVertexBuffer.add(u[y++],u[y++],n);let g=0;for(;g<d;)this._fillIndexBuffer.add(h+f[g++],h+f[g++],h+f[g++]);if(void 0!==r){const m=this._patternMap,T=m.get(r);T?T[1]+=d:m.set(r,[this._fillIndexStart+this._fillIndexCount,d])}this._fillIndexCount+=d}}Ce.Z.release(u)}_isClipEdge(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)}static _area(e){let t=0;const n=e.length-1;for(let i=0;i<n;i++)t+=(e[i].x-e[i+1].x)*(e[i].y+e[i+1].y);return t+=(e[n].x-e[0].x)*(e[n].y+e[0].y),.5*t}}var et=C(46519);class st extends ue{constructor(e,t,n,i,r){super(e,t,n),this.type=J.al.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=r,this._lineTessellator=new et.z(it(this.tessellationProperties),nt(this.tessellationProperties),e.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(e,t,n){const i=this.layer,r=this.zoom,a=i.getPaintProperty("line-pattern"),o=i.getPaintProperty("line-dasharray"),l=i.getLayoutProperty("line-cap");if(!a&&!o)return;const u=(null==l?void 0:l.getValue(r))||0,f=null==l?void 0:l.isDataDriven,d=null==a?void 0:a.isDataDriven;if(d||(null==o?void 0:o.isDataDriven))for(const y of this._features)t(d?a.getValue(r,y):this._getDashArrayKey(y,r,i,o,f,l,u));else if(a)t(a.getValue(r));else if(o){const y=o.getValue(r);t(i.getDashKey(y,u))}}processFeatures(e){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const t=this.layer,n=this.zoom,i=this._features,r=this._tessellationOptions,{hasDataDrivenLine:a,lineMaterial:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("line-pattern"),u=t.getPaintProperty("line-dasharray"),f=null==l?void 0:l.isDataDriven,d=null==u?void 0:u.isDataDriven;let h;h=t.getLayoutProperty("line-cap");const y=null!=h&&h.isDataDriven?h:null,g=y?null:t.getLayoutValue("line-cap",n),m=g||0,T=!!y;h=t.getLayoutProperty("line-join");const x=null!=h&&h.isDataDriven?h:null,_=x?null:t.getLayoutValue("line-join",n);h=t.getLayoutProperty("line-miter-limit");const p=null!=h&&h.isDataDriven?h:null,M=p?null:t.getLayoutValue("line-miter-limit",n);h=t.getLayoutProperty("line-round-limit");const B=null!=h&&h.isDataDriven?h:null,I=B?null:t.getLayoutValue("line-round-limit",n);h=t.getPaintProperty("line-width");const P=null!=h&&h.isDataDriven?h:null,D=P?null:t.getPaintValue("line-width",n);h=t.getPaintProperty("line-offset");const b=null!=h&&h.isDataDriven?h:null,L=b?null:t.getPaintValue("line-offset",n);if(f||d){const E=[];for(const w of i){const S=f?l.getValue(n,w):this._getDashArrayKey(w,n,t,u,T,y,m),k=this._spriteInfo[S];if(!k||!k.rect)continue;const R=o.encodeAttributes(w,n,t,k),U=w.getGeometry(e);E.push({ddAttributes:R,page:k.page,cap:y?y.getValue(n,w):g,join:x?x.getValue(n,w):_,miterLimit:p?p.getValue(n,w):M,roundLimit:B?B.getValue(n,w):I,halfWidth:.5*(P?P.getValue(n,w):D),offset:b?b.getValue(n,w):L,geometry:U})}E.sort((w,S)=>w.page-S.page),r.textured=!0;for(const{ddAttributes:w,page:S,cap:k,join:R,miterLimit:U,roundLimit:ee,halfWidth:W,offset:Q,geometry:te}of E)r.capType=k,r.joinType=R,r.miterLimit=U,r.roundLimit=ee,r.halfWidth=W,r.offset=Q,this._processFeature(te,w,S)}else{if(l){const E=l.getValue(n),w=this._spriteInfo[E];if(!w||!w.rect)return}r.textured=!(!l&&!u),r.capType=g,r.joinType=_,r.miterLimit=M,r.roundLimit=I,r.halfWidth=.5*D,r.offset=L;for(const E of i){const w=a?o.encodeAttributes(E,n,t):null;y&&(r.capType=y.getValue(n,E)),x&&(r.joinType=x.getValue(n,E)),p&&(r.miterLimit=p.getValue(n,E)),B&&(r.roundLimit=B.getValue(n,E)),P&&(r.halfWidth=.5*P.getValue(n,E)),b&&(r.offset=b.getValue(n,E));const S=E.getGeometry(e);this._processFeature(S,w)}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._lineIndexStart,t[i++]=this._lineIndexCount;const r=this._patternMap,a=r.size;if(t[i++]=a,a>0)for(const[o,[l,u]]of r)t[i++]=o,t[i++]=l,t[i++]=u;t[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineVertexBuffer.array.length;o++)n[i++]=this.tessellationProperties._lineVertexBuffer.array[o];t[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineIndexBuffer.array.length;o++)t[i++]=this.tessellationProperties._lineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,n){if(!e)return;const i=e.length;for(let r=0;r<i;r++)this._processGeometry(e[r],t,n)}_processGeometry(e,t,n){if(e.length<2)return;let r,a,o=e[0],l=1;for(;l<e.length;)r=e[l].x-o.x,a=e[l].y-o.y,r*r+a*a<1e-6?e.splice(l,1):(o=e[l],++l);if(e.length<2)return;const u=this.tessellationProperties._lineIndexBuffer,f=3*u.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=t,this._lineTessellator.tessellate(e,this._tessellationOptions);const d=3*u.index-f;if(void 0!==n){const h=this._patternMap,y=h.get(n);y?y[1]+=d:h.set(n,[f+this._lineIndexCount,d])}this._lineIndexCount+=d}_getDashArrayKey(e,t,n,i,r,a,o){const l=r?a.getValue(t,e):o,u=i.getValue(t,e);return n.getDashKey(u,l)}}const it=c=>(e,t,n,i,r,a,o,l,u,f,d)=>(c._lineVertexBuffer.add(e,t,o,l,n,i,r,a,u,f,d,c._ddValues),c._lineVertexBuffer.index-1),nt=c=>(e,t,n)=>{c._lineIndexBuffer.add(e,t,n)};var X,rt=C(6879),Oe=C(77275),Ue=C(13295);function at(c,e){return c.iconMosaicItem&&e.iconMosaicItem?c.iconMosaicItem.page===e.iconMosaicItem.page?0:c.iconMosaicItem.page-e.iconMosaicItem.page:c.iconMosaicItem&&!e.iconMosaicItem?1:!c.iconMosaicItem&&e.iconMosaicItem?-1:0}class Z extends ue{constructor(e,t,n,i,r,a,o,l){super(e,t,l.getSpriteItems()),this.type=J.al.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._iconVertexBuffer=n,this._iconIndexBuffer=i,this._textVertexBuffer=r,this._textIndexBuffer=a,this._placementEngine=o,this._workerTileHandler=l}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(e,t,n){const i=this.layer,r=this.zoom;e&&e.setExtent(this.layerExtent);const a=i.getLayoutProperty("icon-image"),o=i.getLayoutProperty("text-field");let l=i.getLayoutProperty("text-transform"),u=i.getLayoutProperty("text-font");const f=[];let d,h,y,g;a&&!a.isDataDriven&&(d=a.getValue(r)),o&&!o.isDataDriven&&(h=o.getValue(r)),l&&l.isDataDriven||(y=i.getLayoutValue("text-transform",r),l=null),u&&u.isDataDriven||(g=i.getLayoutValue("text-font",r),u=null);for(const m of this._features){const T=m.getGeometry(e);if(!T||0===T.length)continue;let x,_;a&&(x=a.isDataDriven?a.getValue(r,m):this._replaceKeys(d,m.values),x&&t(x));let p=!1;if(o&&(_=o.isDataDriven?o.getValue(r,m):this._replaceKeys(h,m.values),_)){switch(_=_.replace(/\\n/g,"\n"),l&&(y=l.getValue(r,m)),y){case A._5.LOWERCASE:_=_.toLowerCase();break;case A._5.UPPERCASE:_=_.toUpperCase()}if(Z._bidiEngine.hasBidiChar(_)){let P;P="rtl"===Z._bidiEngine.checkContextual(_)?"IDNNN":"ICNNN",_=Z._bidiEngine.bidiTransform(_,P,"VLYSN"),p=!0}const I=_.length;if(I>0){u&&(g=u.getValue(r,m));for(const P of g){let D=n[P];D||(D=n[P]=new Set);for(let b=0;b<I;b++){const L=_.charCodeAt(b);D.add(L)}}}}if(!x&&!_)continue;const M=i.getLayoutValue("symbol-sort-key",r,m),B={feature:m,sprite:x,label:_,rtl:p,geometry:T,hash:(_?(0,Oe.hP)(_):0)^(x?(0,Oe.hP)(x):0),priority:M,textFont:g};f.push(B)}this._symbolFeatures=f}processFeatures(e){e&&e.setExtent(this.layerExtent);const t=this.layer,n=this.zoom,i=t.getLayoutValue("symbol-placement",n),r=i!==A.R.POINT,a=8*t.getLayoutValue("symbol-spacing",n),o=t.getLayoutProperty("icon-image"),l=t.getLayoutProperty("text-field"),u=o?new Ue._L(t,n,r):null,f=l?new Ue.nj(t,n,r):null,d=this._workerTileHandler;let h;o&&(h=d.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const y=[];let g=1;f&&f.size&&(g=f.size/j);const m=f?f.maxAngle*v.DT:0,T=f?8*f.size:0;for(const x of this._symbolFeatures){let _,p;u&&h&&x.sprite&&(_=h[x.sprite],_&&_.sdf&&(this._isIconSDF=!0)),_&&u.update(n,x.feature);let M=0;const B=x.label;if(B){(0,be.O3)(f),f.update(n,x.feature);const I=r&&f.rotationAlignment===A.aF.MAP?f.keepUpright:f.writingMode&&f.writingMode.includes(A.r1.VERTICAL);let P=.5;switch(f.anchor){case A.nR.TOP_LEFT:case A.nR.LEFT:case A.nR.BOTTOM_LEFT:P=0;break;case A.nR.TOP_RIGHT:case A.nR.RIGHT:case A.nR.BOTTOM_RIGHT:P=1}let D=.5;switch(f.anchor){case A.nR.TOP_LEFT:case A.nR.TOP:case A.nR.TOP_RIGHT:D=0;break;case A.nR.BOTTOM_LEFT:case A.nR.BOTTOM:case A.nR.BOTTOM_RIGHT:D=1}let b=.5;switch(f.justify){case A.vL.AUTO:b=P;break;case A.vL.LEFT:b=0;break;case A.vL.RIGHT:b=1}const L=f.letterSpacing*j,E=r?0:f.maxWidth*j,w=f.lineHeight*j,S=x.textFont.map(k=>d.getGlyphItems(k));if(p=new Ae(S,E,w,L,P,D,b).getShaping(B,x.rtl,I),p&&p.length>0){let k=1e30,R=-1e30;for(const U of p)k=Math.min(k,U.x),R=Math.max(R,U.x);M=(R-k+48)*g*8}}for(let I of x.geometry){const P=[];if(i===A.R.LINE){if((null==p?void 0:p.length)&&(null==f?void 0:f.size)){const D=8*f.size*(2+Math.min(2,4*Math.abs(f.offset[1])));I=Z._smoothVertices(I,D)}Z._pushAnchors(P,I,a,M)}else i===A.R.LINE_CENTER?Z._pushCenterAnchor(P,I):x.feature.type===V.Vl.Polygon?Z._pushCentroid(P,I):P.push(new he(I[0].x,I[0].y));for(const D of P){if(D.x<0||D.x>4096||D.y<0||D.y>4096||r&&M>0&&(null==f?void 0:f.rotationAlignment)===A.aF.MAP&&!Z._honorsTextMaxAngle(I,D,M,m,T))continue;const b={shaping:p,line:I,iconMosaicItem:_,anchor:D,symbolFeature:x,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};y.push(b),this._processFeature(b,u,f)}}}y.sort(at),this._addPlacedGlyphs(),this._symbolInstances=y}serialize(){let e=11;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=Z._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer),i=new Float32Array(t.buffer);let r=0;t[r++]=this.type,t[r++]=this.layerUIDs.length;for(let a=0;a<this.layerUIDs.length;a++)t[r++]=this.layerUIDs[a];t[r++]=this._isIconSDF?1:0,t[r++]=this.markerPageMap.size;for(const[a,[o,l]]of this.markerPageMap)t[r++]=a,t[r++]=o,t[r++]=l;t[r++]=this.glyphsPageMap.size;for(const[a,[o,l]]of this.glyphsPageMap)t[r++]=a,t[r++]=o,t[r++]=l;t[r++]=this._iconVertexBuffer.index/4,t[r++]=this._textVertexBuffer.index/4,r=Z.serializeSymbols(t,n,i,r,this._symbolInstances),t[r++]=this._iconVertexBuffer.array.length;for(let a=0;a<this._iconVertexBuffer.array.length;a++)n[r++]=this._iconVertexBuffer.array[a];t[r++]=this._iconIndexBuffer.array.length;for(let a=0;a<this._iconIndexBuffer.array.length;a++)t[r++]=this._iconIndexBuffer.array[a];t[r++]=this._textVertexBuffer.array.length;for(let a=0;a<this._textVertexBuffer.array.length;a++)n[r++]=this._textVertexBuffer.array[a];t[r++]=this._textIndexBuffer.array.length;for(let a=0;a<this._textIndexBuffer.array.length;a++)t[r++]=this._textIndexBuffer.array[a];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const n of e||[]){t+=4,t+=1;for(const i of n.textColliders)t+=10;for(const i of n.iconColliders)t+=10;t+=1,t+=2*n.textVertexRanges.length,t+=1,t+=2*n.iconVertexRanges.length}return t}static serializeSymbols(e,t,n,i,r){t[i++]=(r=r||[]).length;for(const a of r){t[i++]=a.anchor.x,t[i++]=a.anchor.y,t[i++]=a.symbolFeature.hash,t[i++]=a.symbolFeature.priority,t[i++]=a.textColliders.length+a.iconColliders.length;for(const o of a.textColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;for(const o of a.iconColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;t[i++]=a.textVertexRanges.length;for(const[o,l]of a.textVertexRanges)t[i++]=o,t[i++]=l;t[i++]=a.iconVertexRanges.length;for(const[o,l]of a.iconVertexRanges)t[i++]=o,t[i++]=l}return i}_replaceKeys(e,t){return e.replace(/{([^{}]+)}/g,(n,i)=>i in t?t[i]:"")}_processFeature(e,t,n){const{line:i,iconMosaicItem:r,shaping:a,anchor:o}=e,l=this.zoom,u=this.layer,f=!!r;let d=!0;f&&(d=(null==t?void 0:t.optional)||!r);const h=a&&a.length>0,y=!h||(null==n?void 0:n.optional);let g,m;if(f&&(g=this._placementEngine.getIconPlacement(o,r,t)),(g||d)&&(h&&(m=this._placementEngine.getTextPlacement(o,a,i,n)),m||y)){if(g&&m||(y||d?y||m?d||g||(m=null):g=null:(g=null,m=null)),m){const T=u.hasDataDrivenText?u.textMaterial.encodeAttributes(e.symbolFeature.feature,l,u):null;if(this._storePlacedGlyphs(e,m.shapes,l,n.rotationAlignment,T),m.textColliders){e.textColliders=m.textColliders;for(const x of m.textColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,D=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,L=x.dxPixels*M+(x.dyPixels+x.height)*p,E=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,E),k=Math.max(B,P,b,E),R=Math.min(I,D,L,w),U=Math.max(I,D,L,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}if(g){const T=u.hasDataDrivenIcon?u.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,u):null;if(this._addPlacedIcons(e,g.shapes,l,r.page,t.rotationAlignment===A.aF.VIEWPORT,T),g.iconColliders){e.iconColliders=g.iconColliders;for(const x of g.iconColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,D=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,L=x.dxPixels*M+(x.dyPixels+x.height)*p,E=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,E),k=Math.max(B,P,b,E),R=Math.min(I,D,L,w),U=Math.max(I,D,L,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}}}_addPlacedIcons(e,t,n,i,r,a){const o=Math.max(n-1,0),l=this._iconVertexBuffer,u=this._iconIndexBuffer,f=this._markerMap;for(const d of t){const h=r?0:Math.max(n+(0,v.k3)(d.minzoom),o),y=r?25:Math.min(n+(0,v.k3)(d.maxzoom),25);if(y<=h)continue;const g=d.tl,m=d.tr,T=d.bl,x=d.br,_=d.mosaicRect,p=d.labelAngle,M=d.minAngle,B=d.maxAngle,I=d.anchor,P=l.index,D=_.x,b=_.y,L=D+_.width,E=b+_.height,w=l.index;l.add(I.x,I.y,g.x,g.y,D,b,p,M,B,h,y,a),l.add(I.x,I.y,m.x,m.y,L,b,p,M,B,h,y,a),l.add(I.x,I.y,T.x,T.y,D,E,p,M,B,h,y,a),l.add(I.x,I.y,x.x,x.y,L,E,p,M,B,h,y,a),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===w?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([w,4]),u.add(P+0,P+1,P+2),u.add(P+1,P+2,P+3),f.has(i)?f.get(i)[1]+=6:f.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,n=this._glyphMap;for(const[i,r]of this._glyphBufferDataStorage)for(const a of r){const o=e.index,l=a.symbolInstance,u=a.ddAttributes,f=e.index;e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tl[0],a.tl[1],a.xmin,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tr[0],a.tr[1],a.xmax,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.bl[0],a.bl[1],a.xmin,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.br[0],a.br[1],a.xmax,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),l.textVertexRanges.length>0&&l.textVertexRanges[0][0]+l.textVertexRanges[0][1]===f?l.textVertexRanges[0][1]+=4:l.textVertexRanges.push([f,4]),t.add(o+0,o+1,o+2),t.add(o+1,o+2,o+3),n.has(i)?n.get(i)[1]+=6:n.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,n,i,r){const a=Math.max(n-1,0),o=i===A.aF.VIEWPORT;let l,u,f,d,h,y,g,m,T,x,_;for(const p of t)l=o?0:Math.max(n+(0,v.k3)(p.minzoom),a),u=o?25:Math.min(n+(0,v.k3)(p.maxzoom),25),!(u<=l)&&(f=p.tl,d=p.tr,h=p.bl,y=p.br,g=p.labelAngle,m=p.minAngle,T=p.maxAngle,x=p.anchor,_=p.mosaicRect,this._glyphBufferDataStorage.has(p.page)||this._glyphBufferDataStorage.set(p.page,[]),this._glyphBufferDataStorage.get(p.page).push({glyphAnchor:[x.x,x.y],tl:[f.x,f.y],tr:[d.x,d.y],bl:[h.x,h.y],br:[y.x,y.y],xmin:_.x,ymin:_.y,xmax:_.x+_.width,ymax:_.y+_.height,labelAngle:g,minAngle:m,maxAngle:T,minLod:l,maxLod:u,placementLod:a,symbolInstance:e,ddAttributes:r}))}static _pushAnchors(e,t,n,i){n+=i;let r=0;const a=t.length-1;for(let h=0;h<a;h++)r+=V.E9.distance(t[h],t[h+1]);let o=i||n;if(o*=.5,r<=o)return;const l=o/r;let u=0,f=-(n=r/Math.max(Math.round(r/n),1))/2;const d=t.length-1;for(let h=0;h<d;h++){const y=t[h],g=t[h+1],m=g.x-y.x,T=g.y-y.y,x=Math.sqrt(m*m+T*T);let _;for(;f+n<u+x;){f+=n;const p=(f-u)/x,M=(0,v.sX)(y.x,g.x,p),B=(0,v.sX)(y.y,g.y,p);void 0===_&&(_=Math.atan2(T,m)),e.push(new he(M,B,_,h,l))}u+=x}}static _pushCenterAnchor(e,t){let n=0;const i=t.length-1;for(let l=0;l<i;l++)n+=V.E9.distance(t[l],t[l+1]);const r=n/2;let a=0;const o=t.length-1;for(let l=0;l<o;l++){const u=t[l],f=t[l+1],d=f.x-u.x,h=f.y-u.y,y=Math.sqrt(d*d+h*h);if(r<a+y){const g=(r-a)/y,m=(0,v.sX)(u.x,f.x,g),T=(0,v.sX)(u.y,f.y,g),x=Math.atan2(h,d);return void e.push(new he(m,T,x,l,0))}a+=y}}static _deviation(e,t,n){return Math.atan2((t.x-e.x)*(n.y-t.y)-(t.y-e.y)*(n.x-t.x),(t.x-e.x)*(n.x-t.x)+(t.y-e.y)*(n.y-t.y))}static _honorsTextMaxAngle(e,t,n,i,r){let a=0;const o=n/2;let l=new V.E9(t.x,t.y),u=t.segment+1;for(;a>-o;){if(--u,u<0)return!1;a-=V.E9.distance(e[u],l),l=e[u]}a+=V.E9.distance(e[u],e[u+1]);const f=[];let d=0;const h=e.length;for(;a<o;){const y=e[u];let g,m=u;do{if(++m,m===h)return!1;g=e[m]}while(g.isEqual(y));let T,x=m;do{if(++x,x===h)return!1;T=e[x]}while(T.isEqual(g));const _=this._deviation(y,g,T);for(f.push({deviation:_,distToAnchor:a}),d+=_;a-f[0].distToAnchor>r;)d-=f.shift().deviation;if(Math.abs(d)>i)return!1;a+=V.E9.distance(g,T),u=m}return!0}static _smoothVertices(e,t){if(t<=0)return e;let n=e.length;if(n<3)return e;const i=[];let r=0,a=0;i.push(0);for(let m=1;m<n;m++){const T=V.E9.distance(e[m],e[m-1]);T>0&&(r+=T,i.push(r),a++,a!==m&&(e[a]=e[m]))}if(n=a+1,n<3)return e;t=Math.min(t,.2*r);const o=e[0].x,l=e[0].y,u=e[n-1].x,f=e[n-1].y,d=V.E9.sub(e[0],e[1]);d.normalize(),e[0].x+=t*d.x,e[0].y+=t*d.y,d.assignSub(e[n-1],e[n-2]),d.normalize(),e[n-1].x+=t*d.x,e[n-1].y+=t*d.y,i[0]-=t,i[n-1]+=t;const h=[];h.push(new V.E9(o,l));const y=1e-6,g=.5*t;for(let m=1;m<n-1;m++){let T=0,x=0,_=0;for(let p=m-1;p>=0;p--){const M=g+i[p+1]-i[m];if(M<0)break;const B=i[p+1]-i[p],I=i[m]-i[p]<g?1:M/B;if(I<y)break;const P=I*I,D=I*M-.5*P*B,b=I*B/t,L=e[p+1],E=e[p].x-L.x,w=e[p].y-L.y;T+=b/D*(L.x*I*M+.5*P*(M*E-B*L.x)-P*I*B*E/3),x+=b/D*(L.y*I*M+.5*P*(M*w-B*L.y)-P*I*B*w/3),_+=b}for(let p=m+1;p<n;p++){const M=g-i[p-1]+i[m];if(M<0)break;const B=i[p]-i[p-1],I=i[p]-i[m]<g?1:M/B;if(I<y)break;const P=I*I,D=I*M-.5*P*B,b=I*B/t,L=e[p-1],E=e[p].x-L.x,w=e[p].y-L.y;T+=b/D*(L.x*I*M+.5*P*(M*E-B*L.x)-P*I*B*E/3),x+=b/D*(L.y*I*M+.5*P*(M*w-B*L.y)-P*I*B*w/3),_+=b}h.push(new V.E9(T/_,x/_))}return h.push(new V.E9(u,f)),e[0].x=o,e[0].y=l,e[n-1].x=u,e[n-1].y=f,h}static _pushCentroid(e,t){const o=t.length-1;let l=0,u=0,f=0,d=t[0].x,h=t[0].y;d>4096&&(d=4096),d<0&&(d=0),h>4096&&(h=4096),h<0&&(h=0);for(let y=1;y<o;y++){let g=t[y].x,m=t[y].y,T=t[y+1].x,x=t[y+1].y;g>4096&&(g=4096),g<0&&(g=0),m>4096&&(m=4096),m<0&&(m=0),T>4096&&(T=4096),T<0&&(T=0),x>4096&&(x=4096),x<0&&(x=0);const _=(g-d)*(x-h)-(T-d)*(m-h);l+=_*(d+g+T),u+=_*(h+m+x),f+=_}l/=3*f,u/=3*f,isNaN(l)||isNaN(u)||e.push(new he(l,u))}}Z._bidiEngine=new rt.Z,function(c){c[c.INITIALIZED=0]="INITIALIZED",c[c.NO_DATA=1]="NO_DATA",c[c.READY=2]="READY",c[c.MODIFIED=3]="MODIFIED",c[c.INVALID=4]="INVALID"}(X||(X={}));class ct{constructor(e,t,n,i,r){var f,d;if(this._pbfTiles={},this._tileClippers={},this._client=n,this._tile=t,r){this._styleLayerUIDs=new Set;for(const h of r)this._styleLayerUIDs.add(h)}this._styleRepository=i,this._layers=null!=(d=null==(f=this._styleRepository)?void 0:f.layers)?d:[];const[a,o,l]=t.tileKey.split("/").map(parseFloat);this._level=a;const u=8+Math.max(5*(this._level-14),0);for(const h of Object.keys(e)){const y=e[h];if(this._pbfTiles[h]=new je.Z(new Uint8Array(y.protobuff),new DataView(y.protobuff)),y.refKey){const[g]=y.refKey.split("/").map(parseFloat),m=a-g;if(m>0){const T=(1<<m)-1;this._tileClippers[h]=new V.bN(m,o&T,l&T,8,u)}}this._tileClippers[h]||(this._tileClippers[h]=new V.I6)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}parse(e){var t=this;return(0,le.Z)(function*(){const n=(0,Re.j)(),i=t._initialize(e),{returnedBuckets:r}=i;t._processLayers(i),t._linkReferences(i),t._filterFeatures(i);const a=[],o=new Set,l=(d,h)=>{o.has(d)||(a.push({name:d,repeat:h}),o.add(d))},u={};for(const d of r)d.getResources(d.tileClipper,l,u);if(t._tile.status===X.INVALID)return[];const f=t._fetchResources(a,u,e);return Promise.all([...f,n]).then(()=>t._processFeatures(i.returnedBuckets))})()}_initialize(e){return{signal:e&&e.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,layers:n,zoom:i,sourceNameToTileClipper:r,sourceNameToUniqueSourceLayerBuckets:a,sourceNameToUniqueSourceLayers:o,returnedBuckets:l,layerIdToBucket:u,referencerUIDToReferencedId:f}=e;for(let d=n.length-1;d>=0;d--){const h=n[d];if(!this._canParseStyleLayer(h.uid)||h.minzoom&&i<Math.floor(h.minzoom)||h.maxzoom&&i>=h.maxzoom||h.type===A.fR.BACKGROUND||!t[h.source]||!r[h.source])continue;const g=r[h.source],m=h.sourceLayer,T=t[h.source][m];if(T){let x=o[h.source];if(x||(x=o[h.source]=new Set),x.add(h.sourceLayer),h.refLayerId)f.set(h.uid,h.refLayerId);else{const _=this._createBucket(h);if(_){_.layerUIDs=[h.uid],_.layerExtent=T.extent,_.tileClipper=g;let p=a[h.source];p||(p=a[h.source]={});let M=p[m];M||(M=p[m]=[]),M.push(_),l.push(_),u[h.id]=_}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:n}=e;n.forEach((i,r)=>{t[i]&&t[i].layerUIDs.push(r)})}_filterFeatures(e){const{signal:t,sourceNameToTileData:n,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:r}=e,a=10*this._level,o=10*(this._level+1),l=[],u=[];for(const f of Object.keys(r))r[f].forEach(d=>{l.push(d),u.push(f)});for(let f=0;f<l.length;f++){const d=u[f],h=l[f];if(!n[d]||!i[d])continue;const y=n[d][h],g=i[d][h];if(!g||0===g.length)continue;if((0,me.Hc)(t))return;const m=y.getData();for(;m.nextTag(2);){const T=m.getMessage(),x=new Ye(T,y);T.release();const _=x.values;if(_){const p=_._minzoom;if(p&&p>=o)continue;const M=_._maxzoom;if(M&&M<=a)continue}for(const p of g)p.pushFeature(x)}}}_fetchResources(e,t,n){const i=[],r=this._tile.getWorkerTileHandler();let a,o;e.length>0&&(a=r.fetchSprites(e,this._client,n),i.push(a));for(const l in t){const u=t[l];u.size>0&&(o=r.fetchGlyphs(this._tile.tileKey,l,u,this._client,n),i.push(o))}return i}_processFeatures(e){const t=e.filter(n=>n.hasFeatures()||this._canParseStyleLayer(n.layer.uid));for(const n of t)n.processFeatures(n.tileClipper);return t}_parseTileData(e){const t={};for(const n of Object.keys(e)){const i=e[n],r={};for(;i.next();)switch(i.tag()){case 3:{const a=i.getMessage(),o=new Ie(a);a.release(),r[o.name]=o;break}default:i.skip()}t[n]=r}return t}_createBucket(e){switch(e.type){case A.fR.BACKGROUND:return null;case A.fR.FILL:return this._createFillBucket(e);case A.fR.LINE:return this._createLineBucket(e);case A.fR.CIRCLE:return this._createCircleBucket(e);case A.fR.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new Me(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Xe(e.fillMaterial.getStride()),new ne,new Qe(e.outlineMaterial.getStride()),new ne)}_createLineBucket(e){return new st(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Je(e.lineMaterial.getStride()),new ne)}_createCircleBucket(e){return new qe(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new $e(e.circleMaterial.getStride()),new ne)}_createSymbolBucket(e){const t=this._tile;return new Z(e,this._level,new Se(e.iconMaterial.getStride()),new ne,new Se(e.textMaterial.getStride()),new ne,t.placementEngine,t.getWorkerTileHandler())}}class ut{constructor(e,t,n,i){this.status=X.INITIALIZED,this.placementEngine=new We,this.tileKey=e,this.refKeys=t,this._workerTileHandler=n,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=X.INITIALIZED,this._workerTileHandler=null}parse(e,t){var n=this;return(0,le.Z)(function*(){const i=t&&t.signal;if((0,be.pC)(i)){const d=()=>{i.removeEventListener("abort",d),n.status=X.INVALID};i.addEventListener("abort",d)}let r;const a={bucketsWithData:[],emptyBuckets:null};try{r=yield n._parse(e,t)}catch(d){if((0,me.D_)(d))throw d;return{result:a,transferList:[]}}n.status=X.READY;const o=a.bucketsWithData,l=[];for(const d of r)if(d.hasFeatures()){const h=d.serialize();o.push(h)}else l.push(d.layer.uid);const u=[...o];let f=null;return l.length>0&&(f=Uint32Array.from(l),u.push(f.buffer)),a.emptyBuckets=f,{result:a,transferList:u}})()}setObsolete(){this.status=X.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}_parse(e,t){var n=this;return(0,le.Z)(function*(){const i=e.sourceName2DataAndRefKey;return 0===Object.keys(i).length?[]:(n.status=X.MODIFIED,new ct(i,n,t.client,n._styleRepository,e.styleLayerUIDs).parse(t))})()}}var ft=C(78364);class dt{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){var e,t;return null!=(t=null==(e=this._styleRepository)?void 0:e.layers)?t:[]}createTileAndParse(e,t){var n=this;return(0,le.Z)(function*(){const{key:i}=e,r={};for(const o of Object.keys(e.sourceName2DataAndRefKey))r[o]=e.sourceName2DataAndRefKey[o].refKey;const a=new ut(i,r,n,n._styleRepository);try{return yield a.parse(e,t)}catch(o){if(a.setObsolete(),a.release(),!(0,me.D_)(o))throw o;return null}})()}updateStyle(e){if(!e||0===e.length||!this._styleRepository)return;const t=this._styleRepository;for(const n of e){const r=n.data;switch(n.type){case J.Fr.PAINTER_CHANGED:t.setPaintProperties(r.layer,r.paint);break;case J.Fr.LAYOUT_CHANGED:t.setLayoutProperties(r.layer,r.layout);break;case J.Fr.LAYER_REMOVED:t.deleteStyleLayer(r.layer);break;case J.Fr.LAYER_CHANGED:t.setStyleLayer(r.layer,r.index);break;case J.Fr.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(e){this._styleRepository=new ft.Z(e),this._spriteInfo={},this._glyphInfo={}}fetchSprites(e,t,n){const i=[],r=this._spriteInfo;for(const a of e)void 0===r[a.name]&&i.push(a);return 0===i.length?Promise.resolve():t.invoke("getSprites",i,{signal:n&&n.signal}).then(a=>{for(const o in a)r[o]=a[o]})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(e,t,n,i,r){const a=[];let o=this._glyphInfo[t];return o?n.forEach(l=>{o[l]||a.push(l)}):(o=this._glyphInfo[t]=[],n.forEach(l=>a.push(l))),0===a.length?Promise.resolve():i.invoke("getGlyphs",{tileID:e,font:t,codePoints:a},r).then(l=>{for(let u=0;u<l.length;u++)l[u]&&(o[u]=l[u])})}getGlyphItems(e){return this._glyphInfo[e]}}}}]);