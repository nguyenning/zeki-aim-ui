"use strict";(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[195],{90195:(xt,Be,C)=>{C.r(Be),C.d(Be,{default:()=>yt});var le=C(15861),me=C(10699),Y=C(919),He=C(62208),v=C(86575);function Ke(u){return!(u<11904)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=65280&&u<=65519||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543||u>=65040&&u<=65055||u>=42128&&u<=42191||u>=40960&&u<=42127)}function We(u){switch(u){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function be(u){switch(u){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}var we=C(84439);const Z=24;class De{constructor(e,t,n,i,r,a,o){this._glyphItems=e,this._maxWidth=t,this._lineHeight=n,this._letterSpacing=i,this._hAnchor=r,this._vAnchor=a,this._justify=o}getShaping(e,t,n){const i=this._letterSpacing,r=this._lineHeight,a=this._justify,o=this._maxWidth,l=[];let c=0,f=0;const d=e.length;for(let p=0;p<d;p++){const M=e.charCodeAt(p),B=n&&(746===(u=M)||747===u||!(u<4352)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103&&!(u>=65097&&u<=65103)||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351&&!(u>=12296&&u<=12305||u>=12308&&u<=12319||12336===u)||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=12592&&u<=12687||u>=43360&&u<=43391||u>=55216&&u<=55295||u>=4352&&u<=4607||u>=44032&&u<=55215||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12688&&u<=12703||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543&&12540!==u||u>=65280&&u<=65519&&!(65288===u||65289===u||65293===u||u>=65306&&u<=65310||65339===u||65341===u||65343===u||u>=65371&&u<=65503||65507===u||u>=65512&&u<=65519)||u>=65104&&u<=65135&&!(u>=65112&&u<=65118||u>=65123&&u<=65126)||u>=5120&&u<=5759||u>=6320&&u<=6399||u>=65040&&u<=65055||u>=19904&&u<=19967||u>=40960&&u<=42127||u>=42128&&u<=42191));let I;for(const P of this._glyphItems)if(I=P[M],I)break;l.push({codePoint:M,x:c,y:f,vertical:B,glyphMosaicItem:I}),I&&(c+=I.metrics.advance+i)}var u;let h=c;o>0&&(h=c/Math.max(1,Math.ceil(c/o)));const y=e.includes("\u200b"),g=[];for(let p=0;p<d-1;p++){const M=l[p].codePoint,B=Ke(M);if(We(M)||B){let I=0;if(10===M)I-=1e4;else if(B&&y)I+=150;else{40!==M&&65288!==M||(I+=50);const P=l[p+1].codePoint;41!==P&&65289!==P||(I+=50)}g.push(this._buildBreak(p+1,l[p].x,h,g,I,!1))}}const m=this._optimalBreaks(this._buildBreak(d,c,h,g,0,!0));let T=0;const x=t?-r:r;let _=0;for(let p=0;p<m.length;p++){const M=m[p];let B=_;for(;B<M&&be(l[B].codePoint);)l[B].glyphMosaicItem=null,++B;let I=M-1;for(;I>B&&be(l[I].codePoint);)l[I].glyphMosaicItem=null,--I;if(B<=I){const P=l[B].x;for(let b=B;b<=I;b++)l[b].x-=P,l[b].y=f;let L=l[I].x;l[I].glyphMosaicItem&&(L+=l[I].glyphMosaicItem.metrics.advance),T=Math.max(L,T),a&&this._applyJustification(l,B,I)}_=M,f+=x}if(l.length>0){const p=m.length-1,M=(a-this._hAnchor)*T;let B=(-this._vAnchor*(p+1)+.5)*r;t&&p&&(B+=p*r);for(const I of l)I.x+=M,I.y+=B}return l.filter(p=>p.glyphMosaicItem)}static getTextBox(e,t){if(!e.length)return null;let n=1/0,i=1/0,r=0,a=0;for(const o of e){const c=o.x,f=o.y-17,d=c+o.glyphMosaicItem.metrics.advance,h=f+t;n=Math.min(n,c),r=Math.max(r,d),i=Math.min(i,f),a=Math.max(a,h)}return{x:n,y:i,width:r-n,height:a-i}}static getBox(e){if(!e.length)return null;let t=1/0,n=1/0,i=0,r=0;for(const a of e){const{height:o,left:l,top:c,width:f}=a.glyphMosaicItem.metrics,d=a.x,h=a.y-(o-Math.abs(c)),y=d+f+l,g=h+o;t=Math.min(t,d),i=Math.max(i,y),n=Math.min(n,h),r=Math.max(r,g)}return{x:t,y:n,width:i-t,height:r-n}}static addDecoration(e,t){const n=e.length;if(0===n)return;let r=e[0].x+e[0].glyphMosaicItem.metrics.left,a=e[0].y;for(let l=1;l<n;l++){const c=e[l];if(c.y!==a){const f=e[l-1].x+e[l-1].glyphMosaicItem.metrics.left+e[l-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:r,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new we.Z(4,0,4,8),metrics:{width:f-r,height:8,left:0,top:0,advance:0},page:0,code:0}}),a=c.y,r=c.x+c.glyphMosaicItem.metrics.left}}const o=e[n-1].x+e[n-1].glyphMosaicItem.metrics.left+e[n-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:r,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new we.Z(4,0,4,8),metrics:{width:o-r,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(e,t,n,i){const r=(e-t)*(e-t);return i?e<t?r/2:2*r:r+Math.abs(n)*n}_buildBreak(e,t,n,i,r,a){let o=null,l=this._breakScore(t,n,r,a);for(const c of i){const d=this._breakScore(t-c.x,n,r,a)+c.score;d<=l&&(o=c,l=d)}return{index:e,x:t,score:l,previousBreak:o}}_optimalBreaks(e){return e?this._optimalBreaks(e.previousBreak).concat(e.index):[]}_applyJustification(e,t,n){const i=e[n],a=(i.x+(i.vertical?Z:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0))*this._justify;for(let o=t;o<=n;o++)e[o].x-=a}}var Ve=C(47132),V=C(1268),E=C(97938);const q=.5;class he{constructor(e,t,n=0,i=-1,r=q){this.x=e,this.y=t,this.angle=n,this.segment=i,this.minzoom=r}}class ce{constructor(e,t,n,i,r,a=q,o=v.B1){this.anchor=e,this.labelAngle=t,this.glyphAngle=n,this.page=i,this.alternateVerticalGlyph=r,this.minzoom=a,this.maxzoom=o}}class ve{constructor(e,t,n,i,r,a,o,l,c,f,d,h){this.tl=e,this.tr=t,this.bl=n,this.br=i,this.mosaicRect=r,this.labelAngle=a,this.minAngle=o,this.maxAngle=l,this.anchor=c,this.minzoom=f,this.maxzoom=d,this.page=h}}class Ae{constructor(e){this.shapes=e}}class je{getIconPlacement(e,t,n){const i=new E.E(e.x,e.y),r=n.rotationAlignment===V.aF.MAP,a=n.keepUpright;let o=n.rotate*v.DT;r&&(o+=e.angle);const l=new Ae([]);return n.allowOverlap&&n.ignorePlacement||!Ve.Bf||(l.iconColliders=[]),this._addIconPlacement(l,i,t,n,o),r&&a&&this._addIconPlacement(l,i,t,n,o+v.JJ),l}_addIconPlacement(e,t,n,i,r){const a=n.pixelRatio,o=n.width/a,l=n.height/a,c=i.offset;let f=c[0],d=c[1];switch(i.anchor){case V.nR.CENTER:f-=o/2,d-=l/2;break;case V.nR.LEFT:d-=l/2;break;case V.nR.RIGHT:f-=o,d-=l/2;break;case V.nR.TOP:f-=o/2;break;case V.nR.BOTTOM:f-=o/2,d-=l;break;case V.nR.TOP_LEFT:break;case V.nR.BOTTOM_LEFT:d-=l;break;case V.nR.TOP_RIGHT:f-=o;break;case V.nR.BOTTOM_RIGHT:f-=o,d-=l}const h=n.rect,y=2/a,g=f-y,m=d-y,T=g+h.width/a,x=m+h.height/a,_=new E.E(g,m),p=new E.E(T,x),M=new E.E(g,x),B=new E.E(T,m);if(0!==r){const P=Math.cos(r),L=Math.sin(r);_.rotate(P,L),p.rotate(P,L),M.rotate(P,L),B.rotate(P,L)}const I=new ve(_,B,M,p,h,r,0,256,t,q,v.B1,0);if(e.shapes.push(I),(!i.allowOverlap||!i.ignorePlacement)&&Ve.Bf){const P=i.size,L=i.padding;e.iconColliders.push({xTile:t.x,yTile:t.y,dxPixels:f*P-L,dyPixels:d*P-L,hard:!i.optional,partIndex:0,width:o*P+2*L,height:l*P+2*L,angle:r,minLod:q,maxLod:v.B1})}}getTextPlacement(e,t,n,i){const r=new E.E(e.x,e.y),a=i.rotate*v.DT,o=i.rotationAlignment===V.aF.MAP,l=i.keepUpright,c=i.padding;let f=q;const d=o?e.angle:0,h=e.segment>=0&&o,y=i.allowOverlap&&i.ignorePlacement?null:[],g=[],T=!h;let x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_;const B=(h||o)&&l,I=i.size/Z;let P=!1;for(const w of t)if(w.vertical){P=!0;break}let L,b=0,D=0;if(!h&&P){const w=De.getTextBox(t,i.lineHeight*Z);switch(i.anchor){case V.nR.LEFT:b=w.height/2,D=-w.width/2;break;case V.nR.RIGHT:b=-w.height/2,D=w.width/2;break;case V.nR.TOP:b=w.height/2,D=w.width/2;break;case V.nR.BOTTOM:b=-w.height/2,D=-w.width/2;break;case V.nR.TOP_LEFT:b=w.height;break;case V.nR.BOTTOM_LEFT:D=-w.width;break;case V.nR.TOP_RIGHT:D=w.width;break;case V.nR.BOTTOM_RIGHT:b=-w.height}}b+=i.offset[0]*Z,D+=i.offset[1]*Z;for(const w of t){const S=w.glyphMosaicItem;if(!S||S.rect.isEmpty)continue;const k=S.rect,R=S.metrics,U=S.page;if(y&&T){if(void 0!==L&&L!==w.y){let F,N,W,j;P?(F=-M+b,N=x+D,W=M-p,j=_-x):(F=x+b,N=p+D,W=_-x,j=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:F*I-c,dyPixels:N*I-c,hard:!i.optional,partIndex:1,width:W*I+2*c,height:j*I+2*c,angle:a,minLod:q,maxLod:v.B1}),x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_}L=w.y}const ee=[];if(h){const N=(w.x+R.left-4+.5*S.metrics.width)*I*8;if(f=this._placeGlyph(e,f,N,n,e.segment,1,w.vertical,U,ee),l&&(f=this._placeGlyph(e,f,N,n,e.segment,-1,w.vertical,U,ee)),f>=2)break}else ee.push(new ce(r,d,d,U,!1)),o&&l&&ee.push(new ce(r,d+v.JJ,d+v.JJ,U,!1));const H=w.x+R.left,X=w.y-17-R.top,te=H+R.width,Te=X+R.height;let z,K,fe,de,se,ye,Ne,Ge;!h&&P?w.vertical?(z=new E.E(-((X+Te)/2+R.width/2)-4+b,(H+te)/2-R.height/2-4+D),K=new E.E(z.x+k.width,z.y+k.height),fe=new E.E(z.x,K.y),de=new E.E(K.x,z.y)):(z=new E.E(4-X+b,H-4+D),K=new E.E(z.x-k.height,z.y+k.width),fe=new E.E(K.x,z.y),de=new E.E(z.x,K.y)):(z=new E.E(H-4+b,X-4+D),K=new E.E(z.x+k.width,z.y+k.height),fe=new E.E(z.x,K.y),de=new E.E(K.x,z.y));for(const F of ee){let N,W,j,Q;F.alternateVerticalGlyph?(se||(se=new E.E((H+te)/2+b-R.height/2-4,(X+Te)/2+D+R.width/2+4),ye=new E.E(se.x+k.height,se.y-k.width),Ne=new E.E(ye.x,se.y),Ge=new E.E(se.x,ye.y)),N=se,W=Ne,j=Ge,Q=ye):(N=z,W=fe,j=de,Q=K);const xe=X,Pe=Te,ge=F.glyphAngle+a;if(0!==ge){const $=Math.cos(ge),pe=Math.sin(ge);N=N.clone(),W=W.clone(),j=j.clone(),Q=Q.clone(),N.rotate($,pe),Q.rotate($,pe),W.rotate($,pe),j.rotate($,pe)}let ae=0,oe=256;h&&P?w.vertical?F.alternateVerticalGlyph?(ae=32,oe=96):(ae=224,oe=32):(ae=224,oe=96):(ae=192,oe=64),g.push(new ve(N,j,W,Q,k,F.labelAngle,ae,oe,F.anchor,F.minzoom,F.maxzoom,F.page)),!y||B&&!this._legible(F.labelAngle)||(T?(H<x&&(x=H),xe<p&&(p=xe),te>_&&(_=te),Pe>M&&(M=Pe)):F.minzoom<2&&y.push({xTile:e.x,yTile:e.y,dxPixels:(H+b)*I-c,dyPixels:(xe+b)*I-c,hard:!i.optional,partIndex:1,width:(te-H)*I+2*c,height:(Pe-xe)*I+2*c,angle:ge,minLod:F.minzoom,maxLod:F.maxzoom}))}}if(f>=2)return null;if(y&&T){let w,S,k,R;P?(w=-M+b,S=x+D,k=M-p,R=_-x):(w=x+b,S=p+D,k=_-x,R=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:w*I-c,dyPixels:S*I-c,hard:!i.optional,partIndex:1,width:k*I+2*c,height:R*I+2*c,angle:a,minLod:q,maxLod:v.B1})}const A=new Ae(g);return y&&y.length>0&&(A.textColliders=y),A}_legible(e){const t=(0,v.Or)(e);return t<65||t>=193}_placeGlyph(e,t,n,i,r,a,o,l,c){let f=a;const d=f<0?(0,v.DQ)(e.angle+v.JJ,v._U):e.angle;let h=0;n<0&&(f*=-1,n*=-1,h=v.JJ),f>0&&++r;let y=new E.E(e.x,e.y),g=i[r],m=v.B1;if(i.length<=r)return m;for(;;){const T=g.x-y.x,x=g.y-y.y,_=Math.sqrt(T*T+x*x),p=Math.max(n/_,t),I=(0,v.DQ)(Math.atan2(x/_,T/_)+h,v._U);if(c.push(new ce(y,d,I,l,!1,p,m)),o&&c.push(new ce(y,d,I,l,!0,p,m)),p<=t)return p;y=g.clone();do{if(i.length<=(r+=f)||r<0)return p;g=i[r]}while(y.isEqual(g));let P=g.x-y.x,L=g.y-y.y;const b=Math.sqrt(P*P+L*L);P*=_/b,L*=_/b,y.x-=P,y.y-=L,m=p}}}var ie,u,Ye=C(24192),ke=C(58774);(u=ie||(ie={}))[u.moveTo=1]="moveTo",u[u.lineTo=2]="lineTo",u[u.close=7]="close";class Je{constructor(e,t){this.values={};const n=t.keys,i=t.values;for(;e.next();)switch(e.tag()){case 1:this.id=e.getUInt64();break;case 2:{const r=e.getMessage(),a=this.values;for(;!r.empty();){const o=r.getUInt32(),l=r.getUInt32();a[n[o]]=i[l]}r.release();break}case 3:this.type=e.getUInt32();break;case 4:this._pbfGeometry=e.getMessage();break;default:e.skip()}}getGeometry(e){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const t=this._pbfGeometry;let n,i;this._pbfGeometry=null,e?e.reset(this.type):n=[];let r,a=ie.moveTo,o=0,l=0,c=0;for(;!t.empty();){if(0===o){const f=t.getUInt32();a=7&f,o=f>>3}switch(o--,a){case ie.moveTo:l+=t.getSInt32(),c+=t.getSInt32(),e?e.moveTo(l,c):(i&&n.push(i),i=[],i.push(new E.E(l,c)));break;case ie.lineTo:l+=t.getSInt32(),c+=t.getSInt32(),e?e.lineTo(l,c):i.push(new E.E(l,c));break;case ie.close:e?e.close():i&&!i[0].equals(l,c)&&i.push(i[0].clone());break;default:throw t.release(),new Error("Invalid path operation")}}return e?r=e.result():(i&&n.push(i),r=n),t.release(),this._geometry=r,r}}var O=C(36243);class ne extends O.Z{constructor(){super(12)}add(e,t,n){const i=this.array;i.push(e),i.push(t),i.push(n)}}class Ie{constructor(e){for(this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=e.clone();e.next();)switch(e.tag()){case 1:this.name=e.getString();break;case 3:this.keys.push(e.getString());break;case 4:this.values.push(e.processMessage(Ie._parseValue));break;case 5:this.extent=e.getUInt32();break;default:e.skip()}}getData(){return this._pbfLayer}static _parseValue(e){for(;e.next();)switch(e.tag()){case 1:return e.getString();case 2:return e.getFloat();case 3:return e.getDouble();case 4:return e.getInt64();case 5:return e.getUInt64();case 6:return e.getSInt64();case 7:return e.getBool();default:e.skip()}return null}}class Xe extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o,l,c,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g);const m=31;g=O.Z.i8888to32(Math.round(m*n),Math.round(m*i),Math.round(m*r),Math.round(m*a)),y.push(g),g=O.Z.i8888to32(Math.round(m*o),Math.round(m*l),Math.round(m*c),Math.round(m*f)),y.push(g),g=O.Z.i1616to32(d,0),y.push(g),h&&y.push(...h)}}class Qe extends O.Z{constructor(e){super(e)}add(e,t,n){const i=this.array;i.push(O.Z.i1616to32(e,t)),n&&i.push(...n)}}class $e extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o){const l=this.array,c=this.index;let f=O.Z.i1616to32(e,t);return l.push(f),f=O.Z.i8888to32(Math.round(15*n),Math.round(15*i),r,a),l.push(f),o&&l.push(...o),c}}class Re extends O.Z{constructor(e){super(e)}add(e,t,n,i,r,a,o,l,c,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g),g=O.Z.i1616to32(Math.round(8*n),Math.round(8*i)),y.push(g),g=O.Z.i8888to32(r/4,a/4,l,c),y.push(g),g=O.Z.i8888to32(0,(0,v.Or)(o),10*f,Math.min(10*d,255)),y.push(g),h&&y.push(...h)}}class qe extends O.Z{constructor(e){super(e)}add(e,t,n,i,r){const a=this.array,o=O.Z.i1616to32(2*e+n,2*t+i);a.push(o),r&&a.push(...r)}}class ue{constructor(e,t,n){this.layerExtent=4096,this._features=[],this.layer=e,this.zoom=t,this._spriteInfo=n,this._filter=e.getFeatureFilter()}pushFeature(e){this._filter&&!this._filter.filter(e,this.zoom)||this._features.push(e)}hasFeatures(){return this._features.length>0}getResources(e,t,n){}}class et extends ue{constructor(e,t,n,i,r){super(e,t,n),this.type=Y.al.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=r}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(e){const t=this._circleVertexBuffer,n=this._circleIndexBuffer;this._circleIndexStart=3*n.index,this._circleIndexCount=0;const i=this.layer,r=this.zoom;e&&e.setExtent(this.layerExtent);for(const a of this._features){const o=a.getGeometry(e);if(!o)continue;const l=i.circleMaterial.encodeAttributes(a,r,i);for(const c of o)if(c)for(const f of c){const d=t.index;t.add(f.x,f.y,0,0,l),t.add(f.x,f.y,0,1,l),t.add(f.x,f.y,1,0,l),t.add(f.x,f.y,1,1,l),n.add(d+0,d+1,d+2),n.add(d+1,d+2,d+3),this._circleIndexCount+=6}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this._circleVertexBuffer.array.length,e+=this._circleIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)t[i++]=this.layerUIDs[r];t[i++]=this._circleIndexStart,t[i++]=this._circleIndexCount,t[i++]=this._circleVertexBuffer.array.length;for(let r=0;r<this._circleVertexBuffer.array.length;r++)n[i++]=this._circleVertexBuffer.array[r];t[i++]=this._circleIndexBuffer.array.length;for(let r=0;r<this._circleIndexBuffer.array.length;r++)t[i++]=this._circleIndexBuffer.array[r];return t.buffer}}var Se=C(35575),Ce=C(11915);class Me extends ue{constructor(e,t,n,i,r,a,o){super(e,t,n),this.type=Y.al.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=r,this._outlineVertexBuffer=a,this._outlineIndexBuffer=o}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(e,t,n){const r=this.zoom,a=this.layer.getPaintProperty("fill-pattern");if(a)if(a.isDataDriven)for(const o of this._features)t(a.getValue(r,o),!0);else t(a.getValue(r),!0)}processFeatures(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,n=this.zoom,{fillMaterial:i,outlineMaterial:r,hasDataDrivenFill:a,hasDataDrivenOutline:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("fill-pattern"),c=null==l?void 0:l.isDataDriven;let f=!l&&t.getPaintValue("fill-antialias",n);if(t.outlineUsesFillColor){if(f&&!t.hasDataDrivenOpacity){const y=t.getPaintValue("fill-opacity",n),g=t.getPaintValue("fill-opacity",n+1);y<1&&g<1&&(f=!1)}if(f&&!t.hasDataDrivenColor){const y=t.getPaintValue("fill-color",n),g=t.getPaintValue("fill-color",n+1);y[3]<1&&g[3]<1&&(f=!1)}}const d=this._features,h=null==e?void 0:e.validateTessellation;if(c){const y=[];for(const g of d){const m=l.getValue(n,g),T=this._spriteInfo[m];if(!T||!T.rect)continue;const x=i.encodeAttributes(g,n,t,T),_=f&&o?r.encodeAttributes(g,n,t):[],p=g.getGeometry(e);y.push({ddFillAttributes:x,ddOutlineAttributes:_,page:T.page,geometry:p}),y.sort((M,B)=>M.page-B.page);for(const{ddFillAttributes:M,ddOutlineAttributes:B,page:I,geometry:P}of y)this._processFeature(P,f,t.outlineUsesFillColor,M,B,h,I)}}else for(const y of d){const g=a?i.encodeAttributes(y,n,t):null,m=f&&o?r.encodeAttributes(y,n,t):null,T=y.getGeometry(e);this._processFeature(T,f,t.outlineUsesFillColor,g,m,h)}}serialize(){let e=10;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._fillIndexStart,t[i++]=this._fillIndexCount,t[i++]=this._outlineIndexStart,t[i++]=this._outlineIndexCount;const r=this._patternMap,a=r.size;if(t[i++]=a,a>0)for(const[o,[l,c]]of r)t[i++]=o,t[i++]=l,t[i++]=c;t[i++]=this._fillVertexBuffer.array.length;for(let o=0;o<this._fillVertexBuffer.array.length;o++)n[i++]=this._fillVertexBuffer.array[o];t[i++]=this._fillIndexBuffer.array.length;for(let o=0;o<this._fillIndexBuffer.array.length;o++)t[i++]=this._fillIndexBuffer.array[o];t[i++]=this._outlineVertexBuffer.array.length;for(let o=0;o<this._outlineVertexBuffer.array.length;o++)n[i++]=this._outlineVertexBuffer.array[o];t[i++]=this._outlineIndexBuffer.array.length;for(let o=0;o<this._outlineIndexBuffer.array.length;o++)t[i++]=this._outlineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,n,i,r,a,o){if(!e)return;const l=e.length;if(t&&(!n||!r||0===r.length))for(let h=0;h<l;h++)this._processOutline(e[h],r);let d;for(let h=0;h<l;h++){const y=Me._area(e[h]);y>32?(void 0!==d&&this._processFill(e,d,i,a,o),d=[h]):y<-32&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(e,d,i,a,o)}_processOutline(e,t){const n=this._outlineVertexBuffer,i=this._outlineIndexBuffer,r=i.index;let a,o,l;const c=new E.E(0,0),f=new E.E(0,0),d=new E.E(0,0);let h=-1,y=-1,g=-1,m=-1,T=-1,x=!1,p=e.length;if(p<2)return;const M=e[0];let B=e[p-1];for(;p&&B.isEqual(M);)--p,B=e[p-1];if(!(p-0<2)){for(let I=0;I<p;++I){0===I?(a=e[p-1],o=e[0],l=e[1],c.assignSub(o,a),c.normalize(),c.rightPerpendicular()):(a=o,o=l,l=I!==p-1?e[I+1]:e[0],c.assign(f));const P=this._isClipEdge(a,o);-1===m&&(x=P),f.assignSub(l,o),f.normalize(),f.rightPerpendicular();const L=c.x*f.y-c.y*f.x;d.assignAdd(c,f),d.normalize();const b=-d.x*-c.x+-d.y*-c.y;let D=Math.abs(0!==b?1/b:1);D>8&&(D=8),L>=0?(g=n.add(o.x,o.y,c.x,c.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,D*-d.x,D*-d.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=n.add(o.x,o.y,d.x,d.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,f.x,f.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g)):(g=n.add(o.x,o.y,D*d.x,D*d.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=n.add(o.x,o.y,-c.x,-c.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=n.add(o.x,o.y,-d.x,-d.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=n.add(o.x,o.y,-f.x,-f.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g))}h>=0&&y>=0&&m>=0&&!x&&i.add(h,y,m),h>=0&&m>=0&&T>=0&&!x&&i.add(h,T,m),this._outlineIndexCount+=3*(i.index-r)}}_processFill(e,t,n,i,r){let a;t.length>1&&(a=[]);let o=0;for(const d of t)0!==o&&a.push(o),o+=e[d].length;const l=2*o,c=Se.Z.acquire();for(const d of t){const h=e[d],y=h.length;for(let g=0;g<y;++g)c.push(h[g].x,h[g].y)}const f=(0,Ce.e)(c,a,2);if(Ce.e.deviation(c,a,2,f)>0){const d=t.map(g=>e[g].length),{buffer:h,vertexCount:y}=(0,ke.b)(c,d);if(y>0){const g=this._fillVertexBuffer.index;for(let m=0;m<y;m++)this._fillVertexBuffer.add(h[2*m],h[2*m+1],n);for(let m=0;m<y;m+=3){const T=g+m;this._fillIndexBuffer.add(T,T+1,T+2)}if(void 0!==r){const m=this._patternMap,T=m.get(r);T?T[1]+=y:m.set(r,[this._fillIndexStart+this._fillIndexCount,y])}this._fillIndexCount+=y}}else{const d=f.length;if(d>0){const h=this._fillVertexBuffer.index;let y=0;for(;y<l;)this._fillVertexBuffer.add(c[y++],c[y++],n);let g=0;for(;g<d;)this._fillIndexBuffer.add(h+f[g++],h+f[g++],h+f[g++]);if(void 0!==r){const m=this._patternMap,T=m.get(r);T?T[1]+=d:m.set(r,[this._fillIndexStart+this._fillIndexCount,d])}this._fillIndexCount+=d}}Se.Z.release(c)}_isClipEdge(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)}static _area(e){let t=0;const n=e.length-1;for(let i=0;i<n;i++)t+=(e[i].x-e[i+1].x)*(e[i].y+e[i+1].y);return t+=(e[n].x-e[0].x)*(e[n].y+e[0].y),.5*t}}var tt=C(46519);class it extends ue{constructor(e,t,n,i,r){super(e,t,n),this.type=Y.al.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=r,this._lineTessellator=new tt.z(nt(this.tessellationProperties),rt(this.tessellationProperties),e.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(e,t,n){const i=this.layer,r=this.zoom,a=i.hasDataDrivenLine,o=i.getPaintProperty("line-pattern"),l=i.getPaintProperty("line-dasharray"),c=i.getLayoutProperty("line-cap");if(!o&&!l)return;const f=(null==c?void 0:c.getValue(r))||0,d=null==c?void 0:c.isDataDriven;if(a){const h=null==o?void 0:o.isDataDriven,y=null==l?void 0:l.isDataDriven;if(!h&&!y)return;for(const g of this._features)t(h?o.getValue(r,g):this._getDashArrayKey(g,r,i,l,d,c,f))}else if(o)t(o.getValue(r));else if(l){const h=l.getValue(r);t(i.getDashKey(h,f))}}processFeatures(e){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const t=this.layer,n=this.zoom,i=this._features,r=this._tessellationOptions,{hasDataDrivenLine:a,lineMaterial:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("line-pattern"),c=t.getPaintProperty("line-dasharray"),f=null==l?void 0:l.isDataDriven,d=null==c?void 0:c.isDataDriven;let h;h=t.getLayoutProperty("line-cap");const y=null!=h&&h.isDataDriven?h:null,g=y?null:t.getLayoutValue("line-cap",n),m=g||0,T=!!y;h=t.getLayoutProperty("line-join");const x=null!=h&&h.isDataDriven?h:null,_=x?null:t.getLayoutValue("line-join",n);h=t.getLayoutProperty("line-miter-limit");const p=null!=h&&h.isDataDriven?h:null,M=p?null:t.getLayoutValue("line-miter-limit",n);h=t.getLayoutProperty("line-round-limit");const B=null!=h&&h.isDataDriven?h:null,I=B?null:t.getLayoutValue("line-round-limit",n);h=t.getPaintProperty("line-width");const P=null!=h&&h.isDataDriven?h:null,L=P?null:t.getPaintValue("line-width",n);h=t.getPaintProperty("line-offset");const b=null!=h&&h.isDataDriven?h:null,D=b?null:t.getPaintValue("line-offset",n);if(f||d){const A=[];for(const w of i){const S=f?l.getValue(n,w):this._getDashArrayKey(w,n,t,c,T,y,m),k=this._spriteInfo[S];if(!k||!k.rect)continue;const R=o.encodeAttributes(w,n,t,k),U=w.getGeometry(e);A.push({ddAttributes:R,page:k.page,cap:y?y.getValue(n,w):g,join:x?x.getValue(n,w):_,miterLimit:p?p.getValue(n,w):M,roundLimit:B?B.getValue(n,w):I,halfWidth:.5*(P?P.getValue(n,w):L),offset:b?b.getValue(n,w):D,geometry:U})}A.sort((w,S)=>w.page-S.page),r.textured=!0;for(const{ddAttributes:w,page:S,cap:k,join:R,miterLimit:U,roundLimit:ee,halfWidth:H,offset:X,geometry:te}of A)r.capType=k,r.joinType=R,r.miterLimit=U,r.roundLimit=ee,r.halfWidth=H,r.offset=X,this._processFeature(te,w,S)}else{r.textured=!(!l&&!c),r.capType=g,r.joinType=_,r.miterLimit=M,r.roundLimit=I,r.halfWidth=.5*L,r.offset=D;for(const A of i){const w=a?o.encodeAttributes(A,n,t):null;y&&(r.capType=y.getValue(n,A)),x&&(r.joinType=x.getValue(n,A)),p&&(r.miterLimit=p.getValue(n,A)),B&&(r.roundLimit=B.getValue(n,A)),P&&(r.halfWidth=.5*P.getValue(n,A)),b&&(r.offset=b.getValue(n,A));const S=A.getGeometry(e);this._processFeature(S,w)}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),n=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._lineIndexStart,t[i++]=this._lineIndexCount;const r=this._patternMap,a=r.size;if(t[i++]=a,a>0)for(const[o,[l,c]]of r)t[i++]=o,t[i++]=l,t[i++]=c;t[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineVertexBuffer.array.length;o++)n[i++]=this.tessellationProperties._lineVertexBuffer.array[o];t[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineIndexBuffer.array.length;o++)t[i++]=this.tessellationProperties._lineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,n){if(!e)return;const i=e.length;for(let r=0;r<i;r++)this._processGeometry(e[r],t,n)}_processGeometry(e,t,n){if(e.length<2)return;let r,a,o=e[0],l=1;for(;l<e.length;)r=e[l].x-o.x,a=e[l].y-o.y,r*r+a*a<1e-6?e.splice(l,1):(o=e[l],++l);if(e.length<2)return;const c=this.tessellationProperties._lineIndexBuffer,f=3*c.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=t,this._lineTessellator.tessellate(e,this._tessellationOptions);const d=3*c.index-f;if(void 0!==n){const h=this._patternMap,y=h.get(n);y?y[1]+=d:h.set(n,[f+this._lineIndexCount,d])}this._lineIndexCount+=d}_getDashArrayKey(e,t,n,i,r,a,o){const l=r?a.getValue(t,e):o,c=i.getValue(t,e);return n.getDashKey(c,l)}}const nt=u=>(e,t,n,i,r,a,o,l,c,f,d)=>(u._lineVertexBuffer.add(e,t,o,l,n,i,r,a,c,f,d,u._ddValues),u._lineVertexBuffer.index-1),rt=u=>(e,t,n)=>{u._lineIndexBuffer.add(e,t,n)};var at=C(6879),Fe=C(77275),Oe=C(13295);function ot(u,e){return u.iconMosaicItem&&e.iconMosaicItem?u.iconMosaicItem.page===e.iconMosaicItem.page?0:u.iconMosaicItem.page-e.iconMosaicItem.page:u.iconMosaicItem&&!e.iconMosaicItem?1:!u.iconMosaicItem&&e.iconMosaicItem?-1:0}class G extends ue{constructor(e,t,n,i,r,a,o,l){super(e,t,l.getSpriteItems()),this.type=Y.al.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._iconVertexBuffer=n,this._iconIndexBuffer=i,this._textVertexBuffer=r,this._textIndexBuffer=a,this._placementEngine=o,this._workerTileHandler=l}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(e,t,n){const i=this.layer,r=this.zoom;e&&e.setExtent(this.layerExtent);const a=i.getLayoutProperty("icon-image"),o=i.getLayoutProperty("text-field");let l=i.getLayoutProperty("text-transform"),c=i.getLayoutProperty("text-font");const f=[];let d,h,y,g;a&&!a.isDataDriven&&(d=a.getValue(r)),o&&!o.isDataDriven&&(h=o.getValue(r)),l&&l.isDataDriven||(y=i.getLayoutValue("text-transform",r),l=null),c&&c.isDataDriven||(g=i.getLayoutValue("text-font",r),c=null);for(const m of this._features){const T=m.getGeometry(e);if(!T||0===T.length)continue;let x,_;a&&(x=a.isDataDriven?a.getValue(r,m):this._replaceKeys(d,m.values),x&&t(x));let p=!1;if(o&&(_=o.isDataDriven?o.getValue(r,m):this._replaceKeys(h,m.values),_)){switch(_=_.replace(/\\n/g,"\n"),l&&(y=l.getValue(r,m)),y){case V._5.LOWERCASE:_=_.toLowerCase();break;case V._5.UPPERCASE:_=_.toUpperCase()}if(G._bidiEngine.hasBidiChar(_)){let P;P="rtl"===G._bidiEngine.checkContextual(_)?"IDNNN":"ICNNN",_=G._bidiEngine.bidiTransform(_,P,"VLYSN"),p=!0}const I=_.length;if(I>0){c&&(g=c.getValue(r,m));for(const P of g){let L=n[P];L||(L=n[P]=new Set);for(let b=0;b<I;b++){const D=_.charCodeAt(b);L.add(D)}}}}if(!x&&!_)continue;const M=i.getLayoutValue("symbol-sort-key",r,m),B={feature:m,sprite:x,label:_,rtl:p,geometry:T,hash:(_?(0,Fe.hP)(_):0)^(x?(0,Fe.hP)(x):0),priority:M,textFont:g};f.push(B)}this._symbolFeatures=f}processFeatures(e){e&&e.setExtent(this.layerExtent);const t=this.layer,n=this.zoom,i=t.getLayoutValue("symbol-placement",n),r=i!==V.R.POINT,a=8*t.getLayoutValue("symbol-spacing",n),o=t.getLayoutProperty("icon-image"),l=t.getLayoutProperty("text-field"),c=o?new Oe._L(t,n,r):null,f=l?new Oe.nj(t,n,r):null,d=this._workerTileHandler;let h;o&&(h=d.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const y=[];let g=1;f&&f.size&&(g=f.size/Z);const m=f?f.maxAngle*v.DT:0,T=f?8*f.size:0;for(const x of this._symbolFeatures){let _,p;c&&h&&x.sprite&&(_=h[x.sprite],_&&_.sdf&&(this._isIconSDF=!0)),_&&c.update(n,x.feature);let M=0;const B=x.label;if(B){f.update(n,x.feature);const I=r?f.keepUpright:f.writingMode&&f.writingMode.includes(V.r1.VERTICAL);let P=.5;switch(f.anchor){case V.nR.TOP_LEFT:case V.nR.LEFT:case V.nR.BOTTOM_LEFT:P=0;break;case V.nR.TOP_RIGHT:case V.nR.RIGHT:case V.nR.BOTTOM_RIGHT:P=1}let L=.5;switch(f.anchor){case V.nR.TOP_LEFT:case V.nR.TOP:case V.nR.TOP_RIGHT:L=0;break;case V.nR.BOTTOM_LEFT:case V.nR.BOTTOM:case V.nR.BOTTOM_RIGHT:L=1}let b=.5;switch(f.justify){case V.vL.AUTO:b=P;break;case V.vL.LEFT:b=0;break;case V.vL.RIGHT:b=1}const D=f.letterSpacing*Z,A=r?0:f.maxWidth*Z,w=f.lineHeight*Z,S=x.textFont.map(k=>d.getGlyphItems(k));if(p=new De(S,A,w,D,P,L,b).getShaping(B,x.rtl,I),p&&p.length>0){let k=1e30,R=-1e30;for(const U of p)k=Math.min(k,U.x),R=Math.max(R,U.x);M=(R-k+48)*g*8}}for(let I of x.geometry){const P=[];if(i===V.R.LINE){if(p&&p.length>0&&f&&f.size){const L=8*f.size*(2+Math.min(2,4*Math.abs(f.offset[1])));I=G._smoothVertices(I,L)}G._pushAnchors(P,I,a,M)}else i===V.R.LINE_CENTER?G._pushCenterAnchor(P,I):x.feature.type===E.V.Polygon?G._pushCentroid(P,I):P.push(new he(I[0].x,I[0].y));for(const L of P){if(L.x<0||L.x>4096||L.y<0||L.y>4096||r&&M>0&&f.rotationAlignment===V.aF.MAP&&!G._honorsTextMaxAngle(I,L,M,m,T))continue;const b={shaping:p,line:I,iconMosaicItem:_,anchor:L,symbolFeature:x,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};y.push(b),this._processFeature(b,c,f)}}}y.sort(ot),this._addPlacedGlyphs(),this._symbolInstances=y}serialize(){let e=11;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=G._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),n=new Int32Array(t.buffer),i=new Float32Array(t.buffer);let r=0;t[r++]=this.type,t[r++]=this.layerUIDs.length;for(let a=0;a<this.layerUIDs.length;a++)t[r++]=this.layerUIDs[a];t[r++]=this._isIconSDF?1:0,t[r++]=this.markerPageMap.size;for(const[a,[o,l]]of this.markerPageMap)t[r++]=a,t[r++]=o,t[r++]=l;t[r++]=this.glyphsPageMap.size;for(const[a,[o,l]]of this.glyphsPageMap)t[r++]=a,t[r++]=o,t[r++]=l;t[r++]=this._iconVertexBuffer.index/4,t[r++]=this._textVertexBuffer.index/4,r=G.serializeSymbols(t,n,i,r,this._symbolInstances),t[r++]=this._iconVertexBuffer.array.length;for(let a=0;a<this._iconVertexBuffer.array.length;a++)n[r++]=this._iconVertexBuffer.array[a];t[r++]=this._iconIndexBuffer.array.length;for(let a=0;a<this._iconIndexBuffer.array.length;a++)t[r++]=this._iconIndexBuffer.array[a];t[r++]=this._textVertexBuffer.array.length;for(let a=0;a<this._textVertexBuffer.array.length;a++)n[r++]=this._textVertexBuffer.array[a];t[r++]=this._textIndexBuffer.array.length;for(let a=0;a<this._textIndexBuffer.array.length;a++)t[r++]=this._textIndexBuffer.array[a];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const n of e||[]){t+=4,t+=1;for(const i of n.textColliders)t+=10;for(const i of n.iconColliders)t+=10;t+=1,t+=2*n.textVertexRanges.length,t+=1,t+=2*n.iconVertexRanges.length}return t}static serializeSymbols(e,t,n,i,r){t[i++]=(r=r||[]).length;for(const a of r){t[i++]=a.anchor.x,t[i++]=a.anchor.y,t[i++]=a.symbolFeature.hash,t[i++]=a.symbolFeature.priority,t[i++]=a.textColliders.length+a.iconColliders.length;for(const o of a.textColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;for(const o of a.iconColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,n[i++]=o.minLod,n[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;t[i++]=a.textVertexRanges.length;for(const[o,l]of a.textVertexRanges)t[i++]=o,t[i++]=l;t[i++]=a.iconVertexRanges.length;for(const[o,l]of a.iconVertexRanges)t[i++]=o,t[i++]=l}return i}_replaceKeys(e,t){return e.replace(/{([^{}]+)}/g,(n,i)=>i in t?t[i]:"")}_processFeature(e,t,n){const{line:i,iconMosaicItem:r,shaping:a,anchor:o}=e,l=this.zoom,c=this.layer,f=!!r;let d=!0;f&&(d=t.optional||!r);const h=a&&a.length>0;let y,g,m=!0;if(h&&(m=n.optional),f&&(y=this._placementEngine.getIconPlacement(o,r,t)),(y||d)&&(h&&(g=this._placementEngine.getTextPlacement(o,a,i,n)),g||m)){if(y&&g||(m||d?m||g?d||y||(g=null):y=null:(y=null,g=null)),g){const T=c.hasDataDrivenText?c.textMaterial.encodeAttributes(e.symbolFeature.feature,l,c):null;if(this._storePlacedGlyphs(e,g.shapes,l,n.rotationAlignment,T),g.textColliders){e.textColliders=g.textColliders;for(const x of g.textColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,L=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,D=x.dxPixels*M+(x.dyPixels+x.height)*p,A=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,A),k=Math.max(B,P,b,A),R=Math.min(I,L,D,w),U=Math.max(I,L,D,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}if(y){const T=c.hasDataDrivenIcon?c.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,c):null;if(this._addPlacedIcons(e,y.shapes,l,r.page,t.rotationAlignment===V.aF.VIEWPORT,T),y.iconColliders){e.iconColliders=y.iconColliders;for(const x of y.iconColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,L=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,D=x.dxPixels*M+(x.dyPixels+x.height)*p,A=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,A),k=Math.max(B,P,b,A),R=Math.min(I,L,D,w),U=Math.max(I,L,D,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}}}_addPlacedIcons(e,t,n,i,r,a){const o=Math.max(n-1,0),l=this._iconVertexBuffer,c=this._iconIndexBuffer,f=this._markerMap;for(const d of t){const h=r?0:Math.max(n+(0,v.k3)(d.minzoom),o),y=r?25:Math.min(n+(0,v.k3)(d.maxzoom),25);if(y<=h)continue;const g=d.tl,m=d.tr,T=d.bl,x=d.br,_=d.mosaicRect,p=d.labelAngle,M=d.minAngle,B=d.maxAngle,I=d.anchor,P=l.index,L=_.x,b=_.y,D=L+_.width,A=b+_.height,w=l.index;l.add(I.x,I.y,g.x,g.y,L,b,p,M,B,h,y,a),l.add(I.x,I.y,m.x,m.y,D,b,p,M,B,h,y,a),l.add(I.x,I.y,T.x,T.y,L,A,p,M,B,h,y,a),l.add(I.x,I.y,x.x,x.y,D,A,p,M,B,h,y,a),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===w?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([w,4]),c.add(P+0,P+1,P+2),c.add(P+1,P+2,P+3),f.has(i)?f.get(i)[1]+=6:f.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,n=this._glyphMap;for(const[i,r]of this._glyphBufferDataStorage)for(const a of r){const o=e.index,l=a.symbolInstance,c=a.ddAttributes,f=e.index;e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tl[0],a.tl[1],a.xmin,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,c),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tr[0],a.tr[1],a.xmax,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,c),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.bl[0],a.bl[1],a.xmin,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,c),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.br[0],a.br[1],a.xmax,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,c),l.textVertexRanges.length>0&&l.textVertexRanges[0][0]+l.textVertexRanges[0][1]===f?l.textVertexRanges[0][1]+=4:l.textVertexRanges.push([f,4]),t.add(o+0,o+1,o+2),t.add(o+1,o+2,o+3),n.has(i)?n.get(i)[1]+=6:n.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,n,i,r){const a=Math.max(n-1,0),o=i===V.aF.VIEWPORT;let l,c,f,d,h,y,g,m,T,x,_;for(const p of t)l=o?0:Math.max(n+(0,v.k3)(p.minzoom),a),c=o?25:Math.min(n+(0,v.k3)(p.maxzoom),25),!(c<=l)&&(f=p.tl,d=p.tr,h=p.bl,y=p.br,g=p.labelAngle,m=p.minAngle,T=p.maxAngle,x=p.anchor,_=p.mosaicRect,this._glyphBufferDataStorage.has(p.page)||this._glyphBufferDataStorage.set(p.page,[]),this._glyphBufferDataStorage.get(p.page).push({glyphAnchor:[x.x,x.y],tl:[f.x,f.y],tr:[d.x,d.y],bl:[h.x,h.y],br:[y.x,y.y],xmin:_.x,ymin:_.y,xmax:_.x+_.width,ymax:_.y+_.height,labelAngle:g,minAngle:m,maxAngle:T,minLod:l,maxLod:c,placementLod:a,symbolInstance:e,ddAttributes:r}))}static _pushAnchors(e,t,n,i){n+=i;let r=0;const a=t.length-1;for(let h=0;h<a;h++)r+=E.E.distance(t[h],t[h+1]);let o=i||n;if(o*=.5,r<=o)return;const l=o/r;let c=0,f=-(n=r/Math.max(Math.round(r/n),1))/2;const d=t.length-1;for(let h=0;h<d;h++){const y=t[h],g=t[h+1],m=g.x-y.x,T=g.y-y.y,x=Math.sqrt(m*m+T*T);let _;for(;f+n<c+x;){f+=n;const p=(f-c)/x,M=(0,v.sX)(y.x,g.x,p),B=(0,v.sX)(y.y,g.y,p);void 0===_&&(_=Math.atan2(T,m)),e.push(new he(M,B,_,h,l))}c+=x}}static _pushCenterAnchor(e,t){let n=0;const i=t.length-1;for(let l=0;l<i;l++)n+=E.E.distance(t[l],t[l+1]);const r=n/2;let a=0;const o=t.length-1;for(let l=0;l<o;l++){const c=t[l],f=t[l+1],d=f.x-c.x,h=f.y-c.y,y=Math.sqrt(d*d+h*h);if(r<a+y){const g=(r-a)/y,m=(0,v.sX)(c.x,f.x,g),T=(0,v.sX)(c.y,f.y,g),x=Math.atan2(h,d);return void e.push(new he(m,T,x,l,0))}a+=y}}static _deviation(e,t,n){return Math.atan2((t.x-e.x)*(n.y-t.y)-(t.y-e.y)*(n.x-t.x),(t.x-e.x)*(n.x-t.x)+(t.y-e.y)*(n.y-t.y))}static _honorsTextMaxAngle(e,t,n,i,r){let a=0;const o=n/2;let l=new E.E(t.x,t.y),c=t.segment+1;for(;a>-o;){if(--c,c<0)return!1;a-=E.E.distance(e[c],l),l=e[c]}a+=E.E.distance(e[c],e[c+1]);const f=[];let d=0;const h=e.length;for(;a<o;){const y=e[c];let g,m=c;do{if(++m,m===h)return!1;g=e[m]}while(g.isEqual(y));let T,x=m;do{if(++x,x===h)return!1;T=e[x]}while(T.isEqual(g));const _=this._deviation(y,g,T);for(f.push({deviation:_,distToAnchor:a}),d+=_;a-f[0].distToAnchor>r;)d-=f.shift().deviation;if(Math.abs(d)>i)return!1;a+=E.E.distance(g,T),c=m}return!0}static _smoothVertices(e,t){if(t<=0)return e;let n=e.length;if(n<3)return e;const i=[];let r=0,a=0;i.push(0);for(let m=1;m<n;m++){const T=E.E.distance(e[m],e[m-1]);T>0&&(r+=T,i.push(r),a++,a!==m&&(e[a]=e[m]))}if(n=a+1,n<3)return e;t=Math.min(t,.2*r);const o=e[0].x,l=e[0].y,c=e[n-1].x,f=e[n-1].y,d=E.E.sub(e[0],e[1]);d.normalize(),e[0].x+=t*d.x,e[0].y+=t*d.y,d.assignSub(e[n-1],e[n-2]),d.normalize(),e[n-1].x+=t*d.x,e[n-1].y+=t*d.y,i[0]-=t,i[n-1]+=t;const h=[];h.push(new E.E(o,l));const y=1e-6,g=.5*t;for(let m=1;m<n-1;m++){let T=0,x=0,_=0;for(let p=m-1;p>=0;p--){const M=g+i[p+1]-i[m];if(M<0)break;const B=i[p+1]-i[p],I=i[m]-i[p]<g?1:M/B;if(I<y)break;const P=I*I,L=I*M-.5*P*B,b=I*B/t,D=e[p+1],A=e[p].x-D.x,w=e[p].y-D.y;T+=b/L*(D.x*I*M+.5*P*(M*A-B*D.x)-P*I*B*A/3),x+=b/L*(D.y*I*M+.5*P*(M*w-B*D.y)-P*I*B*w/3),_+=b}for(let p=m+1;p<n;p++){const M=g-i[p-1]+i[m];if(M<0)break;const B=i[p]-i[p-1],I=i[p]-i[m]<g?1:M/B;if(I<y)break;const P=I*I,L=I*M-.5*P*B,b=I*B/t,D=e[p-1],A=e[p].x-D.x,w=e[p].y-D.y;T+=b/L*(D.x*I*M+.5*P*(M*A-B*D.x)-P*I*B*A/3),x+=b/L*(D.y*I*M+.5*P*(M*w-B*D.y)-P*I*B*w/3),_+=b}h.push(new E.E(T/_,x/_))}return h.push(new E.E(c,f)),e[0].x=o,e[0].y=l,e[n-1].x=c,e[n-1].y=f,h}static _pushCentroid(e,t){const o=t.length-1;let l=0,c=0,f=0,d=t[0].x,h=t[0].y;d>4096&&(d=4096),d<0&&(d=0),h>4096&&(h=4096),h<0&&(h=0);for(let y=1;y<o;y++){let g=t[y].x,m=t[y].y,T=t[y+1].x,x=t[y+1].y;g>4096&&(g=4096),g<0&&(g=0),m>4096&&(m=4096),m<0&&(m=0),T>4096&&(T=4096),T<0&&(T=0),x>4096&&(x=4096),x<0&&(x=0);const _=(g-d)*(x-h)-(T-d)*(m-h);l+=_*(d+g+T),c+=_*(h+m+x),f+=_}l/=3*f,c/=3*f,isNaN(l)||isNaN(c)||e.push(new he(l,c))}}G._bidiEngine=new at.Z;var J,ze=C(47018);!function(u){u[u.INITIALIZED=0]="INITIALIZED",u[u.NO_DATA=1]="NO_DATA",u[u.READY=2]="READY",u[u.MODIFIED=3]="MODIFIED",u[u.INVALID=4]="INVALID"}(J||(J={}));class ut{constructor(e,t,n,i,r){if(this._pbfTiles={},this._tileClippers={},this._client=n,this._tile=t,r){this._styleLayerUIDs=new Set;for(const f of r)this._styleLayerUIDs.add(f)}this._styleRepository=i,this._layers=this._styleRepository.layers;const[a,o,l]=t.tileKey.split("/").map(parseFloat);this._level=a;const c=8+Math.max(5*(this._level-14),0);for(const f of Object.keys(e)){const d=e[f];if(this._pbfTiles[f]=new Ye.Z(new Uint8Array(d.protobuff),new DataView(d.protobuff)),d.refKey){const[h]=d.refKey.split("/").map(parseFloat),y=a-h;if(y>0){const g=(1<<y)-1;this._tileClippers[f]=new ze.b(y,o&g,l&g,8,c)}}this._tileClippers[f]||(this._tileClippers[f]=new ze.I)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}parse(e){var t=this;return(0,le.Z)(function*(){const n=(0,ke.j)(),i=t._initialize(e),{returnedBuckets:r}=i;t._processLayers(i),t._linkReferences(i),t._filterFeatures(i);const a=[],o=new Set,l=(d,h)=>{o.has(d)||(a.push({name:d,repeat:h}),o.add(d))},c={};for(const d of r)d.getResources(d.tileClipper,l,c);if(t._tile.status===J.INVALID)return[];const f=t._fetchResources(a,c,e);return Promise.all([...f,n]).then(()=>t._processFeatures(i.returnedBuckets))})()}_initialize(e){return{signal:e&&e.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,layers:n,zoom:i,sourceNameToTileClipper:r,sourceNameToUniqueSourceLayerBuckets:a,sourceNameToUniqueSourceLayers:o,returnedBuckets:l,layerIdToBucket:c,referencerUIDToReferencedId:f}=e;for(let d=n.length-1;d>=0;d--){const h=n[d];if(!this._canParseStyleLayer(h.uid)||h.minzoom&&i<Math.floor(h.minzoom)||h.maxzoom&&i>=h.maxzoom||h.type===V.fR.BACKGROUND||!t[h.source]||!r[h.source])continue;const g=r[h.source],m=h.sourceLayer,T=t[h.source][m];if(T){let x=o[h.source];if(x||(x=o[h.source]=new Set),x.add(h.sourceLayer),h.refLayerId)f.set(h.uid,h.refLayerId);else{const _=this._createBucket(h);if(_){_.layerUIDs=[h.uid],_.layerExtent=T.extent,_.tileClipper=g;let p=a[h.source];p||(p=a[h.source]={});let M=p[m];M||(M=p[m]=[]),M.push(_),l.push(_),c[h.id]=_}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:n}=e;n.forEach((i,r)=>{t[i]&&t[i].layerUIDs.push(r)})}_filterFeatures(e){const{signal:t,sourceNameToTileData:n,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:r}=e,a=10*this._level,o=10*(this._level+1),l=[],c=[];for(const f of Object.keys(r))r[f].forEach(d=>{l.push(d),c.push(f)});for(let f=0;f<l.length;f++){const d=c[f],h=l[f];if(!n[d]||!i[d])continue;const y=n[d][h],g=i[d][h];if(!g||0===g.length)continue;if((0,me.Hc)(t))return;const m=y.getData();for(;m.nextTag(2);){const T=m.getMessage(),x=new Je(T,y);T.release();const _=x.values;if(_){const p=_._minzoom;if(p&&p>=o)continue;const M=_._maxzoom;if(M&&M<=a)continue}for(const p of g)p.pushFeature(x)}}}_fetchResources(e,t,n){const i=[],r=this._tile.getWorkerTileHandler();let a,o;e.length>0&&(a=r.fetchSprites(e,this._client,n),i.push(a));for(const l in t){const c=t[l];c.size>0&&(o=r.fetchGlyphs(this._tile.tileKey,l,c,this._client,n),i.push(o))}return i}_processFeatures(e){const t=e.filter(n=>n.hasFeatures()||this._canParseStyleLayer(n.layer.uid));for(const n of t)n.processFeatures(n.tileClipper);return t}_parseTileData(e){const t={};for(const n of Object.keys(e)){const i=e[n],r={};for(;i.next();)switch(i.tag()){case 3:{const a=i.getMessage(),o=new Ie(a);a.release(),r[o.name]=o;break}default:i.skip()}t[n]=r}return t}_createBucket(e){switch(e.type){case V.fR.BACKGROUND:return null;case V.fR.FILL:return this._createFillBucket(e);case V.fR.LINE:return this._createLineBucket(e);case V.fR.CIRCLE:return this._createCircleBucket(e);case V.fR.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new Me(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Qe(e.fillMaterial.getStride()),new ne,new $e(e.outlineMaterial.getStride()),new ne)}_createLineBucket(e){return new it(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Xe(e.lineMaterial.getStride()),new ne)}_createCircleBucket(e){return new et(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new qe(e.circleMaterial.getStride()),new ne)}_createSymbolBucket(e){const t=this._tile;return new G(e,this._level,new Re(e.iconMaterial.getStride()),new ne,new Re(e.textMaterial.getStride()),new ne,t.placementEngine,t.getWorkerTileHandler())}}class ft{constructor(e,t,n,i){this.status=J.INITIALIZED,this.placementEngine=new je,this.tileKey=e,this.refKeys=t,this._workerTileHandler=n,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=J.INITIALIZED,this._workerTileHandler=null}parse(e,t){var n=this;return(0,le.Z)(function*(){const i=t&&t.signal;if((0,He.pC)(i)){const d=()=>{i.removeEventListener("abort",d),n.status=J.INVALID};i.addEventListener("abort",d)}let r;const a={bucketsWithData:[],emptyBuckets:null};try{r=yield n._parse(e,t)}catch(d){if((0,me.D_)(d))throw d;return{result:a,transferList:[]}}n.status=J.READY;const o=a.bucketsWithData,l=[];for(const d of r)if(d.hasFeatures()){const h=d.serialize();o.push(h)}else l.push(d.layer.uid);const c=[...o];let f=null;return l.length>0&&(f=Uint32Array.from(l),c.push(f.buffer)),a.emptyBuckets=f,{result:a,transferList:c}})()}setObsolete(){this.status=J.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}_parse(e,t){var n=this;return(0,le.Z)(function*(){const i=e.sourceName2DataAndRefKey;return 0===Object.keys(i).length?[]:(n.status=J.MODIFIED,new ut(i,n,t.client,n._styleRepository,e.styleLayerUIDs).parse(t))})()}}var dt=C(78364);class yt{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){var e;return null==(e=this._styleRepository)?void 0:e.layers}createTileAndParse(e,t){var n=this;return(0,le.Z)(function*(){const{key:i}=e,r={};for(const o of Object.keys(e.sourceName2DataAndRefKey))r[o]=e.sourceName2DataAndRefKey[o].refKey;const a=new ft(i,r,n,n._styleRepository);try{return yield a.parse(e,t)}catch(o){if(a.setObsolete(),a.release(),!(0,me.D_)(o))throw o;return null}})()}updateStyle(e){if(!e||0===e.length||!this._styleRepository)return;const t=this._styleRepository;for(const n of e){const r=n.data;switch(n.type){case Y.Fr.PAINTER_CHANGED:t.setPaintProperties(r.layer,r.paint);break;case Y.Fr.LAYOUT_CHANGED:t.setLayoutProperties(r.layer,r.layout);break;case Y.Fr.LAYER_REMOVED:t.deleteStyleLayer(r.layer);break;case Y.Fr.LAYER_CHANGED:t.setStyleLayer(r.layer,r.index);break;case Y.Fr.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(e){this._styleRepository=new dt.Z(e),this._spriteInfo={},this._glyphInfo={}}fetchSprites(e,t,n){const i=[],r=this._spriteInfo;for(const a of e)void 0===r[a.name]&&i.push(a);return 0===i.length?Promise.resolve():t.invoke("getSprites",i,{signal:n&&n.signal}).then(a=>{for(const o in a)r[o]=a[o]})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(e,t,n,i,r){const a=[];let o=this._glyphInfo[t];return o?n.forEach(l=>{o[l]||a.push(l)}):(o=this._glyphInfo[t]=[],n.forEach(l=>a.push(l))),0===a.length?Promise.resolve():i.invoke("getGlyphs",{tileID:e,font:t,codePoints:a},r).then(l=>{for(let c=0;c<l.length;c++)l[c]&&(o[c]=l[c])})}getGlyphItems(e){return this._glyphInfo[e]}}}}]);