"use strict";var De=Object.defineProperty,$e=Object.defineProperties,Ge=Object.getOwnPropertyDescriptors,jt=Object.getOwnPropertySymbols,Ne=Object.prototype.hasOwnProperty,Be=Object.prototype.propertyIsEnumerable,Dt=(E,w,l)=>w in E?De(E,w,{enumerable:!0,configurable:!0,writable:!0,value:l}):E[w]=l,dt=(E,w)=>{for(var l in w||(w={}))Ne.call(w,l)&&Dt(E,l,w[l]);if(jt)for(var l of jt(w))Be.call(w,l)&&Dt(E,l,w[l]);return E},xt=(E,w)=>$e(E,Ge(w));(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[2435],{12435:(E,w,l)=>{l.r(w),l.d(w,{meshFeatureSetFromJSON:()=>Se});var $t=l(88879),f=l(62208),ot=l(2004),U=l(15861),R=l(17626),it=l(26584),Gt=l(80542),Nt=l(47996),C=l(63290),Bt=l(60330),N=l(10699),Wt=l(32917),P=l(77712),Yt=(l(90912),l(85931),l(76898)),d=l(28093),Kt=l(21674),I=l(72642),Vt=l(37118),A=l(89586),B=l(61751),_=l(99746),tt=l(92529),Ht=l(85334),z=l(55915),et=l(92545),at=l(60853);const lt=C.Z.getLogger("esri.geometry.support.meshUtils.centerAt");const _t=(0,d.c)(),te=(0,d.c)();var vt=l(21726);function ct(){return(ct=(0,U.Z)(function*(t,n,e){const{loadGLTFMesh:r}=yield(0,N.Hl)(l.e(9185).then(l.bind(l,29185)),e),s=yield yt(n,e),i=r(new I.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),s.url,{resolveFile:ne(s),useTransform:!0,signal:(0,f.pC)(e)?e.signal:null});i.then(()=>s.dispose(),()=>s.dispose());const{vertexAttributes:o,components:a}=yield i;t.vertexAttributes=o,t.components=a})).apply(this,arguments)}function ne(t){const n=(0,vt.Yd)(t.url);return e=>{var i;const r=(0,vt.PF)(e,n,n),s=r?r.replace(/^ *\.\//,""):null;return null!=(i=s?t.files.get(s):null)?i:e}}function yt(t,n){return ft.apply(this,arguments)}function ft(){return(ft=(0,U.Z)(function*(t,n){return t instanceof Blob?W.fromBlob(t):"string"==typeof t?new W(t):Array.isArray(t)?re(t,n):se(t,n)})).apply(this,arguments)}function re(t,n){return pt.apply(this,arguments)}function pt(){return pt=(0,U.Z)(function*(t,n){const e=new Map;let r=null;const s=yield(0,N.WW)(t.map(function(){var o=(0,U.Z)(function*(a){return{name:a.name,source:yield yt(a instanceof Blob?a:a.source,n)}});return function(a){return o.apply(this,arguments)}}())),i=[];for(const o of s)o&&((0,N.Hc)(n)?o.source.dispose():i.push(o));(0,N.k_)(n);for(const{name:o,source:a}of i)((0,f.Wi)(r)||/\.(gltf|glb)/i.test(o))&&(r=a.url),e.set(o,a.url),a.files&&a.files.forEach((c,p)=>e.set(p,c));if((0,f.Wi)(r))throw new it.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new W(r,()=>i.forEach(({source:o})=>o.dispose()),e)}),pt.apply(this,arguments)}function se(t,n){return ut.apply(this,arguments)}function ut(){return ut=(0,U.Z)(function*(t,n){const{default:e}=yield(0,N.Hl)(Promise.resolve().then(l.bind(l,84792)),n),r="string"==typeof t.multipart[0]?yield Promise.all(t.multipart.map(function(){var s=(0,U.Z)(function*(i){return(yield e(i,{responseType:"array-buffer"})).data});return function(i){return s.apply(this,arguments)}}())):t.multipart;return W.fromBlob(new Blob(r))}),ut.apply(this,arguments)}class W{constructor(n,e=(()=>{}),r=new Map){this.url=n,this.dispose=e,this.files=r}static fromBlob(n){const e=URL.createObjectURL(n);return new W(e,()=>URL.revokeObjectURL(e))}}var Ct=l(30217),ht=l(550),At=l(43703),y=l(84161),gt=l(81863),v=l(65231);function bt(t,n){if(t)for(let e=0;e<t.length;e+=3)for(let r=0;r<3;r++)t[e+r]+=n[r]}const ce=(0,d.c)(),wt=(0,At.c)(),Zt=(0,ht.c)(),q={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function nt(t,n,e){t.isPlane||function de(t){for(let n=0;n<t.position.length;n+=3)t.position[n+2]+=.5}(t),function xe(t,n){if(null==n)return;const e="number"==typeof n?[n,n,n]:[null!=n.width?n.width:1,null!=n.depth?n.depth:1,null!=n.height?n.height:1];j[0]=e[0],j[4]=e[1],j[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let s=0;s<3;s++)x[s]=t.position[r+s];(0,y.t)(x,x,j);for(let s=0;s<3;s++)t.position[r+s]=x[s]}if(e[0]!==e[1]||e[1]!==e[2]){j[0]=1/e[0],j[4]=1/e[1],j[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let s=0;s<3;s++)x[s]=t.normal[r+s];(0,y.t)(x,x,j),(0,y.n)(x,x);for(let s=0;s<3;s++)t.normal[r+s]=x[s]}}}(t,null==e?void 0:e.size);const{vertexAttributes:r,transform:s}=(0,at.w1)(t,n,e);return{vertexAttributes:new tt.Q(xt(dt({},r),{uv:t.uv})),transform:s,components:[new B.Z({faces:t.faces,material:e&&e.material||null})],spatialReference:n.spatialReference}}const ve={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},ye={south:0,east:1,north:2,west:3,up:4,down:5},x=(0,d.c)(),j=(0,ht.c)();var Ce=l(28347);const Ft=C.Z.getLogger("esri.geometry.support.meshUtils.rotate");function H(t,n,e,r=d.Z){if(!(0,f.Wi)(t)){(0,Ce.d)(rt,(0,A.WH)(n),(0,A.ZZ)(n));for(let s=0;s<t.length;s+=e){for(let i=0;i<3;i++)X[i]=t[s+i]-r[i];(0,y.m)(X,X,rt);for(let i=0;i<3;i++)t[s+i]=X[i]+r[i]}}}const X=(0,d.c)(),Mt=(0,d.c)(),Rt=(0,A.Ue)(),rt=(0,At.c)(),Pt=(0,ht.c)(),Lt=(0,d.c)(),Ot=C.Z.getLogger("esri.geometry.support.meshUtils.scale");function St(t,n,e=d.Z){if(t)for(let r=0;r<t.length;r+=3){for(let s=0;s<3;s++)J[s]=t[r+s]-e[s];(0,y.g)(J,J,n);for(let s=0;s<3;s++)t[r+s]=J[s]+e[s]}}const J=(0,d.c)(),Et=(0,d.c)(),It=(0,d.c)();var L;const G="esri.geometry.Mesh";let Z=L=class extends((0,Gt.p)(Nt.Z.LoadableMixin((0,Bt.v)(Kt.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new tt.Q,this.type="mesh"}initialize(){((0,f.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add((0,Wt.YP)(()=>{var t;return{vertexAttributes:this.vertexAttributes,components:null==(t=this.components)?void 0:t.map(n=>n.clone())}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&(0,f.pC)(this.external)&&(0,f.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const t=this.vertexAttributes.position,n=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new ot.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new I.Z({x:0,y:0,z:0,spatialReference:n})};const e=(0,f.pC)(this.transform)?this.transform.project(t,n):t;let r=1/0,s=1/0,i=1/0,o=-1/0,a=-1/0,c=-1/0,p=0,u=0,h=0;const g=e.length,m=1/(g/3);let F=0;for(;F<g;){const T=e[F++],b=e[F++],O=e[F++];r=Math.min(r,T),s=Math.min(s,b),i=Math.min(i,O),o=Math.max(o,T),a=Math.max(a,b),c=Math.max(c,O),p+=m*T,u+=m*b,h+=m*O}return{extent:new ot.Z({xmin:r,ymin:s,zmin:i,xmax:o,ymax:a,zmax:c,spatialReference:n}),center:new I.Z({x:p,y:u,z:h,spatialReference:n})}}get anchor(){if((0,f.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this._boundingInfo;return new I.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,f.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&(0,f.pC)(this.external)&&(0,f.pC)(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(B.Z.from(t)),this.notifyChange("components")):C.Z.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const n=this.components.indexOf(t);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}C.Z.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else C.Z.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,n,e,r){return(0,A.uT)(mt.x,t,Q),(0,A.uT)(mt.y,n,zt),(0,A.uT)(mt.z,e,Tt),(0,A.qC)(Q,zt,Q),(0,A.qC)(Q,Tt,Q),function Ae(t,n,e){var s,i;if(!t.vertexAttributes||!t.vertexAttributes.position||0===n[3])return;const r=t.spatialReference;if((0,f.pC)(t.transform)){null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&Ft.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=null!=(s=null==e?void 0:e.origin)?s:t.transform.getOriginPoint(r);!function be(t,n,e){const r=(0,y.s)(X,e.x,e.y,e.z),s=(0,y.b)(X,r,t.origin);t.applyLocalInverse(s,Mt),t.rotation=(0,A.qC)(t.rotation,n,(0,A.Ue)()),t.applyLocalInverse(s,s),(0,y.b)(s,s,Mt),t.translation=(0,y.a)((0,d.c)(),t.translation,s)}(t.transform,n,o)}else{const o=null!=(i=null==e?void 0:e.origin)?i:t.origin;(0,et.h)(t.spatialReference,e)?function we(t,n,e){const r=t.spatialReference,s=(0,gt.rS)(r),i=Lt;(0,z.KC)(e,i,s)||(0,z.KC)(t.origin,i,s);const o=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,p=new Float64Array(o.length),u=(0,f.pC)(a)?new Float32Array(a.length):null,h=(0,f.pC)(c)?new Float32Array(c.length):null;(0,z.Bm)(s,i,rt,s),(0,Ct.f)(Pt,rt);const g=Rt;(0,y.t)((0,A.ZZ)(Rt),(0,A.ZZ)(n),Pt),g[3]=n[3],(0,v.XO)(o,r,p),(0,f.pC)(a)&&(0,f.pC)(u)&&(0,v.Iz)(a,o,p,r,u),(0,f.pC)(c)&&(0,f.pC)(h)&&(0,v.wi)(c,o,p,r,h),H(p,g,3,i),(0,v.To)(p,o,r),(0,f.pC)(a)&&(0,f.pC)(u)&&(H(u,g,3),(0,v.Yk)(u,o,p,r,a)),(0,f.pC)(c)&&(0,f.pC)(h)&&(H(h,g,4),(0,v.M2)(h,o,p,r,c)),t.vertexAttributesChanged()}(t,n,o):function Ze(t,n,e){const r=Lt;if(!(0,z.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Ft.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}H(t.vertexAttributes.position,n,3,r),H(t.vertexAttributes.normal,n,3),H(t.vertexAttributes.tangent,n,4),t.vertexAttributesChanged()}(t,n,o)}}(this,Q,r),this}offset(t,n,e,r){return this.loaded?(st[0]=t,st[1]=n,st[2]=e,function oe(t,n,e){t.vertexAttributes&&t.vertexAttributes.position&&((0,f.pC)(t.transform)?(null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&C.Z.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function ie(t,n){const e=t.origin;t.origin=(0,y.a)((0,d.c)(),e,n)}(t.transform,n)):(0,et.h)(t.spatialReference,e)?function ae(t,n){const e=t.spatialReference,r=t.vertexAttributes.position,s=t.vertexAttributes.normal,i=t.vertexAttributes.tangent,o=new Float64Array(r.length),a=(0,f.pC)(s)?new Float32Array(s.length):null,c=(0,f.pC)(i)?new Float32Array(i.length):null,p=t.extent.center,u=ce;(0,z.Bm)(e,[p.x,p.y,p.z],wt,(0,gt.rS)(e)),(0,Ct.f)(Zt,wt),(0,y.t)(u,n,Zt),(0,v.XO)(r,e,o),(0,f.pC)(s)&&(0,f.pC)(a)&&(0,v.Iz)(s,r,o,e,a),(0,f.pC)(i)&&(0,f.pC)(c)&&(0,v.wi)(i,r,o,e,c),bt(o,u),(0,v.To)(o,r,e),(0,f.pC)(s)&&(0,f.pC)(a)&&(0,v.Yk)(a,r,o,e,s),(0,f.pC)(i)&&(0,f.pC)(c)&&(0,v.M2)(c,r,o,e,i),t.vertexAttributesChanged()}(t,n):function le(t,n){bt(t.vertexAttributes.position,n),t.vertexAttributesChanged()}(t,n))}(this,st,r),this):(C.Z.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,n){return this.loaded?(function Fe(t,n,e){var s;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,f.pC)(t.transform)){null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&Ot.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const i=null!=(s=null==e?void 0:e.origin)?s:t.transform.getOriginPoint(r);!function Me(t,n,e){const r=(0,y.s)(J,e.x,e.y,e.z),s=(0,y.b)(J,r,t.origin);t.applyLocalInverse(s,Et);const i=(0,y.g)((0,d.c)(),t.scale,n);t.scale=i,t.applyLocalInverse(s,s),(0,y.b)(s,s,Et),t.translation=(0,y.a)((0,d.c)(),t.translation,s)}(t.transform,n,i)}else{const i=(0,et.h)(t.spatialReference,e),o=e&&e.origin||t.origin;i?function Re(t,n,e){const r=t.spatialReference,s=(0,gt.rS)(r),i=It;(0,z.KC)(e,i,s)||(0,z.KC)(t.origin,i,s);const o=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,p=new Float64Array(o.length),u=(0,f.pC)(a)?new Float32Array(a.length):null,h=(0,f.pC)(c)?new Float32Array(c.length):null;(0,v.XO)(o,r,p),(0,f.pC)(a)&&(0,f.pC)(u)&&(0,v.Iz)(a,o,p,r,u),(0,f.pC)(c)&&(0,f.pC)(h)&&(0,v.wi)(c,o,p,r,h),St(p,n,i),(0,v.To)(p,o,r),(0,f.pC)(a)&&(0,f.pC)(u)&&(0,v.Yk)(u,o,p,r,a),(0,f.pC)(c)&&(0,f.pC)(h)&&(0,v.M2)(h,o,p,r,c),t.vertexAttributesChanged()}(t,n,o):function Pe(t,n,e){const r=It;if(!(0,z.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Ot.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}St(t.vertexAttributes.position,n,r),t.vertexAttributesChanged()}(t,n,o)}}(this,t,n),this):(C.Z.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,n){return this.loaded?(function Xt(t,n,e){var s;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=null!=(s=null==e?void 0:e.origin)?s:t.origin;(0,f.pC)(t.transform)?(null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&lt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function Jt(t,n,e){const o=t.origin;t.origin=[o[0]+(n.x-e.x),o[1]+(n.y-e.y),o[2]+(n.hasZ&&e.hasZ?n.z-e.z:0)]}(t.transform,n,r)):(0,et.h)(t.spatialReference,e)?function Qt(t,n,e){const r=(0,at.FF)(t.vertexAttributes,e,{geographic:!0}),{position:s,normal:i,tangent:o}=(0,at.iv)(r,n,{geographic:!0});t.vertexAttributes.position=s,t.vertexAttributes.normal=i,t.vertexAttributes.tangent=o,t.vertexAttributesChanged()}(t,n,r):function kt(t,n,e){const r=te,s=_t;if((0,z.KC)(n,s,t.spatialReference)){if(!(0,z.KC)(e,r,t.spatialReference)){const i=t.origin;r[0]=i.x,r[1]=i.y,r[2]=i.z,lt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function qt(t,n,e){if(t)for(let r=0;r<t.length;r+=3)for(let s=0;s<3;s++)t[r+s]+=n[s]-e[s]})(t.vertexAttributes.position,s,r),t.vertexAttributesChanged()}else lt.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,n,r)}(this,t,n),this):(C.Z.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,f.pC)(this.external)&&this.addResolvingPromise(function ee(t,n,e){return ct.apply(this,arguments)}(this,this.external.source,t)),Promise.resolve(this)}updateExternalSource(t){this._set("external",t)}clone(){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map(s=>s.cloneWithDeduplication(e,r))}const n={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,f.pC)(this.transform)?this.transform.clone():null,external:(0,f.pC)(this.external)?{source:this.external.source,extent:(0,f.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new L(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toBinaryGLTF(t){var n=this;return(0,U.Z)(function*(){const e=l.e(4367).then(l.bind(l,54367)),r=n.load(),s=yield Promise.all([e,r]),{toBinaryGLTF:i}=s[0];return i(n,t)})()}static createBox(t,n){if(!(t instanceof I.Z))return C.Z.getLogger(G).error(".createBox()","expected location to be a Point instance"),null;const e=new L(nt(function fe(){const{faceDescriptions:t,faceVertexOffsets:n,uvScales:e}=ve,r=4*t.length,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let c=0,p=0,u=0,h=0;for(let g=0;g<t.length;g++){const m=t[g],F=c/3;for(const b of n)a[h++]=F+b;const T=m.corners;for(let b=0;b<4;b++){const O=T[b];let M=0;o[u++]=.25*e[b][0]+m.uvOrigin[0],o[u++]=m.uvOrigin[1]-.25*e[b][1];for(let S=0;S<3;S++)0!==m.axis[S]?(s[c++]=.5*m.axis[S],i[p++]=m.axis[S]):(s[c++]=.5*O[M++],i[p++]=0)}}return{position:s,normal:i,uv:o,faces:a}}(),t,n));return n&&n.imageFace&&"all"!==n.imageFace?function pe(t,n){const e=t.components[0],r=e.faces,s=ye[n],i=6*s,o=new Array(6),a=new Array(r.length-6);let c=0,p=0;for(let u=0;u<r.length;u++)u>=i&&u<i+6?o[c++]=r[u]:a[p++]=r[u];if((0,f.pC)(t.vertexAttributes.uv)){const u=new Float32Array(t.vertexAttributes.uv),h=4*s*2,g=[0,1,1,1,1,0,0,0];for(let m=0;m<g.length;m++)u[h+m]=g[m];t.vertexAttributes.uv=u}return t.components=[new B.Z({faces:o,material:e.material}),new B.Z({faces:a})],t}(e,n.imageFace):e}static createSphere(t,n){return t instanceof I.Z?new L(nt(function ue(t=0){const n=Math.round(8*2**t),e=2*n,r=(n-1)*(e+1)+2*e,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array((n-1)*e*2*3);let c=0,p=0,u=0,h=0;for(let g=0;g<=n;g++){const m=g/n*Math.PI+.5*Math.PI,F=Math.cos(m),T=Math.sin(m);x[2]=T;const b=0===g||g===n,O=b?e-1:e;for(let M=0;M<=O;M++){const S=M/O*2*Math.PI;x[0]=-Math.sin(S)*F,x[1]=Math.cos(S)*F;for(let $=0;$<3;$++)s[c]=.5*x[$],i[c]=x[$],++c;o[p++]=(M+(b?.5:0))/e,o[p++]=g/n,0!==g&&M!==e&&(g!==n&&(a[u++]=h,a[u++]=h+1,a[u++]=h-e),1!==g&&(a[u++]=h,a[u++]=h-e,a[u++]=h-e-1)),h++}}return{position:s,normal:i,uv:o,faces:a}}(n&&n.densificationFactor||0),t,n)):(C.Z.getLogger(G).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,n){return t instanceof I.Z?new L(nt(function he(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),a=new Uint32Array(4*e*3);let c=0,p=0,u=0,h=0,g=0;for(let m=0;m<=5;m++){const F=0===m||5===m,T=m<=1||m>=4,b=2===m||4===m,O=F?e-1:e;for(let M=0;M<=O;M++){const S=M/O*2*Math.PI,$=F?0:.5;x[0]=$*Math.sin(S),x[1]=$*-Math.cos(S),x[2]=m<=2?.5:-.5;for(let k=0;k<3;k++)s[c++]=x[k],i[p++]=T?2===k?m<=1?1:-1:0:2===k?0:x[k]/$;o[u++]=(M+(F?.5:0))/e,o[u++]=m<=1?1*m/3:m<=3?1*(m-2)/3+1/3:1*(m-4)/3+2/3,b||0===m||M===e||(5!==m&&(a[h++]=g,a[h++]=g+1,a[h++]=g-e),1!==m&&(a[h++]=g,a[h++]=g-e,a[h++]=g-e-1)),g++}}return{position:s,normal:i,uv:o,faces:a}}(n&&n.densificationFactor||0),t,n)):(C.Z.getLogger(G).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,n){var s;if(!(t instanceof I.Z))return C.Z.getLogger(G).error(".createPlane()","expected location to be a Point instance"),null;const e=null!=(s=null==n?void 0:n.facing)?s:"up",r=function ge(t,n){const e="number"==typeof n?n:null!=n?n.width:1,r="number"==typeof n?n:null!=n?n.height:1;switch(t){case"up":case"down":return{width:e,depth:r};case"north":case"south":return{width:e,height:r};case"east":case"west":return{depth:e,height:r}}}(e,null==n?void 0:n.size);return new L(nt(function me(t){const n=q.facingAxisOrderSwap[t],e=q.position,r=q.normal,s=new Float64Array(e.length),i=new Float32Array(r.length);let o=0;for(let a=0;a<4;a++){const c=o;for(let p=0;p<3;p++){const u=n[p],h=Math.abs(u)-1,g=u>=0?1:-1;s[o]=e[c+h]*g,i[o]=r[c+h]*g,o++}}return{position:s,normal:i,uv:new Float32Array(q.uv),faces:new Uint32Array(q.faces),isPlane:!0}}(e),t,xt(dt({},n),{size:r})))}static createFromPolygon(t,n){var r;if(!(t instanceof Vt.Z))return C.Z.getLogger(G).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const e=(0,Ht.bT)(t);return new L({vertexAttributes:new tt.Q({position:e.position}),components:[new B.Z({faces:e.faces,shading:"flat",material:null!=(r=null==n?void 0:n.material)?r:null})],spatialReference:t.spatialReference})}static createFromGLTF(t,n,e){return(0,U.Z)(function*(){if(!(t instanceof I.Z))throw C.Z.getLogger(G).error(".createfromGLTF()","expected location to be a Point instance"),new it.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=yield(0,N.Hl)(l.e(9185).then(l.bind(l,29185)),e);return new L(yield r(t,n,e))})()}static createWithExternalSource(t,n,e){var o,a,c,p;const r=null!=(o=null==e?void 0:e.extent)?o:null,s=null!=(c=null==(a=null==e?void 0:e.transform)?void 0:a.clone())?c:new _.Z;return s.origin=[t.x,t.y,null!=(p=t.z)?p:0],new L({external:{source:n,extent:r},transform:s,spatialReference:t.spatialReference})}static createIncomplete(t,n){var i,o,a;const e=null!=(o=null==(i=null==n?void 0:n.transform)?void 0:i.clone())?o:new _.Z;e.origin=[t.x,t.y,null!=(a=t.z)?a:0];const s=new L({transform:e,spatialReference:t.spatialReference});return s.addResolvingPromise(Promise.reject(new it.Z("mesh-incomplete","Mesh resources are not complete"))),s}};(0,R._)([(0,P.Cb)({type:[B.Z],json:{write:!0}})],Z.prototype,"components",void 0),(0,R._)([(0,P.Cb)({type:_.Z,json:{write:!0}})],Z.prototype,"transform",void 0),(0,R._)([(0,P.Cb)({constructOnly:!0})],Z.prototype,"external",void 0),(0,R._)([(0,P.Cb)({readOnly:!0})],Z.prototype,"hasExtent",null),(0,R._)([(0,P.Cb)({readOnly:!0})],Z.prototype,"_boundingInfo",null),(0,R._)([(0,P.Cb)({readOnly:!0})],Z.prototype,"anchor",null),(0,R._)([(0,P.Cb)({readOnly:!0})],Z.prototype,"origin",null),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1}})],Z.prototype,"extent",null),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Z.prototype,"hasZ",void 0),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Z.prototype,"hasM",void 0),(0,R._)([(0,P.Cb)({type:tt.Q,nonNullable:!0,json:{write:!0}})],Z.prototype,"vertexAttributes",void 0),Z=L=(0,R._)([(0,Yt.j)(G)],Z);const mt={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},Q=(0,A.Ue)(),zt=(0,A.Ue)(),Tt=(0,A.Ue)(),st=(0,d.c)(),Ut=Z;var D,t,Le=l(65234),Oe=l(17253);function Se(t,n,e){var u;const r=e.features;e.features=[],delete e.geometryType;const s=Oe.Z.fromJSON(e);if(s.geometryType="mesh",!e.assetMaps)return s;const i=function Ue(t,n){const e=new Map;for(const r of n){const s=r.parentGlobalId;if(null==s)continue;const i=r.assetName,o=r.assetURL,a=r.conversionStatus;let c=e.get(s);if(null==c)switch(c={name:i,status:D.FAILED,url:o,projectVertices:je(r.flags).projectVertices},e.set(s,c),a){case"COMPLETED":case"SUBMITTED":c.status=D.COMPLETED;break;case"INPROGRESS":c.status=D.PENDING;break;default:c.status=D.FAILED}else console.warn(`Multiple asset parts not expected. Ignoring additional parts. conflicting assetname: ${r.assetName}`)}return e}(0,e.assetMaps),o=null!=(u=s.spatialReference)?u:Le.Z.WGS84,a=e.globalIdFieldName,{outFields:c}=t,p=(0,f.pC)(c)&&c.length>0?function Ee(t){return({attributes:n})=>{if(!n)return{};if(!t)return n;for(const e in n)t.has(e)||delete n[e];return n}}(c.includes("*")?null:new Set(c)):()=>({});for(const h of r){const g=Ie(h,a,o,n,i);(0,f.pC)(g)&&s.features.push(new $t.Z({geometry:g,attributes:p(h)}))}return s}function Ie(t,n,e,r,s){const o=s.get(t.attributes[n]);if(null==o||o.status===D.FAILED||null==o.url)return null;const a=function ze({attributes:t},n,{transformFieldRoles:e}){return new I.Z({x:t[e.originX],y:t[e.originY],z:t[e.originZ],spatialReference:n})}(t,e,r),c=ot.Z.fromJSON(t.geometry);c.spatialReference=e;const p=function Te(t,{transformFieldRoles:n},e){return new _.Z({translation:[t[n.translationX],-t[n.translationZ],t[n.translationY]],rotation:(0,A.uT)([t[n.rotationX],t[n.rotationZ],t[n.rotationY]],t[n.rotationDeg]),scale:[t[n.scaleX],t[n.scaleY],t[n.scaleZ]],geographic:e})}(t.attributes,r,o.projectVertices);return o.status===D.PENDING?Ut.createIncomplete(a,{extent:c,transform:p}):Ut.createWithExternalSource(a,[{name:o.name,source:o.url}],{extent:c,transform:p})}function je(t){return{projectVertices:t.includes("PROJECT_VERTICES")}}(t=D||(D={}))[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}}]);