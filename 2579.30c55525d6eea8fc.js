"use strict";var je=Object.defineProperty,Ge=Object.defineProperties,$e=Object.getOwnPropertyDescriptors,jt=Object.getOwnPropertySymbols,Be=Object.prototype.hasOwnProperty,We=Object.prototype.propertyIsEnumerable,Gt=(I,b,l)=>b in I?je(I,b,{enumerable:!0,configurable:!0,writable:!0,value:l}):I[b]=l,vt=(I,b)=>{for(var l in b||(b={}))Be.call(b,l)&&Gt(I,l,b[l]);if(jt)for(var l of jt(b))We.call(b,l)&&Gt(I,l,b[l]);return I},yt=(I,b)=>Ge(I,$e(b));(self.webpackChunkexample_app=self.webpackChunkexample_app||[]).push([[2579],{42579:(I,b,l)=>{l.r(b),l.d(b,{meshFeatureSetFromJSON:()=>Le});var $t=l(88879),p=l(62208),at=l(2004),z=l(15861),R=l(17626),lt=l(26584),Bt=l(80542),Wt=l(47996),q=l(63290),Ht=l(60330),$=l(10699),Yt=l(32917),P=l(77712),Kt=(l(85931),l(8314),l(90912),l(76898)),d=l(28093),Xt=l(21674),L=l(49672),Jt=l(37118),A=l(89586),B=l(61751),tt=l(99746),et=l(92529),Qt=l(85334),U=l(55915),nt=l(92545),ct=l(60853);const ft=q.Z.getLogger("esri.geometry.support.meshUtils.centerAt");const ee=(0,d.c)(),ne=(0,d.c)();var At=l(21726);function pt(){return(pt=(0,z.Z)(function*(t,n,e){const{loadGLTFMesh:r}=yield(0,$.Hl)(l.e(9185).then(l.bind(l,29185)),e),o=yield Ct(n,e),s=r(new L.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:oe(o),useTransform:!0,signal:(0,p.pC)(e)?e.signal:null});s.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:i,components:a}=yield s;t.vertexAttributes=i,t.components=a})).apply(this,arguments)}function oe(t){const n=(0,At.Yd)(t.url);return e=>{var s;const r=(0,At.PF)(e,n,n),o=r?r.replace(/^ *\.\//,""):null;return null!=(s=t.files.get(o))?s:e}}function Ct(t,n){return ut.apply(this,arguments)}function ut(){return(ut=(0,z.Z)(function*(t,n){return t instanceof Blob?W.fromBlob(t):"string"==typeof t?new W(t):Array.isArray(t)?se(t,n):ie(t,n)})).apply(this,arguments)}function se(t,n){return ht.apply(this,arguments)}function ht(){return ht=(0,z.Z)(function*(t,n){const e=new Map;let r=null;const o=yield(0,$.WW)(t.map(function(){var i=(0,z.Z)(function*(a){return{name:a.name,source:yield Ct(a instanceof Blob?a:a.source,n)}});return function(a){return i.apply(this,arguments)}}())),s=[];for(const i of o)i&&((0,$.Hc)(n)?i.source.dispose():s.push(i));(0,$.k_)(n);for(const{name:i,source:a}of s)((0,p.Wi)(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),e.set(i,a.url),a.files&&a.files.forEach((c,f)=>e.set(f,c));if((0,p.Wi)(r))throw new lt.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new W(r,()=>s.forEach(({source:i})=>i.dispose()),e)}),ht.apply(this,arguments)}function ie(t,n){return mt.apply(this,arguments)}function mt(){return mt=(0,z.Z)(function*(t,n){const{default:e}=yield(0,$.Hl)(Promise.resolve().then(l.bind(l,84792)),n),r="string"==typeof t.multipart[0]?yield Promise.all(t.multipart.map(function(){var o=(0,z.Z)(function*(s){return(yield e(s,{responseType:"array-buffer"})).data});return function(s){return o.apply(this,arguments)}}())):t.multipart;return W.fromBlob(new Blob(r))}),mt.apply(this,arguments)}class W{constructor(n,e=(()=>{}),r=new Map){this.url=n,this.dispose=e,this.files=r}static fromBlob(n){const e=URL.createObjectURL(n);return new W(e,()=>URL.revokeObjectURL(e))}}var bt=l(30217),gt=l(550),wt=l(43703),y=l(84161),dt=l(12080),v=l(65231);const ae=q.Z.getLogger("esri.geometry.support.meshUtils.offset");function Ft(t,n){if(t)for(let e=0;e<t.length;e+=3)for(let r=0;r<3;r++)t[e+r]+=n[r]}const ue=(0,d.c)(),Mt=(0,wt.c)(),Rt=(0,gt.c)(),_={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function rt(t,n,e){t.isPlane||function ye(t){for(let n=0;n<t.position.length;n+=3)t.position[n+2]+=.5}(t),function Ae(t,n){if(null==n)return;const e="number"==typeof n?[n,n,n]:[null!=n.width?n.width:1,null!=n.depth?n.depth:1,null!=n.height?n.height:1];D[0]=e[0],D[4]=e[1],D[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let o=0;o<3;o++)x[o]=t.position[r+o];(0,y.t)(x,x,D);for(let o=0;o<3;o++)t.position[r+o]=x[o]}if(e[0]!==e[1]||e[1]!==e[2]){D[0]=1/e[0],D[4]=1/e[1],D[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let o=0;o<3;o++)x[o]=t.normal[r+o];(0,y.t)(x,x,D),(0,y.n)(x,x);for(let o=0;o<3;o++)t.normal[r+o]=x[o]}}}(t,e&&e.size);const{vertexAttributes:r,transform:o}=(0,ct.w1)(t,n,e);return{vertexAttributes:new et.Q(yt(vt({},r),{uv:t.uv})),transform:o,components:[new B.Z({faces:t.faces,material:e&&e.material||null})],spatialReference:n.spatialReference}}const Ce={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},be={south:0,east:1,north:2,west:3,up:4,down:5},x=(0,d.c)(),D=(0,gt.c)();var we=l(28347);const Zt=q.Z.getLogger("esri.geometry.support.meshUtils.rotate");function X(t,n,e,r=d.Z){if(!(0,p.Wi)(t)){(0,we.d)(ot,(0,A.WH)(n),(0,A.ZZ)(n));for(let o=0;o<t.length;o+=e){for(let s=0;s<3;s++)J[s]=t[o+s]-r[s];(0,y.m)(J,J,ot);for(let s=0;s<3;s++)t[o+s]=J[s]+r[s]}}}const J=(0,d.c)(),Pt=(0,d.c)(),Et=(0,A.Ue)(),ot=(0,wt.c)(),Ot=(0,gt.c)(),St=(0,d.c)(),It=q.Z.getLogger("esri.geometry.support.meshUtils.scale");function Lt(t,n,e=d.Z){if(t)for(let r=0;r<t.length;r+=3){for(let o=0;o<3;o++)Q[o]=t[r+o]-e[o];(0,y.g)(Q,Q,n);for(let o=0;o<3;o++)t[r+o]=Q[o]+e[o]}}const Q=(0,d.c)(),Ut=(0,d.c)(),Tt=(0,d.c)();var E;const Z=q.Z.getLogger("esri.geometry.Mesh");let w=E=class extends((0,Bt.p)(Wt.Z.LoadableMixin((0,Ht.v)(Xt.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new et.Q,this.type="mesh"}initialize(){((0,p.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add((0,Yt.YP)(()=>{var t;return{vertexAttributes:this.vertexAttributes,components:null==(t=this.components)?void 0:t.map(n=>n.clone()),transform:(0,p.pC)(this.transform)?this.transform.clone():null}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,n=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new at.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new L.Z({x:0,y:0,z:0,spatialReference:n})};const e=(0,p.pC)(this.transform)?this.transform.project(t,n):t;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,c=-1/0,f=0,u=0,g=0;const m=e.length,h=1/(m/3);let F=0;for(;F<m;){const T=e[F++],C=e[F++],O=e[F++];r=Math.min(r,T),o=Math.min(o,C),s=Math.min(s,O),i=Math.max(i,T),a=Math.max(a,C),c=Math.max(c,O),f+=h*T,u+=h*C,g+=h*O}return{extent:new at.Z({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:c,spatialReference:n}),center:new L.Z({x:f,y:u,z:g,spatialReference:n})}}get anchor(){if((0,p.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new L.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,p.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(B.Z.from(t)),this.notifyChange("components")):Z.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const n=this.components.indexOf(t);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}Z.error("removeComponent()","Provided component is not part of the list of components")}else Z.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,n,e,r){return(0,A.uT)(xt.x,t,V),(0,A.uT)(xt.y,n,zt),(0,A.uT)(xt.z,e,Dt),(0,A.qC)(V,zt,V),(0,A.qC)(V,Dt,V),function Fe(t,n,e){var o,s;if(!t.vertexAttributes||!t.vertexAttributes.position||0===n[3])return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&Zt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const i=null!=(o=null==e?void 0:e.origin)?o:t.transform.getOriginPoint(r);!function Me(t,n,e){const r=(0,y.s)(J,e.x,e.y,e.z),o=(0,y.b)(J,r,t.origin);t.applyLocalInverse(o,Pt),t.rotation=(0,A.qC)(t.rotation,n,(0,A.Ue)()),t.applyLocalInverse(o,o),(0,y.b)(o,o,Pt),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,i)}else{const i=null!=(s=null==e?void 0:e.origin)?s:t.origin;(0,nt.h)(t.spatialReference,e)?function Re(t,n,e){const r=t.spatialReference,o=(0,dt.rS)(r),s=St;(0,U.KC)(e,s,o)||(0,U.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,f=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(c)?new Float32Array(c.length):null;(0,U.Bm)(o,s,ot,o),(0,bt.f)(Ot,ot);const m=Et;(0,y.t)((0,A.ZZ)(Et),(0,A.ZZ)(n),Ot),m[3]=n[3],(0,v.XO)(i,r,f),(0,p.pC)(a)&&(0,v.Iz)(a,i,f,r,u),(0,p.pC)(c)&&(0,v.wi)(c,i,f,r,g),X(f,m,3,s),(0,v.To)(f,i,r),(0,p.pC)(a)&&(X(u,m,3),(0,v.Yk)(u,i,f,r,a)),(0,p.pC)(c)&&(X(g,m,4),(0,v.M2)(g,i,f,r,c)),t.vertexAttributesChanged()}(t,n,i):function Ze(t,n,e){const r=St;if(!(0,U.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Zt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}X(t.vertexAttributes.position,n,3,r),X(t.vertexAttributes.normal,n,3),X(t.vertexAttributes.tangent,n,4),t.vertexAttributesChanged()}(t,n,i)}}(this,V,r),this}offset(t,n,e,r){return this.loaded?(st[0]=t,st[1]=n,st[2]=e,function le(t,n,e){t.vertexAttributes&&t.vertexAttributes.position&&((0,p.pC)(t.transform)?(null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&ae.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function ce(t,n){const e=t.origin;t.origin=(0,y.a)((0,d.c)(),e,n)}(t.transform,n)):(0,nt.h)(t.spatialReference,e)?function fe(t,n){const e=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=(0,p.pC)(o)?new Float32Array(o.length):null,c=(0,p.pC)(s)?new Float32Array(s.length):null,f=t.extent.center,u=ue;(0,U.Bm)(e,[f.x,f.y,f.z],Mt,(0,dt.rS)(e)),(0,bt.f)(Rt,Mt),(0,y.t)(u,n,Rt),(0,v.XO)(r,e,i),(0,p.pC)(o)&&(0,v.Iz)(o,r,i,e,a),(0,p.pC)(s)&&(0,v.wi)(s,r,i,e,c),Ft(i,u),(0,v.To)(i,r,e),(0,p.pC)(o)&&(0,v.Yk)(a,r,i,e,o),(0,p.pC)(s)&&(0,v.M2)(c,r,i,e,s),t.vertexAttributesChanged()}(t,n):function pe(t,n){Ft(t.vertexAttributes.position,n),t.vertexAttributesChanged()}(t,n))}(this,st,r),this):(Z.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,n){return this.loaded?(function Pe(t,n,e){var o;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&It.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const s=null!=(o=null==e?void 0:e.origin)?o:t.transform.getOriginPoint(r);!function Ee(t,n,e){const r=(0,y.s)(Q,e.x,e.y,e.z),o=(0,y.b)(Q,r,t.origin);t.applyLocalInverse(o,Ut);const s=(0,y.g)((0,d.c)(),t.scale,n);t.scale=s,t.applyLocalInverse(o,o),(0,y.b)(o,o,Ut),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,s)}else{const s=(0,nt.h)(t.spatialReference,e),i=e&&e.origin||t.origin;s?function Oe(t,n,e){const r=t.spatialReference,o=(0,dt.rS)(r),s=Tt;(0,U.KC)(e,s,o)||(0,U.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,f=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(c)?new Float32Array(c.length):null;(0,v.XO)(i,r,f),(0,p.pC)(a)&&(0,v.Iz)(a,i,f,r,u),(0,p.pC)(c)&&(0,v.wi)(c,i,f,r,g),Lt(f,n,s),(0,v.To)(f,i,r),(0,p.pC)(a)&&(0,v.Yk)(u,i,f,r,a),(0,p.pC)(c)&&(0,v.M2)(g,i,f,r,c),t.vertexAttributesChanged()}(t,n,i):function Se(t,n,e){const r=Tt;if(!(0,U.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,It.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Lt(t.vertexAttributes.position,n,r),t.vertexAttributesChanged()}(t,n,i)}}(this,t,n),this):(Z.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,n){return this.loaded?(function Vt(t,n,e){var o;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=null!=(o=null==e?void 0:e.origin)?o:t.origin;(0,p.pC)(t.transform)?(null!=(null==e?void 0:e.geographic)&&e.geographic!==t.transform.geographic&&ft.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function kt(t,n,e){const i=t.origin;t.origin=[i[0]+(n.x-e.x),i[1]+(n.y-e.y),i[2]+(n.hasZ&&e.hasZ?n.z-e.z:0)]}(t.transform,n,r)):(0,nt.h)(t.spatialReference,e)?function qt(t,n,e){const r=(0,ct.FF)(t.vertexAttributes,e,{geographic:!0}),{position:o,normal:s,tangent:i}=(0,ct.iv)(r,n,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,n,r):function _t(t,n,e){const r=ne,o=ee;if((0,U.KC)(n,o,t.spatialReference)){if(!(0,U.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,ft.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function te(t,n,e){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=n[o]-e[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else ft.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,n,r)}(this,t,n),this):(Z.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,p.pC)(this.external)&&this.addResolvingPromise(function re(t,n,e){return pt.apply(this,arguments)}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,n=this.components?new Map:null,e={components:this.components?this.components.map(r=>r.cloneWithDeduplication(t,n)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,p.pC)(this.transform)?this.transform.clone():null,external:(0,p.pC)(this.external)?{source:this.external.source,extent:(0,p.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new E(e)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toBinaryGLTF(t){var n=this;return(0,z.Z)(function*(){const{toBinaryGLTF:e}=yield l.e(7627).then(l.bind(l,57627));return e(n,t)})()}static createBox(t,n){if(!(t instanceof L.Z))return Z.error(".createBox()","expected location to be a Point instance"),null;const e=new E(rt(function he(){const{faceDescriptions:t,faceVertexOffsets:n,uvScales:e}=Ce,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let c=0,f=0,u=0,g=0;for(let m=0;m<t.length;m++){const h=t[m],F=c/3;for(const C of n)a[g++]=F+C;const T=h.corners;for(let C=0;C<4;C++){const O=T[C];let M=0;i[u++]=.25*e[C][0]+h.uvOrigin[0],i[u++]=h.uvOrigin[1]-.25*e[C][1];for(let S=0;S<3;S++)0!==h.axis[S]?(o[c++]=.5*h.axis[S],s[f++]=h.axis[S]):(o[c++]=.5*O[M++],s[f++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,n));return n&&n.imageFace&&"all"!==n.imageFace?function me(t,n){const e=t.components[0],r=e.faces,o=be[n],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let c=0,f=0;for(let u=0;u<r.length;u++)u>=s&&u<s+6?i[c++]=r[u]:a[f++]=r[u];if((0,p.pC)(t.vertexAttributes.uv)){const u=new Float32Array(t.vertexAttributes.uv),g=4*o*2,m=[0,1,1,1,1,0,0,0];for(let h=0;h<m.length;h++)u[g+h]=m[h];t.vertexAttributes.uv=u}return t.components=[new B.Z({faces:i,material:e.material}),new B.Z({faces:a})],t}(e,n.imageFace):e}static createSphere(t,n){return t instanceof L.Z?new E(rt(function ge(t=0){const n=Math.round(8*2**t),e=2*n,r=(n-1)*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((n-1)*e*2*3);let c=0,f=0,u=0,g=0;for(let m=0;m<=n;m++){const h=m/n*Math.PI+.5*Math.PI,F=Math.cos(h),T=Math.sin(h);x[2]=T;const C=0===m||m===n,O=C?e-1:e;for(let M=0;M<=O;M++){const S=M/O*2*Math.PI;x[0]=-Math.sin(S)*F,x[1]=Math.cos(S)*F;for(let j=0;j<3;j++)o[c]=.5*x[j],s[c]=x[j],++c;i[f++]=(M+(C?.5:0))/e,i[f++]=m/n,0!==m&&M!==e&&(m!==n&&(a[u++]=g,a[u++]=g+1,a[u++]=g-e),1!==m&&(a[u++]=g,a[u++]=g-e,a[u++]=g-e-1)),g++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(Z.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,n){return t instanceof L.Z?new E(rt(function de(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(4*e*3);let c=0,f=0,u=0,g=0,m=0;for(let h=0;h<=5;h++){const F=0===h||5===h,T=h<=1||h>=4,C=2===h||4===h,O=F?e-1:e;for(let M=0;M<=O;M++){const S=M/O*2*Math.PI,j=F?0:.5;x[0]=j*Math.sin(S),x[1]=j*-Math.cos(S),x[2]=h<=2?.5:-.5;for(let k=0;k<3;k++)o[c++]=x[k],s[f++]=T?2===k?h<=1?1:-1:0:2===k?0:x[k]/j;i[u++]=(M+(F?.5:0))/e,i[u++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,C||0===h||M===e||(5!==h&&(a[g++]=m,a[g++]=m+1,a[g++]=m-e),1!==h&&(a[g++]=m,a[g++]=m-e,a[g++]=m-e-1)),m++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(Z.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,n){var o;if(!(t instanceof L.Z))return Z.error(".createPlane()","expected location to be a Point instance"),null;const e=null!=(o=null==n?void 0:n.facing)?o:"up",r=function xe(t,n){const e="number"==typeof n?n:null!=n?n.width:1,r="number"==typeof n?n:null!=n?n.height:1;switch(t){case"up":case"down":return{width:e,depth:r};case"north":case"south":return{width:e,height:r};case"east":case"west":return{depth:e,height:r}}}(e,null==n?void 0:n.size);return new E(rt(function ve(t){const n=_.facingAxisOrderSwap[t],e=_.position,r=_.normal,o=new Float64Array(e.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const c=i;for(let f=0;f<3;f++){const u=n[f],g=Math.abs(u)-1,m=u>=0?1:-1;o[i]=e[c+g]*m,s[i]=r[c+g]*m,i++}}return{position:o,normal:s,uv:new Float32Array(_.uv),faces:new Uint32Array(_.faces),isPlane:!0}}(e),t,yt(vt({},n),{size:r})))}static createFromPolygon(t,n){if(!(t instanceof Jt.Z))return Z.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const e=(0,Qt.bT)(t);return new E({vertexAttributes:new et.Q({position:e.position}),components:[new B.Z({faces:e.faces,shading:"flat",material:n&&n.material||null})],spatialReference:t.spatialReference})}static createFromGLTF(t,n,e){return(0,z.Z)(function*(){if(!(t instanceof L.Z))throw Z.error(".createfromGLTF()","expected location to be a Point instance"),new lt.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=yield(0,$.Hl)(l.e(9185).then(l.bind(l,29185)),e);return new E(yield r(t,n,e))})()}static createWithExternalSource(t,n,e){var i,a,c;const r=null!=(i=null==e?void 0:e.extent)?i:null,o=null!=(a=null==e?void 0:e.transform.clone())?a:new tt.Z;return o.origin=[t.x,t.y,null!=(c=t.z)?c:0],new E({external:{source:n,extent:r},transform:o,spatialReference:t.spatialReference})}static createIncomplete(t,n){var s,i;const e=null!=(s=null==n?void 0:n.transform.clone())?s:new tt.Z;e.origin=[t.x,t.y,null!=(i=t.z)?i:0];const o=new E({transform:e,spatialReference:t.spatialReference});return o.addResolvingPromise(Promise.reject(new lt.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,R._)([(0,P.Cb)({type:[B.Z],json:{write:!0}})],w.prototype,"components",void 0),(0,R._)([(0,P.Cb)({type:tt.Z,json:{write:!0}})],w.prototype,"transform",void 0),(0,R._)([(0,P.Cb)({constructOnly:!0})],w.prototype,"external",void 0),(0,R._)([(0,P.Cb)({readOnly:!0})],w.prototype,"hasExtent",null),(0,R._)([(0,P.Cb)({readOnly:!0})],w.prototype,"boundingInfo",null),(0,R._)([(0,P.Cb)({readOnly:!0})],w.prototype,"anchor",null),(0,R._)([(0,P.Cb)({readOnly:!0})],w.prototype,"origin",null),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1}})],w.prototype,"extent",null),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],w.prototype,"hasZ",void 0),(0,R._)([(0,P.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],w.prototype,"hasM",void 0),(0,R._)([(0,P.Cb)({type:et.Q,nonNullable:!0,json:{write:!0}})],w.prototype,"vertexAttributes",void 0),w=E=(0,R._)([(0,Kt.j)("esri.geometry.Mesh")],w);const xt={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},V=(0,A.Ue)(),zt=(0,A.Ue)(),Dt=(0,A.Ue)(),st=(0,d.c)(),Nt=w;var G,it,t;(t=G||(G={})).featureGUID="featureGUID",t.assetName="assetName",t.hash="hash",t.type="type",t.conversionStatus="conversionStatus",t.flags="flags",t.complexity="complexity",t.size="size",t.seqNo="seqNo",t.sourceHash="sourceHash",t.assetURL="assetURL",function(t){t.SUBMITTED="SUBMITTED",t.INPROGRESS="INPROGRESS",t.FAILED="FAILED",t.COMPLETED="COMPLETED"}(it||(it={}));var N,Ie=l(17253);function Le(t,n,e){const r=e.features;e.features=[],delete e.geometryType;const o=Ie.default.fromJSON(e);o.geometryType="mesh";const s=o.spatialReference,i=(0,p.Wi)(t.outFields)||!t.outFields.length?()=>({}):function Ue(t){return({attributes:n})=>{if(!n)return{};if(!t)return n;for(const e in n)t.has(e)||delete n[e];return n}}(t.outFields.includes("*")?null:new Set(t.outFields));for(const a of r){const c=Te(a,s,n);(0,p.pC)(c)&&o.features.push(new $t.Z({geometry:c,attributes:i(a)}))}return o}function Te(t,n,e){const{status:r,source:o}=function Ne(t){if(!t.assetMappings)return{status:N.FAILED};const n=[],e=new Map;for(const r of t.assetMappings){const o=r[G.seqNo],s=r[G.assetName],i=r[G.assetURL],a=r[G.conversionStatus];if(a===it.FAILED)return{status:N.FAILED};if(a!==it.COMPLETED)return{status:N.PENDING};if(null==o)n.push({name:s,source:i});else{const c=e.get(s);let f;c?f=c.multipart:(f=[],n.push({name:s,source:{multipart:f}}),e.set(s,{multipart:f})),f[o]=i}}return{status:N.COMPLETED,source:n}}(t);if(r===N.FAILED)return null;const s=function ze({attributes:t},n,{transformFieldRoles:e}){return new L.Z({x:t[e.originX],y:t[e.originY],z:t[e.originZ],spatialReference:n})}(t,n,e),i=at.Z.fromJSON(t.geometry);i.spatialReference=n;const a=function De({attributes:t,assetMappings:n},{transformFieldRoles:e}){var r;return new tt.Z({translation:[t[e.translationX],t[e.translationY],t[e.translationZ]],rotation:(0,A.uT)([t[e.rotationX],t[e.rotationY],t[e.rotationZ]],t[e.rotationDeg]),scale:[t[e.scaleX],t[e.scaleY],t[e.scaleZ]],geographic:!(null!=(r=n[G.flags])&&r.includes("PROJECT_VERTICES"))})}(t,e);return r===N.PENDING?Nt.createIncomplete(s,{extent:i,transform:a}):Nt.createWithExternalSource(s,o,{extent:i,transform:a})}!function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}(N||(N={}))}}]);